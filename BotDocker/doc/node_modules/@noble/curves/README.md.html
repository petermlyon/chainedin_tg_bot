<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "node_modules/@noble/curves/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#noble-curves">noble-curves</a>
      </div>

      <div class="heading h3">
        <a href="#this-library-belongs-to-noble-cryptography">This library belongs to noble cryptography</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h3">
        <a href="#implementations">Implementations</a>
      </div>

      <div class="heading h4">
        <a href="#ecdsa-signature-scheme">ECDSA signature scheme</a>
      </div>

      <div class="heading h4">
        <a href="#ecdsa-public-key-recovery-and-extra-entropy">ECDSA public key recovery &amp;amp; extra entropy</a>
      </div>

      <div class="heading h4">
        <a href="#ecdh-elliptic-curve-diffie-hellman">ECDH: Elliptic Curve Diffie-Hellman</a>
      </div>

      <div class="heading h4">
        <a href="#schnorr-signatures-over-secp256k1-bip340">Schnorr signatures over secp256k1 (BIP340)</a>
      </div>

      <div class="heading h4">
        <a href="#ed25519-x25519-ristretto255">ed25519, X25519, ristretto255</a>
      </div>

      <div class="heading h4">
        <a href="#ed448-x448-decaf448">ed448, X448, decaf448</a>
      </div>

      <div class="heading h4">
        <a href="#bls12-381">bls12-381</a>
      </div>

      <div class="heading h4">
        <a href="#all-available-imports">All available imports</a>
      </div>

      <div class="heading h4">
        <a href="#accessing-a-curves-variables">Accessing a curve&#39;s variables</a>
      </div>

      <div class="heading h2">
        <a href="#abstract-api">Abstract API</a>
      </div>

      <div class="heading h3">
        <a href="#weierstrass-short-weierstrass-curve">weierstrass: Short Weierstrass curve</a>
      </div>

      <div class="heading h3">
        <a href="#edwards-twisted-edwards-curve">edwards: Twisted Edwards curve</a>
      </div>

      <div class="heading h3">
        <a href="#montgomery-montgomery-curve">montgomery: Montgomery curve</a>
      </div>

      <div class="heading h3">
        <a href="#bls-barreto-lynn-scott-curves">bls: Barreto-Lynn-Scott curves</a>
      </div>

      <div class="heading h3">
        <a href="#hash-to-curve-hashing-strings-to-curve-points">hash-to-curve: Hashing strings to curve points</a>
      </div>

      <div class="heading h3">
        <a href="#poseidon-poseidon-hash">poseidon: Poseidon hash</a>
      </div>

      <div class="heading h3">
        <a href="#modular-modular-arithmetics-utilities">modular: Modular arithmetics utilities</a>
      </div>

      <div class="heading h4">
        <a href="#creating-private-keys-from-hashes">Creating private keys from hashes</a>
      </div>

      <div class="heading h3">
        <a href="#utils-useful-utilities">utils: Useful utilities</a>
      </div>

      <div class="heading h2">
        <a href="#security">Security</a>
      </div>

      <div class="heading h3">
        <a href="#constant-timeness">Constant-timeness</a>
      </div>

      <div class="heading h3">
        <a href="#supply-chain-security">Supply chain security</a>
      </div>

      <div class="heading h3">
        <a href="#randomness">Randomness</a>
      </div>

      <div class="heading h2">
        <a href="#speed">Speed</a>
      </div>

      <div class="heading h2">
        <a href="#upgrading">Upgrading</a>
      </div>

      <div class="heading h2">
        <a href="#contributing-and-testing">Contributing &amp;amp; testing</a>
      </div>

      <div class="heading h2">
        <a href="#resources">Resources</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="noble-curves">
  <h1>
    <a href="#noble-curves" name="noble-curves" class="pilcrow"></a>
noble-curves
  </h1>
</div>
<p>Audited &amp; minimal JS implementation of elliptic curve cryptography.</p>
<ul>
<li>üîí <a href="#security.html"><strong>Audited</strong></a> by an independent security firms</li>
<li>üîª Tree-shakeable: unused code is excluded from your builds</li>
<li>üèé Fast: hand-optimized for caveats of JS engines</li>
<li>üîç Reliable: property-based / cross-library / wycheproof tests and fuzzing ensure correctness</li>
<li>‚û∞ Short Weierstrass, Edwards, Montgomery curves</li>
<li>‚úçÔ∏è ECDSA, EdDSA, Schnorr, BLS signature schemes, ECDH key agreement, hashing to curves</li>
<li>üîñ SUF-CMA, SBS (non-repudiation), ZIP215 (consensus friendliness) features for ed25519</li>
<li>üßú‚Äç‚ôÇÔ∏è Poseidon ZK-friendly hash</li>
<li>ü™∂ 178KB (87KB gzipped) for everything including bundled hashes, 22KB (10KB gzipped) for single-curve build</li>
</ul>
<p>For discussions, questions and support, visit
<a href="https://github.com/paulmillr/noble-curves/discussions">GitHub Discussions</a>
section of the repository.</p>
<div class="pilwrap" id="this-library-belongs-to-noble-cryptography">
  <h3>
    <a href="#this-library-belongs-to-noble-cryptography" name="this-library-belongs-to-noble-cryptography" class="pilcrow"></a>
This library belongs to <em>noble</em> cryptography
  </h3>
</div>
<blockquote>
<p><strong>noble cryptography</strong> ‚Äî high-security, easily auditable set of contained cryptographic libraries and tools.</p>
</blockquote>
<ul>
<li>Zero or minimal dependencies</li>
<li>Highly readable TypeScript / JS code</li>
<li>PGP-signed releases and transparent NPM builds</li>
<li>All libraries:
<a href="https://github.com/paulmillr/noble-ciphers">ciphers</a>,
<a href="https://github.com/paulmillr/noble-curves">curves</a>,
<a href="https://github.com/paulmillr/noble-hashes">hashes</a>,
<a href="https://github.com/paulmillr/noble-post-quantum">post-quantum</a>,
4kb <a href="https://github.com/paulmillr/noble-secp256k1">secp256k1</a> /
<a href="https://github.com/paulmillr/noble-ed25519">ed25519</a></li>
<li><a href="https://paulmillr.com/noble/">Check out homepage</a>
for reading resources, documentation and apps built with noble</li>
</ul>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<blockquote>
<p>npm install @noble/curves</p>
</blockquote>
<p>We support all major platforms and runtimes.
For <a href="https://deno.land">Deno</a>, ensure to use <a href="https://deno.land/manual@v1.28.0/node/npm_specifiers">npm specifier</a>.
For React Native, you may need a <a href="https://github.com/LinusU/react-native-get-random-values">polyfill for getRandomValues</a>.
A standalone file <a href="https://github.com/paulmillr/noble-curves/releases">noble-curves.js</a> is also available.</p>
<pre><code class="js"><span class="hljs-comment">// import * from '@noble/curves'; // Error: use sub-imports, to ensure small app size</span>
<span class="hljs-keyword">import</span> { secp256k1 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>; <span class="hljs-comment">// ESM and Common.js</span>
<span class="hljs-comment">// import { secp256k1 } from 'npm:@noble/curves@1.4.0/secp256k1'; // Deno</span>
</code></pre>
<ul>
<li><a href="#implementations.html">Implementations</a>
<ul>
<li><a href="#ecdsa-signature-scheme.html">ECDSA signature scheme</a></li>
<li><a href="#ecdsa-public-key-recovery--extra-entropy.html">ECDSA public key recovery &amp; extra entropy</a></li>
<li><a href="#ecdh-elliptic-curve-diffie-hellman.html">ECDH: Elliptic Curve Diffie-Hellman</a></li>
<li><a href="#schnorr-signatures-over-secp256k1-bip340.html">Schnorr signatures over secp256k1, BIP340</a></li>
<li><a href="#ed25519-x25519-ristretto255.html">ed25519, X25519, ristretto255</a></li>
<li><a href="#ed448-x448-decaf448.html">ed448, X448, decaf448</a></li>
<li><a href="#bls12-381.html">bls12-381</a></li>
<li><a href="#all-available-imports.html">All available imports</a></li>
<li><a href="#accessing-a-curves-variables.html">Accessing a curve's variables</a></li>
</ul>
</li>
<li><a href="#abstract-api.html">Abstract API</a>
<ul>
<li><a href="#weierstrass-short-weierstrass-curve.html">weierstrass: Short Weierstrass curve</a></li>
<li><a href="#edwards-twisted-edwards-curve.html">edwards: Twisted Edwards curve</a></li>
<li><a href="#montgomery-montgomery-curve.html">montgomery: Montgomery curve</a></li>
<li><a href="#bls-barreto-lynn-scott-curves.html">bls: Barreto-Lynn-Scott curves</a></li>
<li><a href="#hash-to-curve-hashing-strings-to-curve-points.html">hash-to-curve: Hashing strings to curve points</a></li>
<li><a href="#poseidon-poseidon-hash.html">poseidon: Poseidon hash</a></li>
<li><a href="#modular-modular-arithmetics-utilities.html">modular: Modular arithmetics utilities</a>
<ul>
<li><a href="#creating-private-keys-from-hashes.html">Creating private keys from hashes</a></li>
</ul>
</li>
<li><a href="#utils-useful-utilities.html">utils: Useful utilities</a></li>
</ul>
</li>
<li><a href="#security.html">Security</a></li>
<li><a href="#speed.html">Speed</a></li>
<li><a href="#upgrading.html">Upgrading</a></li>
<li><a href="#contributing--testing.html">Contributing &amp; testing</a></li>
<li><a href="#resources.html">Resources</a></li>
</ul>
<div class="pilwrap" id="implementations">
  <h3>
    <a href="#implementations" name="implementations" class="pilcrow"></a>
Implementations
  </h3>
</div>
<p>Implementations use <a href="https://github.com/paulmillr/noble-hashes">noble-hashes</a>.
If you want to use a different hashing library, <a href="#abstract-api.html">abstract API</a> doesn't depend on them.</p>
<div class="pilwrap" id="ecdsa-signature-scheme">
  <h4>
    <a href="#ecdsa-signature-scheme" name="ecdsa-signature-scheme" class="pilcrow"></a>
ECDSA signature scheme
  </h4>
</div>
<p>Generic example that works for all curves, shown for secp256k1:</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { secp256k1 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>;
<span class="hljs-keyword">const</span> priv = secp256k1.utils.randomPrivateKey();
<span class="hljs-keyword">const</span> pub = secp256k1.getPublicKey(priv);
<span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">32</span>).fill(<span class="hljs-number">1</span>); <span class="hljs-comment">// message hash (not message) in ecdsa</span>
<span class="hljs-keyword">const</span> sig = secp256k1.sign(msg, priv); <span class="hljs-comment">// `{prehash: true}` option is available</span>
<span class="hljs-keyword">const</span> isValid = secp256k1.verify(sig, msg, pub) === <span class="hljs-literal">true</span>;

<span class="hljs-comment">// hex strings are also supported besides Uint8Arrays:</span>
<span class="hljs-keyword">const</span> privHex = <span class="hljs-string">'46c930bc7bb4db7f55da20798697421b98c4175a52c630294d75a84b9c126236'</span>;
<span class="hljs-keyword">const</span> pub2 = secp256k1.getPublicKey(privHex);
</code></pre>
<p>We support P256 (secp256r1), P384 (secp384r1), P521 (secp521r1).</p>
<div class="pilwrap" id="ecdsa-public-key-recovery-and-extra-entropy">
  <h4>
    <a href="#ecdsa-public-key-recovery-and-extra-entropy" name="ecdsa-public-key-recovery-and-extra-entropy" class="pilcrow"></a>
ECDSA public key recovery &amp; extra entropy
  </h4>
</div>
<pre><code class="ts"><span class="hljs-comment">// let sig = secp256k1.Signature.fromCompact(sigHex); // or .fromDER(sigDERHex)</span>
<span class="hljs-comment">// sig = sig.addRecoveryBit(bit); // bit is not serialized into compact / der format</span>
sig.recoverPublicKey(msg).toRawBytes(); <span class="hljs-comment">// === pub; // public key recovery</span>

<span class="hljs-comment">// extraEntropy https://moderncrypto.org/mail-archive/curves/2017/000925.html</span>
<span class="hljs-keyword">const</span> sigImprovedSecurity = secp256k1.sign(msg, priv, { extraEntropy: <span class="hljs-literal">true</span> });
</code></pre>
<div class="pilwrap" id="ecdh-elliptic-curve-diffie-hellman">
  <h4>
    <a href="#ecdh-elliptic-curve-diffie-hellman" name="ecdh-elliptic-curve-diffie-hellman" class="pilcrow"></a>
ECDH: Elliptic Curve Diffie-Hellman
  </h4>
</div>
<pre><code class="ts"><span class="hljs-comment">// 1. The output includes parity byte. Strip it using shared.slice(1)</span>
<span class="hljs-comment">// 2. The output is not hashed. More secure way is sha256(shared) or hkdf(shared)</span>
<span class="hljs-keyword">const</span> someonesPub = secp256k1.getPublicKey(secp256k1.utils.randomPrivateKey());
<span class="hljs-keyword">const</span> shared = secp256k1.getSharedSecret(priv, someonesPub);
</code></pre>
<div class="pilwrap" id="schnorr-signatures-over-secp256k1-bip340">
  <h4>
    <a href="#schnorr-signatures-over-secp256k1-bip340" name="schnorr-signatures-over-secp256k1-bip340" class="pilcrow"></a>
Schnorr signatures over secp256k1 (BIP340)
  </h4>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { schnorr } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>;
<span class="hljs-keyword">const</span> priv = schnorr.utils.randomPrivateKey();
<span class="hljs-keyword">const</span> pub = schnorr.getPublicKey(priv);
<span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> TextEncoder().encode(<span class="hljs-string">'hello'</span>);
<span class="hljs-keyword">const</span> sig = schnorr.sign(msg, priv);
<span class="hljs-keyword">const</span> isValid = schnorr.verify(sig, msg, pub);
</code></pre>
<div class="pilwrap" id="ed25519-x25519-ristretto255">
  <h4>
    <a href="#ed25519-x25519-ristretto255" name="ed25519-x25519-ristretto255" class="pilcrow"></a>
ed25519, X25519, ristretto255
  </h4>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { ed25519 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;
<span class="hljs-keyword">const</span> priv = ed25519.utils.randomPrivateKey();
<span class="hljs-keyword">const</span> pub = ed25519.getPublicKey(priv);
<span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> TextEncoder().encode(<span class="hljs-string">'hello'</span>);
<span class="hljs-keyword">const</span> sig = ed25519.sign(msg, priv);
ed25519.verify(sig, msg, pub); <span class="hljs-comment">// Default mode: follows ZIP215</span>
ed25519.verify(sig, msg, pub, { zip215: <span class="hljs-literal">false</span> }); <span class="hljs-comment">// RFC8032 / FIPS 186-5</span>
</code></pre>
<p>Default <code>verify</code> behavior follows <a href="https://zips.z.cash/zip-0215">ZIP215</a> and
<a href="https://hdevalence.ca/blog/2020-10-04-its-25519am">can be used in consensus-critical applications</a>.
It has SUF-CMA (strong unforgeability under chosen message attacks).
<code>zip215: false</code> option switches verification criteria to strict
<a href="https://www.rfc-editor.org/rfc/rfc8032">RFC8032</a> / <a href="https://csrc.nist.gov/publications/detail/fips/186/5/final">FIPS 186-5</a>
and additionally provides <a href="#edwards-twisted-edwards-curve.html">non-repudiation with SBS</a>.</p>
<p>X25519 follows <a href="https://www.rfc-editor.org/rfc/rfc7748">RFC7748</a>.</p>
<pre><code class="ts"><span class="hljs-comment">// Variants from RFC8032: with context, prehashed</span>
<span class="hljs-keyword">import</span> { ed25519ctx, ed25519ph } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;

<span class="hljs-comment">// ECDH using curve25519 aka x25519</span>
<span class="hljs-keyword">import</span> { x25519 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;
<span class="hljs-keyword">const</span> priv = <span class="hljs-string">'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4'</span>;
<span class="hljs-keyword">const</span> pub = <span class="hljs-string">'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c'</span>;
x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); <span class="hljs-comment">// aliases</span>
x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
x25519.getPublicKey(x25519.utils.randomPrivateKey());

<span class="hljs-comment">// ed25519 =&gt; x25519 conversion</span>
<span class="hljs-keyword">import</span> { edwardsToMontgomeryPub, edwardsToMontgomeryPriv } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;
edwardsToMontgomeryPub(ed25519.getPublicKey(ed25519.utils.randomPrivateKey()));
edwardsToMontgomeryPriv(ed25519.utils.randomPrivateKey());
</code></pre>
<p>ristretto255 follows <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448">irtf draft</a>.</p>
<pre><code class="ts"><span class="hljs-comment">// hash-to-curve, ristretto255</span>
<span class="hljs-keyword">import</span> { utf8ToBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
<span class="hljs-keyword">import</span> { sha512 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-keyword">import</span> {
  hashToCurve,
  encodeToCurve,
  RistrettoPoint,
  hashToRistretto255,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;

<span class="hljs-keyword">const</span> msg = utf8ToBytes(<span class="hljs-string">'Ristretto is traditionally a short shot of espresso coffee'</span>);
hashToCurve(msg);

<span class="hljs-keyword">const</span> rp = RistrettoPoint.fromHex(
  <span class="hljs-string">'6a493210f7499cd17fecb510ae0cea23a110e8d5b901f8acadd3095c73a3b919'</span>
);
RistrettoPoint.BASE.multiply(<span class="hljs-number">2n</span>).add(rp).subtract(RistrettoPoint.BASE).toRawBytes();
RistrettoPoint.ZERO.equals(dp) === <span class="hljs-literal">false</span>;
<span class="hljs-comment">// pre-hashed hash-to-curve</span>
RistrettoPoint.hashToCurve(sha512(msg));
<span class="hljs-comment">// full hash-to-curve including domain separation tag</span>
hashToRistretto255(msg, { DST: <span class="hljs-string">'ristretto255_XMD:SHA-512_R255MAP_RO_'</span> });
</code></pre>
<div class="pilwrap" id="ed448-x448-decaf448">
  <h4>
    <a href="#ed448-x448-decaf448" name="ed448-x448-decaf448" class="pilcrow"></a>
ed448, X448, decaf448
  </h4>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { ed448 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;
<span class="hljs-keyword">const</span> priv = ed448.utils.randomPrivateKey();
<span class="hljs-keyword">const</span> pub = ed448.getPublicKey(priv);
<span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> TextEncoder().encode(<span class="hljs-string">'whatsup'</span>);
<span class="hljs-keyword">const</span> sig = ed448.sign(msg, priv);
ed448.verify(sig, msg, pub);

<span class="hljs-comment">// Variants from RFC8032: prehashed</span>
<span class="hljs-keyword">import</span> { ed448ph } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;
</code></pre>
<p>ECDH using Curve448 aka X448, follows <a href="https://www.rfc-editor.org/rfc/rfc7748">RFC7748</a>.</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { x448 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;
x448.getSharedSecret(priv, pub) === x448.scalarMult(priv, pub); <span class="hljs-comment">// aliases</span>
x448.getPublicKey(priv) === x448.scalarMultBase(priv);

<span class="hljs-comment">// ed448 =&gt; x448 conversion</span>
<span class="hljs-keyword">import</span> { edwardsToMontgomeryPub } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;
edwardsToMontgomeryPub(ed448.getPublicKey(ed448.utils.randomPrivateKey()));
</code></pre>
<p>decaf448 follows <a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448">irtf draft</a>.</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { utf8ToBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
<span class="hljs-keyword">import</span> { shake256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha3'</span>;
<span class="hljs-keyword">import</span> { hashToCurve, encodeToCurve, DecafPoint, hashToDecaf448 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;

<span class="hljs-keyword">const</span> msg = utf8ToBytes(<span class="hljs-string">'Ristretto is traditionally a short shot of espresso coffee'</span>);
hashToCurve(msg);

<span class="hljs-keyword">const</span> dp = DecafPoint.fromHex(
  <span class="hljs-string">'c898eb4f87f97c564c6fd61fc7e49689314a1f818ec85eeb3bd5514ac816d38778f69ef347a89fca817e66defdedce178c7cc709b2116e75'</span>
);
DecafPoint.BASE.multiply(<span class="hljs-number">2n</span>).add(dp).subtract(DecafPoint.BASE).toRawBytes();
DecafPoint.ZERO.equals(dp) === <span class="hljs-literal">false</span>;
<span class="hljs-comment">// pre-hashed hash-to-curve</span>
DecafPoint.hashToCurve(shake256(msg, { dkLen: <span class="hljs-number">112</span> }));
<span class="hljs-comment">// full hash-to-curve including domain separation tag</span>
hashToDecaf448(msg, { DST: <span class="hljs-string">'decaf448_XOF:SHAKE256_D448MAP_RO_'</span> });
</code></pre>
<p>Same RFC7748 / RFC8032 / IRTF draft are followed.</p>
<div class="pilwrap" id="bls12-381">
  <h4>
    <a href="#bls12-381" name="bls12-381" class="pilcrow"></a>
bls12-381
  </h4>
</div>
<p>See <a href="#bls-barreto-lynn-scott-curves.html">abstract/bls</a>.</p>
<div class="pilwrap" id="all-available-imports">
  <h4>
    <a href="#all-available-imports" name="all-available-imports" class="pilcrow"></a>
All available imports
  </h4>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { secp256k1, schnorr } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>;
<span class="hljs-keyword">import</span> { ed25519, ed25519ph, ed25519ctx, x25519, RistrettoPoint } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed25519'</span>;
<span class="hljs-keyword">import</span> { ed448, ed448ph, ed448ctx, x448 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/ed448'</span>;
<span class="hljs-keyword">import</span> { p256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/p256'</span>;
<span class="hljs-keyword">import</span> { p384 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/p384'</span>;
<span class="hljs-keyword">import</span> { p521 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/p521'</span>;
<span class="hljs-keyword">import</span> { pallas, vesta } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/pasta'</span>;
<span class="hljs-keyword">import</span> { bls12_381 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/bls12-381'</span>;
<span class="hljs-keyword">import</span> { bn254 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/bn254'</span>; <span class="hljs-comment">// also known as alt_bn128</span>
<span class="hljs-keyword">import</span> { jubjub } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/jubjub'</span>;
<span class="hljs-keyword">import</span> { bytesToHex, hexToBytes, concatBytes, utf8ToBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/utils'</span>;
</code></pre>
<div class="pilwrap" id="accessing-a-curves-variables">
  <h4>
    <a href="#accessing-a-curves-variables" name="accessing-a-curves-variables" class="pilcrow"></a>
Accessing a curve's variables
  </h4>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { secp256k1 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>;
<span class="hljs-comment">// Every curve has `CURVE` object that contains its parameters, field, and others</span>
<span class="hljs-built_in">console</span>.log(secp256k1.CURVE.p); <span class="hljs-comment">// field modulus</span>
<span class="hljs-built_in">console</span>.log(secp256k1.CURVE.n); <span class="hljs-comment">// curve order</span>
<span class="hljs-built_in">console</span>.log(secp256k1.CURVE.a, secp256k1.CURVE.b); <span class="hljs-comment">// equation params</span>
<span class="hljs-built_in">console</span>.log(secp256k1.CURVE.Gx, secp256k1.CURVE.Gy); <span class="hljs-comment">// base point coordinates</span>
</code></pre>
<div class="pilwrap" id="abstract-api">
  <h2>
    <a href="#abstract-api" name="abstract-api" class="pilcrow"></a>
Abstract API
  </h2>
</div>
<p>Abstract API allows to define custom curves. All arithmetics is done with JS
bigints over finite fields, which is defined from <code>modular</code> sub-module. For
scalar multiplication, we use
<a href="https://paulmillr.com/posts/noble-secp256k1-fast-ecc/">precomputed tables with w-ary non-adjacent form (wNAF)</a>.
Precomputes are enabled for weierstrass and edwards BASE points of a curve. You
could precompute any other point (e.g. for ECDH) using <code>utils.precompute()</code>
method: check out examples.</p>
<div class="pilwrap" id="weierstrass-short-weierstrass-curve">
  <h3>
    <a href="#weierstrass-short-weierstrass-curve" name="weierstrass-short-weierstrass-curve" class="pilcrow"></a>
weierstrass: Short Weierstrass curve
  </h3>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { weierstrass } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/weierstrass'</span>;
<span class="hljs-keyword">import</span> { Field } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/modular'</span>; <span class="hljs-comment">// finite field for mod arithmetics</span>
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>; <span class="hljs-comment">// 3rd-party sha256() of type utils.CHash</span>
<span class="hljs-keyword">import</span> { hmac } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hmac'</span>; <span class="hljs-comment">// 3rd-party hmac() that will accept sha256()</span>
<span class="hljs-keyword">import</span> { concatBytes, randomBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>; <span class="hljs-comment">// 3rd-party utilities</span>
<span class="hljs-keyword">const</span> secq256k1 = weierstrass({
  <span class="hljs-comment">// secq256k1: cycle of secp256k1 with Fp/N flipped.</span>
  <span class="hljs-comment">// https://personaelabs.org/posts/spartan-ecdsa</span>
  <span class="hljs-comment">// https://zcash.github.io/halo2/background/curves.html#cycles-of-curves</span>
  a: <span class="hljs-number">0n</span>,
  b: <span class="hljs-number">7n</span>,
  Fp: Field(<span class="hljs-number">2n</span> ** <span class="hljs-number">256n</span> - <span class="hljs-number">432420386565659656852420866394968145599n</span>),
  n: <span class="hljs-number">2n</span> ** <span class="hljs-number">256n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">32n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">9n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">8n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">7n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">6n</span> - <span class="hljs-number">2n</span> ** <span class="hljs-number">4n</span> - <span class="hljs-number">1n</span>,
  Gx: <span class="hljs-number">55066263022277343669578718895168534326250603453777594175500187360389116729240n</span>,
  Gy: <span class="hljs-number">32670510020758816978083085130507043184471273380659243275938904335757337482424n</span>,
  hash: sha256,
  hmac: <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">Uint8Array</span>, ...msgs: <span class="hljs-built_in">Uint8Array</span>[]</span>) =&gt;</span> hmac(sha256, key, concatBytes(...msgs)),
  randomBytes,
});

<span class="hljs-comment">// Replace weierstrass() with weierstrassPoints() if you don't need ECDSA, hash, hmac, randomBytes</span>
</code></pre>
<p>Short Weierstrass curve's formula is <code>y¬≤ = x¬≥ + ax + b</code>. <code>weierstrass</code>
expects arguments <code>a</code>, <code>b</code>, field <code>Fp</code>, curve order <code>n</code>, cofactor <code>h</code>
and coordinates <code>Gx</code>, <code>Gy</code> of generator point.</p>
<p><strong><code>k</code> generation</strong> is done deterministically, following
<a href="https://www.rfc-editor.org/rfc/rfc6979">RFC6979</a>. For this you will need
<code>hmac</code> &amp; <code>hash</code>, which in our implementations is provided by noble-hashes. If
you're using different hashing library, make sure to wrap it in the following interface:</p>
<pre><code class="ts"><span class="hljs-keyword">type</span> CHash = {
  (message: <span class="hljs-built_in">Uint8Array</span>): <span class="hljs-built_in">Uint8Array</span>;
  blockLen: <span class="hljs-built_in">number</span>;
  outputLen: <span class="hljs-built_in">number</span>;
  create(): <span class="hljs-built_in">any</span>;
};

<span class="hljs-comment">// example</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sha256</span>(<span class="hljs-params">message: <span class="hljs-built_in">Uint8Array</span></span>) </span>{
  <span class="hljs-keyword">return</span> _internal_lowlvl(message);
}
sha256.outputLen = <span class="hljs-number">32</span>; <span class="hljs-comment">// 32 bytes of output for sha2-256</span>
</code></pre>
<p><strong>Message hash</strong> is expected instead of message itself:</p>
<ul>
<li><code>sign(msgHash, privKey)</code> is default behavior, assuming you pre-hash msg with sha2, or other hash</li>
<li><code>sign(msg, privKey, {prehash: true})</code> option can be used if you want to pass the message itself</li>
</ul>
<p><strong>Weierstrass points:</strong></p>
<ol>
<li>Exported as <code>ProjectivePoint</code></li>
<li>Represented in projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)</li>
<li>Use complete exception-free formulas for addition and doubling</li>
<li>Can be decoded/encoded from/to Uint8Array / hex strings using
<code>ProjectivePoint.fromHex</code> and <code>ProjectivePoint#toRawBytes()</code></li>
<li>Have <code>assertValidity()</code> which checks for being on-curve</li>
<li>Have <code>toAffine()</code> and <code>x</code> / <code>y</code> getters which convert to 2d xy affine coordinates</li>
</ol>
<pre><code class="ts"><span class="hljs-comment">// `weierstrassPoints()` returns `CURVE` and `ProjectivePoint`</span>
<span class="hljs-comment">// `weierstrass()` returns `CurveFn`</span>
<span class="hljs-keyword">type</span> SignOpts = { lowS?: <span class="hljs-built_in">boolean</span>; prehash?: <span class="hljs-built_in">boolean</span>; extraEntropy: <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">Uint8Array</span> };
<span class="hljs-keyword">type</span> CurveFn = {
  CURVE: ReturnType&lt;<span class="hljs-keyword">typeof</span> validateOpts&gt;;
  getPublicKey: <span class="hljs-function">(<span class="hljs-params">privateKey: PrivKey, isCompressed?: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
  getSharedSecret: <span class="hljs-function">(<span class="hljs-params">privateA: PrivKey, publicB: Hex, isCompressed?: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
  sign: <span class="hljs-function">(<span class="hljs-params">msgHash: Hex, privKey: PrivKey, opts?: SignOpts</span>) =&gt;</span> SignatureType;
  verify: (
    signature: Hex | SignatureType,
    msgHash: Hex,
    publicKey: Hex,
    opts?: { lowS?: <span class="hljs-built_in">boolean</span>; prehash?: <span class="hljs-built_in">boolean</span> }
  ) =&gt; <span class="hljs-built_in">boolean</span>;
  ProjectivePoint: ProjectivePointConstructor;
  Signature: SignatureConstructor;
  utils: {
    normPrivateKeyToScalar: <span class="hljs-function">(<span class="hljs-params">key: PrivKey</span>) =&gt;</span> bigint;
    isValidPrivateKey(key: PrivKey): <span class="hljs-built_in">boolean</span>;
    randomPrivateKey: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
    precompute: <span class="hljs-function">(<span class="hljs-params">windowSize?: <span class="hljs-built_in">number</span>, point?: ProjPointType&lt;bigint&gt;</span>) =&gt;</span> ProjPointType&lt;bigint&gt;;
  };
};

<span class="hljs-comment">// T is usually bigint, but can be something else like complex numbers in BLS curves</span>
<span class="hljs-keyword">interface</span> ProjPointType&lt;T&gt; <span class="hljs-keyword">extends</span> Group&lt;ProjPointType&lt;T&gt;&gt; {
  readonly px: T;
  readonly py: T;
  readonly pz: T;
  <span class="hljs-keyword">get</span> x(): bigint;
  <span class="hljs-keyword">get</span> y(): bigint;
  multiply(scalar: bigint): ProjPointType&lt;T&gt;;
  multiplyUnsafe(scalar: bigint): ProjPointType&lt;T&gt;;
  multiplyAndAddUnsafe(Q: ProjPointType&lt;T&gt;, a: bigint, b: bigint): ProjPointType&lt;T&gt; | <span class="hljs-literal">undefined</span>;
  toAffine(iz?: T): AffinePoint&lt;T&gt;;
  isTorsionFree(): <span class="hljs-built_in">boolean</span>;
  clearCofactor(): ProjPointType&lt;T&gt;;
  assertValidity(): <span class="hljs-built_in">void</span>;
  hasEvenY(): <span class="hljs-built_in">boolean</span>;
  toRawBytes(isCompressed?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">Uint8Array</span>;
  toHex(isCompressed?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// Static methods for 3d XYZ points</span>
<span class="hljs-keyword">interface</span> ProjConstructor&lt;T&gt; <span class="hljs-keyword">extends</span> GroupConstructor&lt;ProjPointType&lt;T&gt;&gt; {
  <span class="hljs-keyword">new</span> (x: T, y: T, z: T): ProjPointType&lt;T&gt;;
  fromAffine(p: AffinePoint&lt;T&gt;): ProjPointType&lt;T&gt;;
  fromHex(hex: Hex): ProjPointType&lt;T&gt;;
  fromPrivateKey(privateKey: PrivKey): ProjPointType&lt;T&gt;;
}
</code></pre>
<p><strong>ECDSA signatures</strong> are represented by <code>Signature</code> instances and can be
described by the interface:</p>
<pre><code class="ts"><span class="hljs-keyword">interface</span> SignatureType {
  readonly r: bigint;
  readonly s: bigint;
  readonly recovery?: <span class="hljs-built_in">number</span>;
  assertValidity(): <span class="hljs-built_in">void</span>;
  addRecoveryBit(recovery: <span class="hljs-built_in">number</span>): SignatureType;
  hasHighS(): <span class="hljs-built_in">boolean</span>;
  normalizeS(): SignatureType;
  recoverPublicKey(msgHash: Hex): ProjPointType&lt;bigint&gt;;
  toCompactRawBytes(): <span class="hljs-built_in">Uint8Array</span>;
  toCompactHex(): <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// DER-encoded</span>
  toDERRawBytes(): <span class="hljs-built_in">Uint8Array</span>;
  toDERHex(): <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">type</span> SignatureConstructor = {
  <span class="hljs-keyword">new</span> (r: bigint, s: bigint): SignatureType;
  fromCompact(hex: Hex): SignatureType;
  fromDER(hex: Hex): SignatureType;
};
</code></pre>
<p>More examples:</p>
<pre><code class="typescript"><span class="hljs-comment">// All curves expose same generic interface.</span>
<span class="hljs-keyword">const</span> priv = secq256k1.utils.randomPrivateKey();
secq256k1.getPublicKey(priv); <span class="hljs-comment">// Convert private key to public.</span>
<span class="hljs-keyword">const</span> sig = secq256k1.sign(msg, priv); <span class="hljs-comment">// Sign msg with private key.</span>
<span class="hljs-keyword">const</span> sig2 = secq256k1.sign(msg, priv, { prehash: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// hash(msg)</span>
secq256k1.verify(sig, msg, priv); <span class="hljs-comment">// Verify if sig is correct.</span>

<span class="hljs-keyword">const</span> Point = secq256k1.ProjectivePoint;
<span class="hljs-keyword">const</span> point = Point.BASE; <span class="hljs-comment">// Elliptic curve Point class and BASE point static var.</span>
point.add(point).equals(point.double()); <span class="hljs-comment">// add(), equals(), double() methods</span>
point.subtract(point).equals(Point.ZERO); <span class="hljs-comment">// subtract() method, ZERO static var</span>
point.negate(); <span class="hljs-comment">// Flips point over x/y coordinate.</span>
point.multiply(<span class="hljs-number">31415n</span>); <span class="hljs-comment">// Multiplication of Point by scalar.</span>

point.assertValidity(); <span class="hljs-comment">// Checks for being on-curve</span>
point.toAffine(); <span class="hljs-comment">// Converts to 2d affine xy coordinates</span>

secq256k1.CURVE.n;
secq256k1.CURVE.p;
secq256k1.CURVE.Fp.mod();
secq256k1.CURVE.hash();

<span class="hljs-comment">// precomputes</span>
<span class="hljs-keyword">const</span> fast = secq256k1.utils.precompute(<span class="hljs-number">8</span>, Point.fromHex(someonesPubKey));
fast.multiply(privKey); <span class="hljs-comment">// much faster ECDH now</span>
</code></pre>
<div class="pilwrap" id="edwards-twisted-edwards-curve">
  <h3>
    <a href="#edwards-twisted-edwards-curve" name="edwards-twisted-edwards-curve" class="pilcrow"></a>
edwards: Twisted Edwards curve
  </h3>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { twistedEdwards } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/edwards'</span>;
<span class="hljs-keyword">import</span> { Field } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/modular'</span>;
<span class="hljs-keyword">import</span> { sha512 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-keyword">import</span> { randomBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;

<span class="hljs-keyword">const</span> Fp = Field(<span class="hljs-number">2n</span> ** <span class="hljs-number">255n</span> - <span class="hljs-number">19n</span>);
<span class="hljs-keyword">const</span> ed25519 = twistedEdwards({
  a: Fp.create(<span class="hljs-number">-1n</span>),
  d: Fp.div(<span class="hljs-number">-121665n</span>, <span class="hljs-number">121666n</span>), <span class="hljs-comment">// -121665n/121666n mod p</span>
  Fp: Fp,
  n: <span class="hljs-number">2n</span> ** <span class="hljs-number">252n</span> + <span class="hljs-number">27742317777372353535851937790883648493n</span>,
  h: <span class="hljs-number">8n</span>,
  Gx: <span class="hljs-number">15112221349535400772501151409588531511454012693041857206046113283949847762202n</span>,
  Gy: <span class="hljs-number">46316835694926478169428394003475163141307993866256225615783033603165251855960n</span>,
  hash: sha512,
  randomBytes,
  adjustScalarBytes(bytes) {
    <span class="hljs-comment">// optional; but mandatory in ed25519</span>
    bytes[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>;
    bytes[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">127</span>;
    bytes[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>;
    <span class="hljs-keyword">return</span> bytes;
  },
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>);
</code></pre>
<p>Twisted Edwards curve's formula is <code>ax¬≤ + y¬≤ = 1 + dx¬≤y¬≤</code>. You must specify <code>a</code>, <code>d</code>, field <code>Fp</code>, order <code>n</code>, cofactor <code>h</code>
and coordinates <code>Gx</code>, <code>Gy</code> of generator point.</p>
<p>For EdDSA signatures, <code>hash</code> param required. <code>adjustScalarBytes</code> which instructs how to change private scalars could be specified.</p>
<p>We support <a href="https://eprint.iacr.org/2020/1244">non-repudiation</a>, which help in following scenarios:</p>
<ul>
<li>Contract Signing: if A signed an agreement with B using key that allows repudiation, it can later claim that it signed a different contract</li>
<li>E-voting: malicious voters may pick keys that allow repudiation in order to deny results</li>
<li>Blockchains: transaction of amount X might also be valid for a different amount Y</li>
</ul>
<p><strong>Edwards points:</strong></p>
<ol>
<li>Exported as <code>ExtendedPoint</code></li>
<li>Represented in extended coordinates: (x, y, z, t) ‚àã (x=x/z, y=y/z)</li>
<li>Use complete exception-free formulas for addition and doubling</li>
<li>Can be decoded/encoded from/to Uint8Array / hex strings using <code>ExtendedPoint.fromHex</code> and <code>ExtendedPoint#toRawBytes()</code></li>
<li>Have <code>assertValidity()</code> which checks for being on-curve</li>
<li>Have <code>toAffine()</code> and <code>x</code> / <code>y</code> getters which convert to 2d xy affine coordinates</li>
<li>Have <code>isTorsionFree()</code>, <code>clearCofactor()</code> and <code>isSmallOrder()</code> utilities to handle torsions</li>
</ol>
<pre><code class="ts"><span class="hljs-comment">// `twistedEdwards()` returns `CurveFn` of following type:</span>
<span class="hljs-keyword">type</span> CurveFn = {
  CURVE: ReturnType&lt;<span class="hljs-keyword">typeof</span> validateOpts&gt;;
  getPublicKey: <span class="hljs-function">(<span class="hljs-params">privateKey: Hex</span>) =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
  sign: <span class="hljs-function">(<span class="hljs-params">message: Hex, privateKey: Hex, context?: Hex</span>) =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
  verify: <span class="hljs-function">(<span class="hljs-params">sig: SigType, message: Hex, publicKey: Hex, context?: Hex</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
  ExtendedPoint: ExtPointConstructor;
  utils: {
    randomPrivateKey: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Uint8Array</span>;
    getExtendedPublicKey: <span class="hljs-function">(<span class="hljs-params">key: PrivKey</span>) =&gt;</span> {
      head: <span class="hljs-built_in">Uint8Array</span>;
      prefix: <span class="hljs-built_in">Uint8Array</span>;
      scalar: bigint;
      point: PointType;
      pointBytes: <span class="hljs-built_in">Uint8Array</span>;
    };
  };
};

<span class="hljs-keyword">interface</span> ExtPointType <span class="hljs-keyword">extends</span> Group&lt;ExtPointType&gt; {
  readonly ex: bigint;
  readonly ey: bigint;
  readonly ez: bigint;
  readonly et: bigint;
  <span class="hljs-keyword">get</span> x(): bigint;
  <span class="hljs-keyword">get</span> y(): bigint;
  assertValidity(): <span class="hljs-built_in">void</span>;
  multiply(scalar: bigint): ExtPointType;
  multiplyUnsafe(scalar: bigint): ExtPointType;
  isSmallOrder(): <span class="hljs-built_in">boolean</span>;
  isTorsionFree(): <span class="hljs-built_in">boolean</span>;
  clearCofactor(): ExtPointType;
  toAffine(iz?: bigint): AffinePoint&lt;bigint&gt;;
  toRawBytes(isCompressed?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">Uint8Array</span>;
  toHex(isCompressed?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// Static methods of Extended Point with coordinates in X, Y, Z, T</span>
<span class="hljs-keyword">interface</span> ExtPointConstructor <span class="hljs-keyword">extends</span> GroupConstructor&lt;ExtPointType&gt; {
  <span class="hljs-keyword">new</span> (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;
  fromAffine(p: AffinePoint&lt;bigint&gt;): ExtPointType;
  fromHex(hex: Hex): ExtPointType;
  fromPrivateKey(privateKey: Hex): ExtPointType;
}
</code></pre>
<div class="pilwrap" id="montgomery-montgomery-curve">
  <h3>
    <a href="#montgomery-montgomery-curve" name="montgomery-montgomery-curve" class="pilcrow"></a>
montgomery: Montgomery curve
  </h3>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { montgomery } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/montgomery'</span>;
<span class="hljs-keyword">import</span> { Field } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/modular'</span>;

<span class="hljs-keyword">const</span> x25519 = montgomery({
  a: <span class="hljs-number">486662n</span>,
  Gu: <span class="hljs-number">9n</span>,
  P: <span class="hljs-number">2n</span> ** <span class="hljs-number">255n</span> - <span class="hljs-number">19n</span>,
  montgomeryBits: <span class="hljs-number">255</span>,
  nByteLength: <span class="hljs-number">32</span>,
  <span class="hljs-comment">// Optional param</span>
  adjustScalarBytes(bytes) {
    bytes[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>;
    bytes[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">127</span>;
    bytes[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>;
    <span class="hljs-keyword">return</span> bytes;
  },
});
</code></pre>
<p>The module contains methods for x-only ECDH on Curve25519 / Curve448 from RFC7748.
Proper Elliptic Curve Points are not implemented yet.</p>
<p>You must specify curve params <code>Fp</code>, <code>a</code>, <code>Gu</code> coordinate of u, <code>montgomeryBits</code> and <code>nByteLength</code>.</p>
<div class="pilwrap" id="bls-barreto-lynn-scott-curves">
  <h3>
    <a href="#bls-barreto-lynn-scott-curves" name="bls-barreto-lynn-scott-curves" class="pilcrow"></a>
bls: Barreto-Lynn-Scott curves
  </h3>
</div>
<p>The module abstracts BLS (Barreto-Lynn-Scott) pairing-friendly elliptic curve construction.
They allow to construct <a href="https://z.cash/technology/zksnarks/">zk-SNARKs</a> and
use aggregated, batch-verifiable
<a href="https://medium.com/snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716">threshold signatures</a>,
using Boneh-Lynn-Shacham signature scheme.</p>
<p>The module doesn't expose <code>CURVE</code> property: use <code>G1.CURVE</code>, <code>G2.CURVE</code> instead.
Only BLS12-381 is implemented currently.
Defining BLS12-377 and BLS24 should be straightforward.</p>
<p>Main methods and properties are:</p>
<ul>
<li><code>getPublicKey(privateKey)</code></li>
<li><code>sign(message, privateKey)</code></li>
<li><code>verify(signature, message, publicKey)</code></li>
<li><code>aggregatePublicKeys(publicKeys)</code></li>
<li><code>aggregateSignatures(signatures)</code></li>
<li><code>G1</code> and <code>G2</code> curves containing <code>CURVE</code> and <code>ProjectivePoint</code></li>
<li><code>Signature</code> property with <code>fromHex</code>, <code>toHex</code> methods</li>
<li><code>fields</code> containing <code>Fp</code>, <code>Fp2</code>, <code>Fp6</code>, <code>Fp12</code>, <code>Fr</code></li>
</ul>
<p>The default BLS uses short public keys (with public keys in G1 and signatures in G2).
Short signatures (public keys in G2 and signatures in G1) is also supported, using:</p>
<ul>
<li><code>getPublicKeyForShortSignatures(privateKey)</code></li>
<li><code>signShortSignature(message, privateKey)</code></li>
<li><code>verifyShortSignature(signature, message, publicKey)</code></li>
<li><code>aggregateShortSignatures(signatures)</code></li>
</ul>
<pre><code class="ts"><span class="hljs-keyword">import</span> { bls12_381 <span class="hljs-keyword">as</span> bls } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/bls12-381'</span>;
<span class="hljs-keyword">const</span> privateKey = <span class="hljs-string">'67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c'</span>;
<span class="hljs-keyword">const</span> message = <span class="hljs-string">'64726e3da8'</span>;
<span class="hljs-keyword">const</span> publicKey = bls.getPublicKey(privateKey);
<span class="hljs-keyword">const</span> signature = bls.sign(message, privateKey);
<span class="hljs-keyword">const</span> isValid = bls.verify(signature, message, publicKey);
<span class="hljs-built_in">console</span>.log({ publicKey, signature, isValid });

<span class="hljs-comment">// Use custom DST, e.g. for Ethereum consensus layer</span>
<span class="hljs-keyword">const</span> htfEthereum = { DST: <span class="hljs-string">'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_'</span> };
<span class="hljs-keyword">const</span> signatureEth = bls.sign(message, privateKey, htfEthereum);
<span class="hljs-keyword">const</span> isValidEth = bls.verify(signature, message, publicKey, htfEthereum);
<span class="hljs-built_in">console</span>.log({ signatureEth, isValidEth });

<span class="hljs-comment">// Sign 1 msg with 3 keys</span>
<span class="hljs-keyword">const</span> privateKeys = [
  <span class="hljs-string">'18f020b98eb798752a50ed0563b079c125b0db5dd0b1060d1c1b47d4a193e1e4'</span>,
  <span class="hljs-string">'ed69a8c50cf8c9836be3b67c7eeff416612d45ba39a5c099d48fa668bf558c9c'</span>,
  <span class="hljs-string">'16ae669f3be7a2121e17d0c68c05a8f3d6bef21ec0f2315f1d7aec12484e4cf5'</span>,
];
<span class="hljs-keyword">const</span> messages = [<span class="hljs-string">'d2'</span>, <span class="hljs-string">'0d98'</span>, <span class="hljs-string">'05caf3'</span>];
<span class="hljs-keyword">const</span> publicKeys = privateKeys.map(bls.getPublicKey);
<span class="hljs-keyword">const</span> signatures2 = privateKeys.map(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> bls.sign(message, p));
<span class="hljs-keyword">const</span> aggPubKey2 = bls.aggregatePublicKeys(publicKeys);
<span class="hljs-keyword">const</span> aggSignature2 = bls.aggregateSignatures(signatures2);
<span class="hljs-keyword">const</span> isValid2 = bls.verify(aggSignature2, message, aggPubKey2);
<span class="hljs-built_in">console</span>.log({ signatures2, aggSignature2, isValid2 });

<span class="hljs-comment">// Sign 3 msgs with 3 keys</span>
<span class="hljs-keyword">const</span> signatures3 = privateKeys.map(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> bls.sign(messages[i], p));
<span class="hljs-keyword">const</span> aggSignature3 = bls.aggregateSignatures(signatures3);
<span class="hljs-keyword">const</span> isValid3 = bls.verifyBatch(aggSignature3, messages, publicKeys);
<span class="hljs-built_in">console</span>.log({ publicKeys, signatures3, aggSignature3, isValid3 });

<span class="hljs-comment">// Pairings, with and without final exponentiation</span>
bls.pairing(PointG1, PointG2);
bls.pairing(PointG1, PointG2, <span class="hljs-literal">false</span>);
bls.fields.Fp12.finalExponentiate(bls.fields.Fp12.mul(PointG1, PointG2));

<span class="hljs-comment">// Others</span>
bls.G1.ProjectivePoint.BASE, bls.G2.ProjectivePoint.BASE;
bls.fields.Fp, bls.fields.Fp2, bls.fields.Fp12, bls.fields.Fr;
bls.params.x, bls.params.r, bls.params.G1b, bls.params.G2b;

<span class="hljs-comment">// hash-to-curve examples can be seen below</span>
</code></pre>
<div class="pilwrap" id="hash-to-curve-hashing-strings-to-curve-points">
  <h3>
    <a href="#hash-to-curve-hashing-strings-to-curve-points" name="hash-to-curve-hashing-strings-to-curve-points" class="pilcrow"></a>
hash-to-curve: Hashing strings to curve points
  </h3>
</div>
<p>The module allows to hash arbitrary strings to elliptic curve points. Implements <a href="https://www.rfc-editor.org/rfc/rfc9380">RFC 9380</a>.</p>
<p>Every curve has exported <code>hashToCurve</code> and <code>encodeToCurve</code> methods. You should always prefer <code>hashToCurve</code> for security:</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { hashToCurve, encodeToCurve } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/secp256k1'</span>;
<span class="hljs-keyword">import</span> { randomBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
hashToCurve(<span class="hljs-string">'0102abcd'</span>);
<span class="hljs-built_in">console</span>.log(hashToCurve(randomBytes()));
<span class="hljs-built_in">console</span>.log(encodeToCurve(randomBytes()));

<span class="hljs-keyword">import</span> { bls12_381 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/bls12-381'</span>;
bls12_381.G1.hashToCurve(randomBytes(), { DST: <span class="hljs-string">'another'</span> });
bls12_381.G2.hashToCurve(randomBytes(), { DST: <span class="hljs-string">'custom'</span> });
</code></pre>
<p>Low-level methods from the spec:</p>
<pre><code class="ts"><span class="hljs-comment">// produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expand_message_xmd</span>(<span class="hljs-params">
  msg: <span class="hljs-built_in">Uint8Array</span>,
  DST: <span class="hljs-built_in">Uint8Array</span>,
  lenInBytes: <span class="hljs-built_in">number</span>,
  H: CHash <span class="hljs-comment">// For CHash see abstract/weierstrass docs section</span>
</span>): <span class="hljs-title">Uint8Array</span></span>;
<span class="hljs-comment">// produces a uniformly random byte string using an extendable-output function (XOF) H.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expand_message_xof</span>(<span class="hljs-params">
  msg: <span class="hljs-built_in">Uint8Array</span>,
  DST: <span class="hljs-built_in">Uint8Array</span>,
  lenInBytes: <span class="hljs-built_in">number</span>,
  k: <span class="hljs-built_in">number</span>,
  H: CHash
</span>): <span class="hljs-title">Uint8Array</span></span>;
<span class="hljs-comment">// Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash_to_field</span>(<span class="hljs-params">msg: <span class="hljs-built_in">Uint8Array</span>, count: <span class="hljs-built_in">number</span>, options: Opts</span>): <span class="hljs-title">bigint</span>[][]</span>;

<span class="hljs-comment">/**
 * * `DST` is a domain separation tag, defined in section 2.2.5
 * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m
 * * `m` is extension degree (1 for prime fields)
 * * `k` is the target security target in bits (e.g. 128), from section 5.1
 * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)
 * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props
 */</span>
<span class="hljs-keyword">type</span> UnicodeOrBytes = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">Uint8Array</span>;
<span class="hljs-keyword">type</span> Opts = {
  DST: UnicodeOrBytes;
  p: bigint;
  m: <span class="hljs-built_in">number</span>;
  k: <span class="hljs-built_in">number</span>;
  expand?: <span class="hljs-string">'xmd'</span> | <span class="hljs-string">'xof'</span>;
  hash: CHash;
};
</code></pre>
<div class="pilwrap" id="poseidon-poseidon-hash">
  <h3>
    <a href="#poseidon-poseidon-hash" name="poseidon-poseidon-hash" class="pilcrow"></a>
poseidon: Poseidon hash
  </h3>
</div>
<p>Implements <a href="https://www.poseidon-hash.info">Poseidon</a> ZK-friendly hash.</p>
<p>There are many poseidon variants with different constants.
We don't provide them: you should construct them manually.
Check out <a href="https://github.com/paulmillr/micro-starknet">micro-starknet</a> package for a proper example.</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { poseidon } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/poseidon'</span>;

<span class="hljs-keyword">type</span> PoseidonOpts = {
  Fp: Field&lt;bigint&gt;;
  t: <span class="hljs-built_in">number</span>;
  roundsFull: <span class="hljs-built_in">number</span>;
  roundsPartial: <span class="hljs-built_in">number</span>;
  sboxPower?: <span class="hljs-built_in">number</span>;
  reversePartialPowIdx?: <span class="hljs-built_in">boolean</span>;
  mds: bigint[][];
  roundConstants: bigint[][];
};
<span class="hljs-keyword">const</span> instance = poseidon(opts: PoseidonOpts);
</code></pre>
<div class="pilwrap" id="modular-modular-arithmetics-utilities">
  <h3>
    <a href="#modular-modular-arithmetics-utilities" name="modular-modular-arithmetics-utilities" class="pilcrow"></a>
modular: Modular arithmetics utilities
  </h3>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/modular'</span>;
<span class="hljs-keyword">const</span> fp = mod.Field(<span class="hljs-number">2n</span> ** <span class="hljs-number">255n</span> - <span class="hljs-number">19n</span>); <span class="hljs-comment">// Finite field over 2^255-19</span>
fp.mul(<span class="hljs-number">591n</span>, <span class="hljs-number">932n</span>); <span class="hljs-comment">// multiplication</span>
fp.pow(<span class="hljs-number">481n</span>, <span class="hljs-number">11024858120n</span>); <span class="hljs-comment">// exponentiation</span>
fp.div(<span class="hljs-number">5n</span>, <span class="hljs-number">17n</span>); <span class="hljs-comment">// division: 5/17 mod 2^255-19 == 5 * invert(17)</span>
fp.sqrt(<span class="hljs-number">21n</span>); <span class="hljs-comment">// square root</span>

<span class="hljs-comment">// Generic non-FP utils are also available</span>
mod.mod(<span class="hljs-number">21n</span>, <span class="hljs-number">10n</span>); <span class="hljs-comment">// 21 mod 10 == 1n; fixed version of 21 % 10</span>
mod.invert(<span class="hljs-number">17n</span>, <span class="hljs-number">10n</span>); <span class="hljs-comment">// invert(17) mod 10; modular multiplicative inverse</span>
mod.invertBatch([<span class="hljs-number">1n</span>, <span class="hljs-number">2n</span>, <span class="hljs-number">4n</span>], <span class="hljs-number">21n</span>); <span class="hljs-comment">// =&gt; [1n, 11n, 16n] in one inversion</span>
</code></pre>
<p>Field operations are not constant-time: they are using JS bigints, see <a href="#security.html">security</a>.
The fact is mostly irrelevant, but the important method to keep in mind is <code>pow</code>,
which may leak exponent bits, when used na√Øvely.</p>
<p><code>mod.Field</code> is always <strong>field over prime</strong>. Non-prime fields aren't supported for now.
We don't test for prime-ness for speed and because algorithms are probabilistic anyway.
Initializing a non-prime field could make your app suspectible to
DoS (infilite loop) on Tonelli-Shanks square root calculation.</p>
<p>Unlike <code>mod.invert</code>, <code>mod.invertBatch</code> won't throw on <code>0</code>: make sure to throw an error yourself.</p>
<div class="pilwrap" id="creating-private-keys-from-hashes">
  <h4>
    <a href="#creating-private-keys-from-hashes" name="creating-private-keys-from-hashes" class="pilcrow"></a>
Creating private keys from hashes
  </h4>
</div>
<p>You can't simply make a 32-byte private key from a 32-byte hash.
Doing so will make the key <a href="https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/">biased</a>.</p>
<p>To make the bias negligible, we follow <a href="https://csrc.nist.gov/publications/detail/fips/186/5/final">FIPS 186-5 A.2</a>
and <a href="https://www.rfc-editor.org/rfc/rfc9380#section-5.2">RFC 9380</a>.
This means, for 32-byte key, we would need 48-byte hash to get 2^-128 bias, which matches curve security level.</p>
<p><code>hashToPrivateScalar()</code> that hashes to <strong>private key</strong> was created for this purpose.
Use <a href="#hash-to-curve-hashing-strings-to-curve-points.html">abstract/hash-to-curve</a>
if you need to hash to <strong>public key</strong>.</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { p256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/p256'</span>;
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">import</span> { hkdf } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hkdf'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/modular'</span>;
<span class="hljs-keyword">const</span> someKey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">32</span>).fill(<span class="hljs-number">2</span>); <span class="hljs-comment">// Needs to actually be random, not .fill(2)</span>
<span class="hljs-keyword">const</span> derived = hkdf(sha256, someKey, <span class="hljs-literal">undefined</span>, <span class="hljs-string">'application'</span>, <span class="hljs-number">48</span>); <span class="hljs-comment">// 48 bytes for 32-byte priv</span>
<span class="hljs-keyword">const</span> validPrivateKey = mod.hashToPrivateScalar(derived, p256.CURVE.n);
</code></pre>
<div class="pilwrap" id="utils-useful-utilities">
  <h3>
    <a href="#utils-useful-utilities" name="utils-useful-utilities" class="pilcrow"></a>
utils: Useful utilities
  </h3>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/curves/abstract/utils'</span>;

utils.bytesToHex(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xef</span>]));
utils.hexToBytes(<span class="hljs-string">'deadbeef'</span>);
utils.numberToHexUnpadded(<span class="hljs-number">123n</span>);
utils.hexToNumber();

utils.bytesToNumberBE(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xef</span>]));
utils.bytesToNumberLE(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xef</span>]));
utils.numberToBytesBE(<span class="hljs-number">123n</span>, <span class="hljs-number">32</span>);
utils.numberToBytesLE(<span class="hljs-number">123n</span>, <span class="hljs-number">64</span>);

utils.concatBytes(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>]), <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xbe</span>, <span class="hljs-number">0xef</span>]));
utils.nLength(<span class="hljs-number">255n</span>);
utils.equalBytes(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>]), <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">0xde</span>]));
</code></pre>
<div class="pilwrap" id="security">
  <h2>
    <a href="#security" name="security" class="pilcrow"></a>
Security
  </h2>
</div>
<p>The library has been independently audited:</p>
<ul>
<li>at version 1.2.0, in Sep 2023, by <a href="https://kudelskisecurity.com">Kudelski Security</a>
<ul>
<li>PDFs: <a href="./audit/2023-09-kudelski-audit-starknet.pdf.html">offline</a></li>
<li><a href="https://github.com/paulmillr/noble-curves/compare/1.2.0..main">Changes since audit</a></li>
<li>Scope: <a href="https://github.com/paulmillr/scure-starknet">scure-starknet</a> and its related
abstract modules of noble-curves: <code>curve</code>, <code>modular</code>, <code>poseidon</code>, <code>weierstrass</code></li>
<li>The audit has been funded by <a href="https://starkware.co">Starkware</a></li>
</ul>
</li>
<li>at version 0.7.3, in Feb 2023, by <a href="https://www.trailofbits.com">Trail of Bits</a>
<ul>
<li>PDFs: <a href="https://github.com/trailofbits/publications/blob/master/reviews/2023-01-ryanshea-noblecurveslibrary-securityreview.pdf">online</a>,
<a href="./audit/2023-01-trailofbits-audit-curves.pdf.html">offline</a></li>
<li><a href="https://github.com/paulmillr/noble-curves/compare/0.7.3..main">Changes since audit</a></li>
<li>Scope: abstract modules <code>curve</code>, <code>hash-to-curve</code>, <code>modular</code>, <code>poseidon</code>, <code>utils</code>, <code>weierstrass</code> and
top-level modules <code>_shortw_utils</code> and <code>secp256k1</code></li>
<li>The audit has been funded by <a href="https://www.shea.io">Ryan Shea</a></li>
</ul>
</li>
</ul>
<p>It is tested against property-based, cross-library and Wycheproof vectors,
and has fuzzing by <a href="https://github.com/guidovranken/cryptofuzz">Guido Vranken's cryptofuzz</a>.</p>
<p>If you see anything unusual: investigate and report.</p>
<div class="pilwrap" id="constant-timeness">
  <h3>
    <a href="#constant-timeness" name="constant-timeness" class="pilcrow"></a>
Constant-timeness
  </h3>
</div>
<p><em>JIT-compiler</em> and <em>Garbage Collector</em> make &quot;constant time&quot; extremely hard to
achieve <a href="https://en.wikipedia.org/wiki/Timing_attack">timing attack</a> resistance
in a scripting language. Which means <em>any other JS library can't have
constant-timeness</em>. Even statically typed Rust, a language without GC,
<a href="https://www.chosenplaintext.ca/open-source/rust-timing-shield/security">makes it harder to achieve constant-time</a>
for some cases. If your goal is absolute security, don't use any JS lib ‚Äî including bindings to native ones.
Use low-level libraries &amp; languages. Nonetheless we're targetting algorithmic constant time.</p>
<div class="pilwrap" id="supply-chain-security">
  <h3>
    <a href="#supply-chain-security" name="supply-chain-security" class="pilcrow"></a>
Supply chain security
  </h3>
</div>
<ul>
<li><strong>Commits</strong> are signed with PGP keys, to prevent forgery. Make sure to verify commit signatures.</li>
<li><strong>Releases</strong> are transparent and built on GitHub CI. Make sure to verify <a href="https://docs.npmjs.com/generating-provenance-statements">provenance</a> logs</li>
<li><strong>Rare releasing</strong> is followed to ensure less re-audit need for end-users</li>
<li><strong>Dependencies</strong> are minimized and locked-down:
<ul>
<li>If your app has 500 dependencies, any dep could get hacked and you'll be downloading
malware with every install. We make sure to use as few dependencies as possible</li>
<li>We prevent automatic dependency updates by locking-down version ranges. Every update is checked with <code>npm-diff</code></li>
<li>One dependency <a href="https://github.com/paulmillr/noble-hashes">noble-hashes</a> is used, by the same author, to provide hashing functionality</li>
</ul>
</li>
<li><strong>Dev Dependencies</strong> are only used if you want to contribute to the repo. They are disabled for end-users:
<ul>
<li>scure-base, scure-bip32, scure-bip39, micro-bmark and micro-should are developed by the same author and follow identical security practices</li>
<li>prettier (linter), fast-check (property-based testing) and typescript are used for code quality, vector generation and ts compilation. The packages are big, which makes it hard to audit their source code thoroughly and fully</li>
</ul>
</li>
</ul>
<div class="pilwrap" id="randomness">
  <h3>
    <a href="#randomness" name="randomness" class="pilcrow"></a>
Randomness
  </h3>
</div>
<p>We're deferring to built-in
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues">crypto.getRandomValues</a>
which is considered cryptographically secure (CSPRNG).</p>
<p>In the past, browsers had bugs that made it weak: it may happen again.
Implementing a userspace CSPRNG to get resilient to the weakness
is even worse: there is no reliable userspace source of quality entropy.</p>
<div class="pilwrap" id="speed">
  <h2>
    <a href="#speed" name="speed" class="pilcrow"></a>
Speed
  </h2>
</div>
<p>Benchmark results on Apple M2 with node v20:</p>
<pre><code>secp256k1
init x 68 ops/sec @ 14ms/op
getPublicKey x 6,750 ops/sec @ 148Œºs/op
sign x 5,206 ops/sec @ 192Œºs/op
verify x 880 ops/sec @ 1ms/op
getSharedSecret x 536 ops/sec @ 1ms/op
recoverPublicKey x 852 ops/sec @ 1ms/op
schnorr.sign x 685 ops/sec @ 1ms/op
schnorr.verify x 908 ops/sec @ 1ms/op

p256
init x 38 ops/sec @ 26ms/op
getPublicKey x 6,530 ops/sec @ 153Œºs/op
sign x 5,074 ops/sec @ 197Œºs/op
verify x 626 ops/sec @ 1ms/op

p384
init x 17 ops/sec @ 57ms/op
getPublicKey x 2,883 ops/sec @ 346Œºs/op
sign x 2,358 ops/sec @ 424Œºs/op
verify x 245 ops/sec @ 4ms/op

p521
init x 9 ops/sec @ 109ms/op
getPublicKey x 1,516 ops/sec @ 659Œºs/op
sign x 1,271 ops/sec @ 786Œºs/op
verify x 123 ops/sec @ 8ms/op

ed25519
init x 54 ops/sec @ 18ms/op
getPublicKey x 10,269 ops/sec @ 97Œºs/op
sign x 5,110 ops/sec @ 195Œºs/op
verify x 1,049 ops/sec @ 952Œºs/op

ed448
init x 19 ops/sec @ 51ms/op
getPublicKey x 3,775 ops/sec @ 264Œºs/op
sign x 1,771 ops/sec @ 564Œºs/op
verify x 351 ops/sec @ 2ms/op

ecdh
‚îú‚îÄx25519 x 1,466 ops/sec @ 682Œºs/op
‚îú‚îÄsecp256k1 x 539 ops/sec @ 1ms/op
‚îú‚îÄp256 x 511 ops/sec @ 1ms/op
‚îú‚îÄp384 x 199 ops/sec @ 5ms/op
‚îú‚îÄp521 x 103 ops/sec @ 9ms/op
‚îî‚îÄx448 x 548 ops/sec @ 1ms/op

bls12-381
init x 36 ops/sec @ 27ms/op
getPublicKey 1-bit x 973 ops/sec @ 1ms/op
getPublicKey x 970 ops/sec @ 1ms/op
sign x 55 ops/sec @ 17ms/op
verify x 39 ops/sec @ 25ms/op
pairing x 106 ops/sec @ 9ms/op
aggregatePublicKeys/8 x 129 ops/sec @ 7ms/op
aggregatePublicKeys/32 x 34 ops/sec @ 28ms/op
aggregatePublicKeys/128 x 8 ops/sec @ 112ms/op
aggregatePublicKeys/512 x 2 ops/sec @ 446ms/op
aggregatePublicKeys/2048 x 0 ops/sec @ 1778ms/op
aggregateSignatures/8 x 50 ops/sec @ 19ms/op
aggregateSignatures/32 x 13 ops/sec @ 74ms/op
aggregateSignatures/128 x 3 ops/sec @ 296ms/op
aggregateSignatures/512 x 0 ops/sec @ 1180ms/op
aggregateSignatures/2048 x 0 ops/sec @ 4715ms/op

hash-to-curve
hash_to_field x 91,600 ops/sec @ 10Œºs/op
secp256k1 x 2,373 ops/sec @ 421Œºs/op
p256 x 4,310 ops/sec @ 231Œºs/op
p384 x 1,664 ops/sec @ 600Œºs/op
p521 x 807 ops/sec @ 1ms/op
ed25519 x 3,088 ops/sec @ 323Œºs/op
ed448 x 1,247 ops/sec @ 801Œºs/op
</code></pre>
<div class="pilwrap" id="upgrading">
  <h2>
    <a href="#upgrading" name="upgrading" class="pilcrow"></a>
Upgrading
  </h2>
</div>
<p>Previously, the library was split into single-feature packages
<a href="https://github.com/paulmillr/noble-secp256k1">noble-secp256k1</a>,
<a href="https://github.com/paulmillr/noble-ed25519">noble-ed25519</a> and
<a href="https://github.com/paulmillr/noble-bls12-381">noble-bls12-381</a>.</p>
<p>Curves continue their original work. The single-feature packages changed their
direction towards providing minimal 4kb implementations of cryptography,
which means they have less features.</p>
<p>Upgrading from noble-secp256k1 2.0 or noble-ed25519 2.0: no changes, libraries are compatible.</p>
<p>Upgrading from noble-secp256k1 1.7:</p>
<ul>
<li><code>getPublicKey</code>
<ul>
<li>now produce 33-byte compressed signatures by default</li>
<li>to use old behavior, which produced 65-byte uncompressed keys, set
argument <code>isCompressed</code> to <code>false</code>: <code>getPublicKey(priv, false)</code></li>
</ul>
</li>
<li><code>sign</code>
<ul>
<li>is now sync</li>
<li>now returns <code>Signature</code> instance with <code>{ r, s, recovery }</code> properties</li>
<li><code>canonical</code> option was renamed to <code>lowS</code></li>
<li><code>recovered</code> option has been removed because recovery bit is always returned now</li>
<li><code>der</code> option has been removed. There are 2 options:
<ol>
<li>Use compact encoding: <code>fromCompact</code>, <code>toCompactRawBytes</code>, <code>toCompactHex</code>.
Compact encoding is simply a concatenation of 32-byte r and 32-byte s.</li>
<li>If you must use DER encoding, switch to noble-curves (see above).</li>
</ol>
</li>
</ul>
</li>
<li><code>verify</code>
<ul>
<li>is now sync</li>
<li><code>strict</code> option was renamed to <code>lowS</code></li>
</ul>
</li>
<li><code>getSharedSecret</code>
<ul>
<li>now produce 33-byte compressed signatures by default</li>
<li>to use old behavior, which produced 65-byte uncompressed keys, set
argument <code>isCompressed</code> to <code>false</code>: <code>getSharedSecret(a, b, false)</code></li>
</ul>
</li>
<li><code>recoverPublicKey(msg, sig, rec)</code> was changed to <code>sig.recoverPublicKey(msg)</code></li>
<li><code>number</code> type for private keys have been removed: use <code>bigint</code> instead</li>
<li><code>Point</code> (2d xy) has been changed to <code>ProjectivePoint</code> (3d xyz)</li>
<li><code>utils</code> were split into <code>utils</code> (same api as in noble-curves) and
<code>etc</code> (<code>hmacSha256Sync</code> and others)</li>
</ul>
<p>Upgrading from <a href="https://github.com/paulmillr/noble-ed25519">@noble/ed25519</a> 1.7:</p>
<ul>
<li>Methods are now sync by default</li>
<li><code>bigint</code> is no longer allowed in <code>getPublicKey</code>, <code>sign</code>, <code>verify</code>. Reason: ed25519 is LE, can lead to bugs</li>
<li><code>Point</code> (2d xy) has been changed to <code>ExtendedPoint</code> (xyzt)</li>
<li><code>Signature</code> was removed: just use raw bytes or hex now</li>
<li><code>utils</code> were split into <code>utils</code> (same api as in noble-curves) and
<code>etc</code> (<code>sha512Sync</code> and others)</li>
<li><code>getSharedSecret</code> was moved to <code>x25519</code> module</li>
<li><code>toX25519</code> has been moved to <code>edwardsToMontgomeryPub</code> and <code>edwardsToMontgomeryPriv</code> methods</li>
</ul>
<p>Upgrading from <a href="https://github.com/paulmillr/noble-bls12-381">@noble/bls12-381</a>:</p>
<ul>
<li>Methods and classes were renamed:
<ul>
<li>PointG1 -&gt; G1.Point, PointG2 -&gt; G2.Point</li>
<li>PointG2.fromSignature -&gt; Signature.decode, PointG2.toSignature -&gt; Signature.encode</li>
</ul>
</li>
<li>Fp2 ORDER was corrected</li>
</ul>
<div class="pilwrap" id="contributing-and-testing">
  <h2>
    <a href="#contributing-and-testing" name="contributing-and-testing" class="pilcrow"></a>
Contributing &amp; testing
  </h2>
</div>
<ol>
<li>Clone the repository</li>
<li><code>npm install</code> to install build dependencies like TypeScript</li>
<li><code>npm run build</code> to compile TypeScript code</li>
<li><code>npm run test</code> will execute all main tests</li>
</ol>
<div class="pilwrap" id="resources">
  <h2>
    <a href="#resources" name="resources" class="pilcrow"></a>
Resources
  </h2>
</div>
<p>Check out <a href="https://paulmillr.com/noble/">paulmillr.com/noble</a>
for useful resources, articles, documentation and demos
related to the library.</p>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2022 Paul Miller <a href="https://paulmillr.com">(https://paulmillr.com)</a></p>
<p>See LICENSE file.</p>
</div>
  </div>
</body>
</html>
