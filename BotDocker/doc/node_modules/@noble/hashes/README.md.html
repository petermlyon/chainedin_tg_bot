<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "node_modules/@noble/hashes/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#noble-hashes">noble-hashes</a>
      </div>

      <div class="heading h3">
        <a href="#this-library-belongs-to-noble-cryptography">This library belongs to noble cryptography</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h3">
        <a href="#implementations">Implementations</a>
      </div>

      <div class="heading h5">
        <a href="#sha2-sha256-sha384-sha512-sha512_256">sha2: sha256, sha384, sha512, sha512_256</a>
      </div>

      <div class="heading h5">
        <a href="#sha3-fips-shake-keccak">sha3: FIPS, SHAKE, Keccak</a>
      </div>

      <div class="heading h5">
        <a href="#sha3-addons-cshake-kmac-k12-m14-turboshake">sha3-addons: cSHAKE, KMAC, K12, M14, TurboSHAKE</a>
      </div>

      <div class="heading h5">
        <a href="#ripemd160">ripemd160</a>
      </div>

      <div class="heading h5">
        <a href="#blake2b-blake2s-blake3">blake2b, blake2s, blake3</a>
      </div>

      <div class="heading h5">
        <a href="#sha1-legacy-hash">sha1: legacy hash</a>
      </div>

      <div class="heading h5">
        <a href="#hmac">hmac</a>
      </div>

      <div class="heading h5">
        <a href="#hkdf">hkdf</a>
      </div>

      <div class="heading h5">
        <a href="#pbkdf2">pbkdf2</a>
      </div>

      <div class="heading h5">
        <a href="#scrypt">scrypt</a>
      </div>

      <div class="heading h5">
        <a href="#argon2">argon2</a>
      </div>

      <div class="heading h5">
        <a href="#utils">utils</a>
      </div>

      <div class="heading h5">
        <a href="#all-available-imports">All available imports</a>
      </div>

      <div class="heading h2">
        <a href="#security">Security</a>
      </div>

      <div class="heading h3">
        <a href="#constant-timeness">Constant-timeness</a>
      </div>

      <div class="heading h3">
        <a href="#memory-dumping">Memory dumping</a>
      </div>

      <div class="heading h3">
        <a href="#supply-chain-security">Supply chain security</a>
      </div>

      <div class="heading h3">
        <a href="#randomness">Randomness</a>
      </div>

      <div class="heading h2">
        <a href="#speed">Speed</a>
      </div>

      <div class="heading h2">
        <a href="#contributing-and-testing">Contributing &amp;amp; testing</a>
      </div>

      <div class="heading h2">
        <a href="#resources">Resources</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="noble-hashes">
  <h1>
    <a href="#noble-hashes" name="noble-hashes" class="pilcrow"></a>
noble-hashes
  </h1>
</div>
<p>Audited &amp; minimal JS implementation of SHA, RIPEMD, BLAKE, HMAC, HKDF, PBKDF, Scrypt &amp; Argon2.</p>
<ul>
<li>üîí <a href="#security.html"><strong>Audited</strong></a> by an independent security firm</li>
<li>üîª Tree-shaking-friendly: use only what's necessary, other code won't be included</li>
<li>üèé Ultra-fast, hand-optimized for caveats of JS engines</li>
<li>üîç Unique tests ensure correctness: chained tests, sliding window tests, DoS tests, fuzzing</li>
<li>üîÅ No unrolled loops: makes it easier to verify and reduces source code size up to 5x</li>
<li>üê¢ Scrypt supports <code>N: 2**22</code>, while other implementations are limited to <code>2**20</code></li>
<li>ü¶ò SHA3 supports Keccak, cSHAKE, KangarooTwelve, MarsupilamiFourteen and TurboSHAKE</li>
<li>ü™∂ 45KB for everything, 5KB for single-hash build</li>
</ul>
<p>The library's initial development was funded by <a href="https://ethereum.org/">Ethereum Foundation</a>.</p>
<p>For discussions, questions and support, visit
<a href="https://github.com/paulmillr/noble-hashes/discussions">GitHub Discussions</a>
section of the repository.</p>
<div class="pilwrap" id="this-library-belongs-to-noble-cryptography">
  <h3>
    <a href="#this-library-belongs-to-noble-cryptography" name="this-library-belongs-to-noble-cryptography" class="pilcrow"></a>
This library belongs to <em>noble</em> cryptography
  </h3>
</div>
<blockquote>
<p><strong>noble cryptography</strong> ‚Äî high-security, easily auditable set of contained cryptographic libraries and tools.</p>
</blockquote>
<ul>
<li>Zero or minimal dependencies</li>
<li>Highly readable TypeScript / JS code</li>
<li>PGP-signed releases and transparent NPM builds</li>
<li>All libraries:
<a href="https://github.com/paulmillr/noble-ciphers">ciphers</a>,
<a href="https://github.com/paulmillr/noble-curves">curves</a>,
<a href="https://github.com/paulmillr/noble-hashes">hashes</a>,
<a href="https://github.com/paulmillr/noble-post-quantum">post-quantum</a>,
4kb <a href="https://github.com/paulmillr/noble-secp256k1">secp256k1</a> /
<a href="https://github.com/paulmillr/noble-ed25519">ed25519</a></li>
<li><a href="https://paulmillr.com/noble/">Check out homepage</a>
for reading resources, documentation and apps built with noble</li>
</ul>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<blockquote>
<p>npm install @noble/hashes</p>
</blockquote>
<p>We support all major platforms and runtimes.
For <a href="https://deno.land">Deno</a>, ensure to use <a href="https://deno.land/manual@v1.28.0/node/npm_specifiers">npm specifier</a>.
For React Native, you may need a <a href="https://github.com/LinusU/react-native-get-random-values">polyfill for getRandomValues</a>.
A standalone file <a href="https://github.com/paulmillr/noble-hashes/releases">noble-hashes.js</a> is also available.</p>
<pre><code class="js"><span class="hljs-comment">// import * from '@noble/hashes'; // Error: use sub-imports, to ensure small app size</span>
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>; <span class="hljs-comment">// ECMAScript modules (ESM) and Common.js</span>
<span class="hljs-comment">// import { sha256 } from 'npm:@noble/hashes@1.3.0/sha256'; // Deno</span>
<span class="hljs-built_in">console</span>.log(sha256(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))); <span class="hljs-comment">// Uint8Array(32) [3, 144, 88, 198, 242...]</span>
<span class="hljs-comment">// you could also pass strings that will be UTF8-encoded to Uint8Array</span>
<span class="hljs-built_in">console</span>.log(sha256(<span class="hljs-string">'abc'</span>)); <span class="hljs-comment">// == sha256(new TextEncoder().encode('abc'))</span>
</code></pre>
<ul>
<li><a href="#implementations.html">Implementations</a>
<ul>
<li><a href="#sha2-sha256-sha384-sha512-sha512_256.html">sha2: sha256, sha384, sha512, sha512_256</a></li>
<li><a href="#sha3-fips-shake-keccak.html">sha3: FIPS, SHAKE, Keccak</a></li>
<li><a href="#sha3-addons-cshake-kmac-k12-m14-turboshake.html">sha3-addons: cSHAKE, KMAC, K12, M14, TurboSHAKE</a></li>
<li><a href="#ripemd160.html">ripemd160</a></li>
<li><a href="#blake2b-blake2s-blake3.html">blake2b, blake2s, blake3</a></li>
<li><a href="#sha1-legacy-hash.html">sha1: legacy hash</a></li>
<li><a href="#hmac.html">hmac</a></li>
<li><a href="#hkdf.html">hkdf</a></li>
<li><a href="#pbkdf2.html">pbkdf2</a></li>
<li><a href="#scrypt.html">scrypt</a></li>
<li><a href="#argon2.html">argon2</a></li>
<li><a href="#utils.html">utils</a></li>
<li><a href="#all-available-imports.html">All available imports</a></li>
</ul>
</li>
<li><a href="#security.html">Security</a>
<ul>
<li><a href="#constant-timeness.html">Constant-timeness</a></li>
<li><a href="#memory-dumping.html">Memory dumping</a></li>
<li><a href="#supply-chain-security.html">Supply chain security</a></li>
<li><a href="#randomness.html">Randomness</a></li>
</ul>
</li>
<li><a href="#speed.html">Speed</a></li>
<li><a href="#contributing--testing.html">Contributing &amp; testing</a></li>
<li><a href="#resources.html">Resources</a></li>
<li><a href="#license.html">License</a></li>
</ul>
<div class="pilwrap" id="implementations">
  <h3>
    <a href="#implementations" name="implementations" class="pilcrow"></a>
Implementations
  </h3>
</div>
<p>All hash functions:</p>
<ul>
<li>receive <code>Uint8Array</code> and return <code>Uint8Array</code></li>
<li>may receive <code>string</code>, which is automatically converted to <code>Uint8Array</code>
via utf8 encoding <strong>(not hex)</strong></li>
<li>support little-endian and big-endian architectures</li>
<li>can hash up to 4GB per chunk, with any amount of chunks</li>
</ul>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">message: <span class="hljs-built_in">Uint8Array</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Uint8Array</span></span>;
hash(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]));
hash(<span class="hljs-string">'string'</span>) == hash(<span class="hljs-keyword">new</span> TextEncoder().encode(<span class="hljs-string">'string'</span>));
</code></pre>
<p>All hash functions can be constructed via <code>hash.create()</code> method:</p>
<ul>
<li>the result is <code>Hash</code> subclass instance, which has <code>update()</code> and <code>digest()</code> methods</li>
<li><code>digest()</code> finalizes the hash and makes it no longer usable</li>
</ul>
<pre><code class="ts">hash
  .create()
  .update(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]))
  .digest();
</code></pre>
<p><em>Some</em> hash functions can also receive <code>options</code> object, which can be either passed as a:</p>
<ul>
<li>second argument to hash function: <code>blake3('abc', { key: 'd', dkLen: 32 })</code></li>
<li>first argument to class initializer: <code>blake3.create({ context: 'e', dkLen: 32 })</code></li>
</ul>
<div class="pilwrap" id="sha2-sha256-sha384-sha512-sha512_256">
  <h5>
    <a href="#sha2-sha256-sha384-sha512-sha512_256" name="sha2-sha256-sha384-sha512-sha512_256" class="pilcrow"></a>
sha2: sha256, sha384, sha512, sha512_256
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">const</span> h1a = sha256(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h1b = sha256
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();
</code></pre>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { sha512 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-keyword">const</span> h2a = sha512(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h2b = sha512
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();

<span class="hljs-comment">// SHA512/256 variant</span>
<span class="hljs-keyword">import</span> { sha512_256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-keyword">const</span> h3a = sha512_256(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h3b = sha512_256
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();

<span class="hljs-comment">// SHA384</span>
<span class="hljs-keyword">import</span> { sha384 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-keyword">const</span> h4a = sha384(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h4b = sha384
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();
</code></pre>
<p>See <a href="https://datatracker.ietf.org/doc/html/rfc4634">RFC 4634</a> and
<a href="https://eprint.iacr.org/2010/548.pdf">the paper on SHA512/256</a>.</p>
<div class="pilwrap" id="sha3-fips-shake-keccak">
  <h5>
    <a href="#sha3-fips-shake-keccak" name="sha3-fips-shake-keccak" class="pilcrow"></a>
sha3: FIPS, SHAKE, Keccak
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> {
  sha3_224,
  sha3_256,
  sha3_384,
  sha3_512,
  keccak_224,
  keccak_256,
  keccak_384,
  keccak_512,
  shake128,
  shake256,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha3'</span>;
<span class="hljs-keyword">const</span> h5a = sha3_256(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h5b = sha3_256
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();
<span class="hljs-keyword">const</span> h6a = keccak_256(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h7a = shake128(<span class="hljs-string">'abc'</span>, { dkLen: <span class="hljs-number">512</span> });
<span class="hljs-keyword">const</span> h7b = shake256(<span class="hljs-string">'abc'</span>, { dkLen: <span class="hljs-number">512</span> });
</code></pre>
<p>See <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">FIPS PUB 202</a>,
<a href="https://keccak.team/keccak.html">Website</a>.</p>
<p>Check out <a href="https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub">the differences between SHA-3 and Keccak</a></p>
<div class="pilwrap" id="sha3-addons-cshake-kmac-k12-m14-turboshake">
  <h5>
    <a href="#sha3-addons-cshake-kmac-k12-m14-turboshake" name="sha3-addons-cshake-kmac-k12-m14-turboshake" class="pilcrow"></a>
sha3-addons: cSHAKE, KMAC, K12, M14, TurboSHAKE
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> {
  cshake128,
  cshake256,
  kmac128,
  kmac256,
  k12,
  m14,
  turboshake128,
  turboshake256,
  tuplehash128,
  tuplehash256,
  parallelhash128,
  parallelhash256,
  keccakprg,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha3-addons'</span>;
<span class="hljs-keyword">const</span> h7c = cshake128(<span class="hljs-string">'abc'</span>, { personalization: <span class="hljs-string">'def'</span> });
<span class="hljs-keyword">const</span> h7d = cshake256(<span class="hljs-string">'abc'</span>, { personalization: <span class="hljs-string">'def'</span> });
<span class="hljs-keyword">const</span> h7e = kmac128(<span class="hljs-string">'key'</span>, <span class="hljs-string">'message'</span>);
<span class="hljs-keyword">const</span> h7f = kmac256(<span class="hljs-string">'key'</span>, <span class="hljs-string">'message'</span>);
<span class="hljs-keyword">const</span> h7h = k12(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h7g = m14(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h7t1 = turboshake128(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> h7t2 = turboshake256(<span class="hljs-string">'def'</span>, { D: <span class="hljs-number">0x05</span> });
<span class="hljs-keyword">const</span> h7i = tuplehash128([<span class="hljs-string">'ab'</span>, <span class="hljs-string">'c'</span>]); <span class="hljs-comment">// tuplehash(['ab', 'c']) !== tuplehash(['a', 'bc']) !== tuplehash(['abc'])</span>
<span class="hljs-comment">// Same as k12/blake3, but without reduced number of rounds. Doesn't speedup anything due lack of SIMD and threading,</span>
<span class="hljs-comment">// added for compatibility.</span>
<span class="hljs-keyword">const</span> h7j = parallelhash128(<span class="hljs-string">'abc'</span>, { blockLen: <span class="hljs-number">8</span> });
<span class="hljs-comment">// pseudo-random generator, first argument is capacity. XKCP recommends 254 bits capacity for 128-bit security strength.</span>
<span class="hljs-comment">// * with a capacity of 254 bits.</span>
<span class="hljs-keyword">const</span> p = keccakprg(<span class="hljs-number">254</span>);
p.feed(<span class="hljs-string">'test'</span>);
<span class="hljs-keyword">const</span> rand1b = p.fetch(<span class="hljs-number">1</span>);
</code></pre>
<ul>
<li>Full <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf">NIST SP 800-185</a>:
cSHAKE, KMAC, TupleHash, ParallelHash + XOF variants</li>
<li><a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/">Reduced-round Keccak</a>:
<ul>
<li>ü¶ò K12 aka KangarooTwelve</li>
<li>M14 aka MarsupilamiFourteen</li>
<li>TurboSHAKE</li>
</ul>
</li>
<li><a href="https://keccak.team/files/CSF-0.1.pdf">KeccakPRG</a>: Pseudo-random generator based on Keccak</li>
</ul>
<div class="pilwrap" id="ripemd160">
  <h5>
    <a href="#ripemd160" name="ripemd160" class="pilcrow"></a>
ripemd160
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { ripemd160 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/ripemd160'</span>;
<span class="hljs-comment">// function ripemd160(data: Uint8Array): Uint8Array;</span>
<span class="hljs-keyword">const</span> hash8 = ripemd160(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> hash9 = ripemd160
  .create()
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();
</code></pre>
<p>See <a href="https://datatracker.ietf.org/doc/html/rfc2286">RFC 2286</a>,
<a href="https://homes.esat.kuleuven.be/~bosselae/ripemd160.html">Website</a></p>
<div class="pilwrap" id="blake2b-blake2s-blake3">
  <h5>
    <a href="#blake2b-blake2s-blake3" name="blake2b-blake2s-blake3" class="pilcrow"></a>
blake2b, blake2s, blake3
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { blake2b } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake2b'</span>;
<span class="hljs-keyword">import</span> { blake2s } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake2s'</span>;
<span class="hljs-keyword">const</span> h10a = blake2s(<span class="hljs-string">'abc'</span>);
<span class="hljs-keyword">const</span> b2params = { key: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">1</span>]), personalization: t, salt: t, dkLen: <span class="hljs-number">32</span> };
<span class="hljs-keyword">const</span> h10b = blake2s(<span class="hljs-string">'abc'</span>, b2params);
<span class="hljs-keyword">const</span> h10c = blake2s
  .create(b2params)
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .digest();

<span class="hljs-keyword">import</span> { blake3 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake3'</span>;
<span class="hljs-comment">// All params are optional</span>
<span class="hljs-keyword">const</span> h11 = blake3(<span class="hljs-string">'abc'</span>, { dkLen: <span class="hljs-number">256</span>, key: <span class="hljs-string">'def'</span>, context: <span class="hljs-string">'fji'</span> });
</code></pre>
<p>See <a href="https://datatracker.ietf.org/doc/html/rfc7693">RFC 7693</a>, <a href="https://www.blake2.net">Website</a>.</p>
<div class="pilwrap" id="sha1-legacy-hash">
  <h5>
    <a href="#sha1-legacy-hash" name="sha1-legacy-hash" class="pilcrow"></a>
sha1: legacy hash
  </h5>
</div>
<p>SHA1 was cryptographically broken, however, it was not broken for cases like HMAC.</p>
<p>See <a href="https://datatracker.ietf.org/doc/html/rfc4226#appendix-B.2">RFC4226 B.2</a>.</p>
<p>Don't use it for a new protocol.</p>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { sha1 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha1'</span>;
<span class="hljs-keyword">const</span> h12 = sha1(<span class="hljs-string">'def'</span>);
</code></pre>
<div class="pilwrap" id="hmac">
  <h5>
    <a href="#hmac" name="hmac" class="pilcrow"></a>
hmac
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { hmac } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hmac'</span>;
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">const</span> mac1 = hmac(sha256, <span class="hljs-string">'key'</span>, <span class="hljs-string">'message'</span>);
<span class="hljs-keyword">const</span> mac2 = hmac
  .create(sha256, <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))
  .update(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]))
  .digest();
</code></pre>
<p>Matches <a href="https://datatracker.ietf.org/doc/html/rfc2104">RFC 2104</a>.</p>
<div class="pilwrap" id="hkdf">
  <h5>
    <a href="#hkdf" name="hkdf" class="pilcrow"></a>
hkdf
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { hkdf } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hkdf'</span>;
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">import</span> { randomBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
<span class="hljs-keyword">const</span> inputKey = randomBytes(<span class="hljs-number">32</span>);
<span class="hljs-keyword">const</span> salt = randomBytes(<span class="hljs-number">32</span>);
<span class="hljs-keyword">const</span> info = <span class="hljs-string">'abc'</span>;
<span class="hljs-keyword">const</span> dkLen = <span class="hljs-number">32</span>;
<span class="hljs-keyword">const</span> hk1 = hkdf(sha256, inputKey, salt, info, dkLen);

<span class="hljs-comment">// == same as</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> hkdf <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hkdf'</span>;
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">const</span> prk = hkdf.extract(sha256, inputKey, salt);
<span class="hljs-keyword">const</span> hk2 = hkdf.expand(sha256, prk, info, dkLen);
</code></pre>
<p>Matches <a href="https://datatracker.ietf.org/doc/html/rfc5869">RFC 5869</a>.</p>
<div class="pilwrap" id="pbkdf2">
  <h5>
    <a href="#pbkdf2" name="pbkdf2" class="pilcrow"></a>
pbkdf2
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { pbkdf2, pbkdf2Async } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/pbkdf2'</span>;
<span class="hljs-keyword">import</span> { sha256 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha256'</span>;
<span class="hljs-keyword">const</span> pbkey1 = pbkdf2(sha256, <span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, { c: <span class="hljs-number">32</span>, dkLen: <span class="hljs-number">32</span> });
<span class="hljs-keyword">const</span> pbkey2 = <span class="hljs-keyword">await</span> pbkdf2Async(sha256, <span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, { c: <span class="hljs-number">32</span>, dkLen: <span class="hljs-number">32</span> });
<span class="hljs-keyword">const</span> pbkey3 = <span class="hljs-keyword">await</span> pbkdf2Async(sha256, <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]), {
  c: <span class="hljs-number">32</span>,
  dkLen: <span class="hljs-number">32</span>,
});
</code></pre>
<p>Matches <a href="https://datatracker.ietf.org/doc/html/rfc2898">RFC 2898</a>.</p>
<div class="pilwrap" id="scrypt">
  <h5>
    <a href="#scrypt" name="scrypt" class="pilcrow"></a>
scrypt
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { scrypt, scryptAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/scrypt'</span>;
<span class="hljs-keyword">const</span> scr1 = scrypt(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, { N: <span class="hljs-number">2</span> ** <span class="hljs-number">16</span>, r: <span class="hljs-number">8</span>, p: <span class="hljs-number">1</span>, dkLen: <span class="hljs-number">32</span> });
<span class="hljs-keyword">const</span> scr2 = <span class="hljs-keyword">await</span> scryptAsync(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, { N: <span class="hljs-number">2</span> ** <span class="hljs-number">16</span>, r: <span class="hljs-number">8</span>, p: <span class="hljs-number">1</span>, dkLen: <span class="hljs-number">32</span> });
<span class="hljs-keyword">const</span> scr3 = <span class="hljs-keyword">await</span> scryptAsync(<span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), <span class="hljs-built_in">Uint8Array</span>.from([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]), {
  N: <span class="hljs-number">2</span> ** <span class="hljs-number">22</span>,
  r: <span class="hljs-number">8</span>,
  p: <span class="hljs-number">1</span>,
  dkLen: <span class="hljs-number">32</span>,
  onProgress(percentage) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'progress'</span>, percentage);
  },
  maxmem: <span class="hljs-number">2</span> ** <span class="hljs-number">32</span> + <span class="hljs-number">128</span> * <span class="hljs-number">8</span> * <span class="hljs-number">1</span>, <span class="hljs-comment">// N * r * p * 128 + (128*r*p)</span>
});
</code></pre>
<p>Conforms to <a href="https://datatracker.ietf.org/doc/html/rfc7914">RFC 7914</a>,
<a href="https://www.tarsnap.com/scrypt.html">Website</a></p>
<ul>
<li><code>N, r, p</code> are work factors. To understand them, see <a href="https://blog.filippo.io/the-scrypt-parameters/">the blog post</a>.</li>
<li><code>dkLen</code> is the length of output bytes</li>
<li>It is common to use N from <code>2**10</code> to <code>2**22</code> and <code>{r: 8, p: 1, dkLen: 32}</code></li>
<li><code>onProgress</code> can be used with async version of the function to report progress to a user.</li>
</ul>
<p>Memory usage of scrypt is calculated with the formula <code>N * r * p * 128 + (128 * r * p)</code>,
which means <code>{N: 2 ** 22, r: 8, p: 1}</code> will use 4GB + 1KB of memory. To prevent
DoS, we limit scrypt to <code>1GB + 1KB</code> of RAM used, which corresponds to
<code>{N: 2 ** 20, r: 8, p: 1}</code>. If you want to use higher values, increase
<code>maxmem</code> using the formula above.</p>
<p><em>Note:</em> noble supports <code>2**22</code> (4GB RAM) which is the highest amount amongst JS
libs. Many other implementations don't support it. We cannot support <code>2**23</code>,
because there is a limitation in JS engines that makes allocating
arrays bigger than 4GB impossible, but we're looking into other possible solutions.</p>
<div class="pilwrap" id="argon2">
  <h5>
    <a href="#argon2" name="argon2" class="pilcrow"></a>
argon2
  </h5>
</div>
<p>Experimental Argon2 RFC 9106 implementation. It may be removed at any time.</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { argon2d, argon2i, argon2id } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/argon2'</span>;
<span class="hljs-keyword">const</span> result = argon2id(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, { t: <span class="hljs-number">2</span>, m: <span class="hljs-number">65536</span>, p: <span class="hljs-number">1</span> });
</code></pre>
<div class="pilwrap" id="utils">
  <h5>
    <a href="#utils" name="utils" class="pilcrow"></a>
utils
  </h5>
</div>
<pre><code class="typescript"><span class="hljs-keyword">import</span> { bytesToHex <span class="hljs-keyword">as</span> toHex, randomBytes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
<span class="hljs-built_in">console</span>.log(toHex(randomBytes(<span class="hljs-number">32</span>)));
</code></pre>
<ul>
<li><code>bytesToHex</code> will convert <code>Uint8Array</code> to a hex string</li>
<li><code>randomBytes(bytes)</code> will produce cryptographically secure random <code>Uint8Array</code> of length <code>bytes</code></li>
</ul>
<div class="pilwrap" id="all-available-imports">
  <h5>
    <a href="#all-available-imports" name="all-available-imports" class="pilcrow"></a>
All available imports
  </h5>
</div>
<pre><code class="js"><span class="hljs-comment">// sha384 is here, because it uses same internals as sha512</span>
<span class="hljs-keyword">import</span> { sha512, sha512_256, sha384 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha512'</span>;
<span class="hljs-comment">// prettier-ignore</span>
<span class="hljs-keyword">import</span> {
  sha3_224, sha3_256, sha3_384, sha3_512,
  keccak_224, keccak_256, keccak_384, keccak_512,
  shake128, shake256
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha3'</span>;
<span class="hljs-comment">// prettier-ignore</span>
<span class="hljs-keyword">import</span> {
  cshake128, cshake256,
  k12, m14,
  turboshake128, turboshake256,
  kmac128, kmac256,
  tuplehash256, parallelhash256, keccakprg
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha3-addons'</span>;
<span class="hljs-keyword">import</span> { ripemd160 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/ripemd160'</span>;
<span class="hljs-keyword">import</span> { blake3 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake3'</span>;
<span class="hljs-keyword">import</span> { blake2b } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake2b'</span>;
<span class="hljs-keyword">import</span> { blake2s } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/blake2s'</span>;
<span class="hljs-keyword">import</span> { hmac } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hmac'</span>;
<span class="hljs-keyword">import</span> { hkdf } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/hkdf'</span>;
<span class="hljs-keyword">import</span> { pbkdf2, pbkdf2Async } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/pbkdf2'</span>;
<span class="hljs-keyword">import</span> { scrypt, scryptAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/scrypt'</span>;

<span class="hljs-keyword">import</span> { sha1 } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/sha1'</span>; <span class="hljs-comment">// legacy</span>

<span class="hljs-comment">// small utility method that converts bytes to hex</span>
<span class="hljs-keyword">import</span> { bytesToHex <span class="hljs-keyword">as</span> toHex } <span class="hljs-keyword">from</span> <span class="hljs-string">'@noble/hashes/utils'</span>;
<span class="hljs-built_in">console</span>.log(toHex(sha256(<span class="hljs-string">'abc'</span>))); <span class="hljs-comment">// ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad</span>
</code></pre>
<div class="pilwrap" id="security">
  <h2>
    <a href="#security" name="security" class="pilcrow"></a>
Security
  </h2>
</div>
<p>The library has been independently audited:</p>
<ul>
<li>at version 1.0.0, in Jan 2022, by <a href="https://cure53.de">cure53</a>
<ul>
<li>PDFs: <a href="https://cure53.de/pentest-report_hashing-libs.pdf">online</a>, <a href="./audit/2022-01-05-cure53-audit-nbl2.pdf.html">offline, in-repo</a></li>
<li><a href="https://github.com/paulmillr/noble-hashes/compare/1.0.0..main">Changes since audit</a>.</li>
<li>Scope: everything, besides <code>blake3</code>, <code>sha3-addons</code>, <code>sha1</code> and <code>argon2</code>, which have not been audited</li>
<li>The audit has been funded by <a href="https://ethereum.org/en/">Ethereum Foundation</a> with help of <a href="https://nomiclabs.io">Nomic Labs</a></li>
</ul>
</li>
</ul>
<p>It is tested against property-based, cross-library and Wycheproof vectors,
and has fuzzing by <a href="https://github.com/guidovranken/cryptofuzz">Guido Vranken's cryptofuzz</a>.</p>
<p>If you see anything unusual: investigate and report.</p>
<div class="pilwrap" id="constant-timeness">
  <h3>
    <a href="#constant-timeness" name="constant-timeness" class="pilcrow"></a>
Constant-timeness
  </h3>
</div>
<p><em>JIT-compiler</em> and <em>Garbage Collector</em> make &quot;constant time&quot; extremely hard to
achieve <a href="https://en.wikipedia.org/wiki/Timing_attack">timing attack</a> resistance
in a scripting language. Which means <em>any other JS library can't have
constant-timeness</em>. Even statically typed Rust, a language without GC,
<a href="https://www.chosenplaintext.ca/open-source/rust-timing-shield/security">makes it harder to achieve constant-time</a>
for some cases. If your goal is absolute security, don't use any JS lib ‚Äî including bindings to native ones.
Use low-level libraries &amp; languages. Nonetheless we're targetting algorithmic constant time.</p>
<div class="pilwrap" id="memory-dumping">
  <h3>
    <a href="#memory-dumping" name="memory-dumping" class="pilcrow"></a>
Memory dumping
  </h3>
</div>
<p>The library shares state buffers between hash
function calls. The buffers are zeroed-out after each call. However, if an attacker
can read application memory, you are doomed in any case:</p>
<ul>
<li>At some point, input will be a string and strings are immutable in JS:
there is no way to overwrite them with zeros. For example: deriving
key from <code>scrypt(password, salt)</code> where password and salt are strings</li>
<li>Input from a file will stay in file buffers</li>
<li>Input / output will be re-used multiple times in application which means it could stay in memory</li>
<li><code>await anything()</code> will always write all internal variables (including numbers)
to memory. With async functions / Promises there are no guarantees when the code
chunk would be executed. Which means attacker can have plenty of time to read data from memory</li>
<li>There is no way to guarantee anything about zeroing sensitive data without
complex tests-suite which will dump process memory and verify that there is
no sensitive data left. For JS it means testing all browsers (incl. mobile),
which is complex. And of course it will be useless without using the same
test-suite in the actual application that consumes the library</li>
</ul>
<div class="pilwrap" id="supply-chain-security">
  <h3>
    <a href="#supply-chain-security" name="supply-chain-security" class="pilcrow"></a>
Supply chain security
  </h3>
</div>
<ul>
<li><strong>Commits</strong> are signed with PGP keys, to prevent forgery. Make sure to verify commit signatures.</li>
<li><strong>Releases</strong> are transparent and built on GitHub CI. Make sure to verify <a href="https://docs.npmjs.com/generating-provenance-statements">provenance</a> logs</li>
<li><strong>Rare releasing</strong> is followed to ensure less re-audit need for end-users</li>
<li><strong>Dependencies</strong> are minimized and locked-down:
<ul>
<li>If your app has 500 dependencies, any dep could get hacked and you'll be downloading
malware with every install. We make sure to use as few dependencies as possible</li>
<li>We prevent automatic dependency updates by locking-down version ranges. Every update is checked with <code>npm-diff</code></li>
</ul>
</li>
<li><strong>Dev Dependencies</strong> are only used if you want to contribute to the repo. They are disabled for end-users:
<ul>
<li>scure-base, scure-bip32, scure-bip39, micro-bmark and micro-should are developed by the same author and follow identical security practices</li>
<li>prettier (linter), fast-check (property-based testing) and typescript are used for code quality, vector generation and ts compilation. The packages are big, which makes it hard to audit their source code thoroughly and fully</li>
</ul>
</li>
</ul>
<div class="pilwrap" id="randomness">
  <h3>
    <a href="#randomness" name="randomness" class="pilcrow"></a>
Randomness
  </h3>
</div>
<p>We're deferring to built-in
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues">crypto.getRandomValues</a>
which is considered cryptographically secure (CSPRNG).</p>
<p>In the past, browsers had bugs that made it weak: it may happen again.
Implementing a userspace CSPRNG to get resilient to the weakness
is even worse: there is no reliable userspace source of quality entropy.</p>
<div class="pilwrap" id="speed">
  <h2>
    <a href="#speed" name="speed" class="pilcrow"></a>
Speed
  </h2>
</div>
<p>Benchmarks measured on Apple M1 with macOS 12.
Note that PBKDF2 and Scrypt are tested with extremely high work factor.
To run benchmarks, execute <code>npm run bench:install</code> and then <code>npm run bench</code></p>
<pre><code>SHA256 32B x 1,219,512 ops/sec @ 820ns/op ¬± 2.58% (min: 625ns, max: 4ms)
SHA384 32B x 512,032 ops/sec @ 1Œºs/op
SHA512 32B x 509,943 ops/sec @ 1Œºs/op
SHA3-256, keccak256, shake256 32B x 199,600 ops/sec @ 5Œºs/op
Kangaroo12 32B x 336,360 ops/sec @ 2Œºs/op
Marsupilami14 32B x 298,418 ops/sec @ 3Œºs/op
BLAKE2b 32B x 379,794 ops/sec @ 2Œºs/op
BLAKE2s 32B x 515,995 ops/sec @ 1Œºs/op ¬± 1.07% (min: 1Œºs, max: 4ms)
BLAKE3 32B x 588,235 ops/sec @ 1Œºs/op ¬± 1.36% (min: 1Œºs, max: 5ms)
RIPEMD160 32B x 1,140,250 ops/sec @ 877ns/op ¬± 3.12% (min: 708ns, max: 6ms)
HMAC-SHA256 32B x 377,358 ops/sec @ 2Œºs/op

HKDF-SHA256 32B x 108,377 ops/sec @ 9Œºs/op
PBKDF2-HMAC-SHA256 262144 x 3 ops/sec @ 326ms/op
PBKDF2-HMAC-SHA512 262144 x 1 ops/sec @ 970ms/op
Scrypt r: 8, p: 1, n: 262144 x 1 ops/sec @ 616ms/op
</code></pre>
<p>Compare to native node.js implementation that uses C bindings instead of pure-js code:</p>
<pre><code>SHA256 32B node x 1,302,083 ops/sec @ 768ns/op ¬± 10.54% (min: 416ns, max: 7ms)
SHA384 32B node x 975,609 ops/sec @ 1Œºs/op ¬± 11.32% (min: 625ns, max: 8ms)
SHA512 32B node x 983,284 ops/sec @ 1Œºs/op ¬± 11.24% (min: 625ns, max: 8ms)
SHA3-256 32B node x 910,746 ops/sec @ 1Œºs/op ¬± 12.19% (min: 666ns, max: 10ms)
keccak, k12, m14 are not implemented
BLAKE2b 32B node x 967,117 ops/sec @ 1Œºs/op ¬± 11.26% (min: 625ns, max: 9ms)
BLAKE2s 32B node x 1,055,966 ops/sec @ 947ns/op ¬± 11.07% (min: 583ns, max: 7ms)
BLAKE3 is not implemented
RIPEMD160 32B node x 1,002,004 ops/sec @ 998ns/op ¬± 10.66% (min: 625ns, max: 7ms)
HMAC-SHA256 32B node x 919,963 ops/sec @ 1Œºs/op ¬± 6.13% (min: 833ns, max: 5ms)
HKDF-SHA256 32 node x 369,276 ops/sec @ 2Œºs/op ¬± 13.59% (min: 1Œºs, max: 9ms)
PBKDF2-HMAC-SHA256 262144 node x 25 ops/sec @ 39ms/op
PBKDF2-HMAC-SHA512 262144 node x 7 ops/sec @ 132ms/op
Scrypt r: 8, p: 1, n: 262144 node x 1 ops/sec @ 523ms/op
</code></pre>
<p>It is possible to <a href="./benchmark/README.md.html">make this library 4x+ faster</a> by
<em>doing code generation of full loop unrolls</em>. We've decided against it. Reasons:</p>
<ul>
<li>the library must be auditable, with minimum amount of code, and zero dependencies</li>
<li>most method invocations with the lib are going to be something like hashing 32b to 64kb of data</li>
<li>hashing big inputs is 10x faster with low-level languages, which means you should probably pick 'em instead</li>
</ul>
<p>The current performance is good enough when compared to other projects; SHA256 takes only 900 nanoseconds to run.</p>
<div class="pilwrap" id="contributing-and-testing">
  <h2>
    <a href="#contributing-and-testing" name="contributing-and-testing" class="pilcrow"></a>
Contributing &amp; testing
  </h2>
</div>
<ol>
<li>Clone the repository</li>
<li><code>npm install</code> to install build dependencies like TypeScript</li>
<li><code>npm run build</code> to compile TypeScript code</li>
<li><code>npm run test</code> will execute all main tests. See <a href="./test/README.md.html">our approach to testing</a></li>
<li><code>npm run test:dos</code> will test against DoS; by measuring function complexity. <strong>Takes ~20 minutes</strong></li>
<li><code>npm run test:big</code> will execute hashing on 4GB inputs,
scrypt with 1024 different <code>N, r, p</code> combinations, etc. <strong>Takes several hours</strong>. Using 8-32+ core CPU helps.</li>
</ol>
<div class="pilwrap" id="resources">
  <h2>
    <a href="#resources" name="resources" class="pilcrow"></a>
Resources
  </h2>
</div>
<p>Check out <a href="https://paulmillr.com/noble/">paulmillr.com/noble</a>
for useful resources, articles, documentation and demos
related to the library.</p>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2022 Paul Miller <a href="https://paulmillr.com">(https://paulmillr.com)</a></p>
<p>See LICENSE file.</p>
</div>
  </div>
</body>
</html>
