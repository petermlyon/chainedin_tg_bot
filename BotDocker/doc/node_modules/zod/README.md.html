<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/zod/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#zod">Zod</a>
      </div>

      <div class="heading h2">
        <a href="#table-of-contents">Table of contents</a>
      </div>

      <div class="heading h2">
        <a href="#introduction">Introduction</a>
      </div>

      <div class="heading h3">
        <a href="#sponsors">Sponsors</a>
      </div>

      <div class="heading h4">
        <a href="#platinum">Platinum</a>
      </div>

      <div class="heading h4">
        <a href="#gold">Gold</a>
      </div>

      <div class="heading h4">
        <a href="#silver">Silver</a>
      </div>

      <div class="heading h4">
        <a href="#bronze">Bronze</a>
      </div>

      <div class="heading h3">
        <a href="#ecosystem">Ecosystem</a>
      </div>

      <div class="heading h4">
        <a href="#resources">Resources</a>
      </div>

      <div class="heading h4">
        <a href="#api-libraries">API libraries</a>
      </div>

      <div class="heading h4">
        <a href="#form-integrations">Form integrations</a>
      </div>

      <div class="heading h4">
        <a href="#zod-to-x">Zod to X</a>
      </div>

      <div class="heading h4">
        <a href="#x-to-zod">X to Zod</a>
      </div>

      <div class="heading h4">
        <a href="#mocking">Mocking</a>
      </div>

      <div class="heading h4">
        <a href="#powered-by-zod">Powered by Zod</a>
      </div>

      <div class="heading h4">
        <a href="#utilities-for-zod">Utilities for Zod</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h3">
        <a href="#requirements">Requirements</a>
      </div>

      <div class="heading h3">
        <a href="#from-npm-nodebun">From npm (Node/Bun)</a>
      </div>

      <div class="heading h3">
        <a href="#from-deno.landx-deno">From deno.land/x (Deno)</a>
      </div>

      <div class="heading h2">
        <a href="#basic-usage">Basic usage</a>
      </div>

      <div class="heading h2">
        <a href="#primitives">Primitives</a>
      </div>

      <div class="heading h2">
        <a href="#coercion-for-primitives">Coercion for primitives</a>
      </div>

      <div class="heading h2">
        <a href="#literals">Literals</a>
      </div>

      <div class="heading h2">
        <a href="#strings">Strings</a>
      </div>

      <div class="heading h3">
        <a href="#datetimes">Datetimes</a>
      </div>

      <div class="heading h3">
        <a href="#dates">Dates</a>
      </div>

      <div class="heading h3">
        <a href="#times">Times</a>
      </div>

      <div class="heading h3">
        <a href="#ip-addresses">IP addresses</a>
      </div>

      <div class="heading h2">
        <a href="#numbers">Numbers</a>
      </div>

      <div class="heading h2">
        <a href="#bigints">BigInts</a>
      </div>

      <div class="heading h2">
        <a href="#nans">NaNs</a>
      </div>

      <div class="heading h2">
        <a href="#booleans">Booleans</a>
      </div>

      <div class="heading h2">
        <a href="#dates-1">Dates</a>
      </div>

      <div class="heading h2">
        <a href="#zod-enums">Zod enums</a>
      </div>

      <div class="heading h2">
        <a href="#native-enums">Native enums</a>
      </div>

      <div class="heading h2">
        <a href="#optionals">Optionals</a>
      </div>

      <div class="heading h2">
        <a href="#nullables">Nullables</a>
      </div>

      <div class="heading h2">
        <a href="#objects">Objects</a>
      </div>

      <div class="heading h3">
        <a href="#.shape">.shape</a>
      </div>

      <div class="heading h3">
        <a href="#.keyof">.keyof</a>
      </div>

      <div class="heading h3">
        <a href="#.extend">.extend</a>
      </div>

      <div class="heading h3">
        <a href="#.merge">.merge</a>
      </div>

      <div class="heading h3">
        <a href="#.pick.omit">.pick/.omit</a>
      </div>

      <div class="heading h3">
        <a href="#.partial">.partial</a>
      </div>

      <div class="heading h3">
        <a href="#.deeppartial">.deepPartial</a>
      </div>

      <div class="heading h3">
        <a href="#.required">.required</a>
      </div>

      <div class="heading h3">
        <a href="#.passthrough">.passthrough</a>
      </div>

      <div class="heading h3">
        <a href="#.strict">.strict</a>
      </div>

      <div class="heading h3">
        <a href="#.strip">.strip</a>
      </div>

      <div class="heading h3">
        <a href="#.catchall">.catchall</a>
      </div>

      <div class="heading h2">
        <a href="#arrays">Arrays</a>
      </div>

      <div class="heading h3">
        <a href="#.element">.element</a>
      </div>

      <div class="heading h3">
        <a href="#.nonempty">.nonempty</a>
      </div>

      <div class="heading h3">
        <a href="#.min.max.length">.min/.max/.length</a>
      </div>

      <div class="heading h2">
        <a href="#tuples">Tuples</a>
      </div>

      <div class="heading h2">
        <a href="#unions">Unions</a>
      </div>

      <div class="heading h2">
        <a href="#discriminated-unions">Discriminated unions</a>
      </div>

      <div class="heading h2">
        <a href="#records">Records</a>
      </div>

      <div class="heading h2">
        <a href="#maps">Maps</a>
      </div>

      <div class="heading h2">
        <a href="#sets">Sets</a>
      </div>

      <div class="heading h2">
        <a href="#intersections">Intersections</a>
      </div>

      <div class="heading h2">
        <a href="#recursive-types">Recursive types</a>
      </div>

      <div class="heading h3">
        <a href="#zodtype-with-zodeffects">ZodType with ZodEffects</a>
      </div>

      <div class="heading h3">
        <a href="#json-type">JSON type</a>
      </div>

      <div class="heading h3">
        <a href="#cyclical-objects">Cyclical objects</a>
      </div>

      <div class="heading h2">
        <a href="#promises">Promises</a>
      </div>

      <div class="heading h2">
        <a href="#instanceof">Instanceof</a>
      </div>

      <div class="heading h2">
        <a href="#functions">Functions</a>
      </div>

      <div class="heading h2">
        <a href="#preprocess">Preprocess</a>
      </div>

      <div class="heading h2">
        <a href="#custom-schemas">Custom schemas</a>
      </div>

      <div class="heading h2">
        <a href="#schema-methods">Schema methods</a>
      </div>

      <div class="heading h3">
        <a href="#.parse">.parse</a>
      </div>

      <div class="heading h3">
        <a href="#.parseasync">.parseAsync</a>
      </div>

      <div class="heading h3">
        <a href="#.safeparse">.safeParse</a>
      </div>

      <div class="heading h3">
        <a href="#.safeparseasync">.safeParseAsync</a>
      </div>

      <div class="heading h3">
        <a href="#.refine">.refine</a>
      </div>

      <div class="heading h4">
        <a href="#arguments">Arguments</a>
      </div>

      <div class="heading h4">
        <a href="#customize-error-path">Customize error path</a>
      </div>

      <div class="heading h4">
        <a href="#asynchronous-refinements">Asynchronous refinements</a>
      </div>

      <div class="heading h4">
        <a href="#relationship-to-transforms">Relationship to transforms</a>
      </div>

      <div class="heading h3">
        <a href="#.superrefine">.superRefine</a>
      </div>

      <div class="heading h4">
        <a href="#abort-early">Abort early</a>
      </div>

      <div class="heading h4">
        <a href="#type-refinements">Type refinements</a>
      </div>

      <div class="heading h3">
        <a href="#.transform">.transform</a>
      </div>

      <div class="heading h4">
        <a href="#chaining-order">Chaining order</a>
      </div>

      <div class="heading h4">
        <a href="#validating-during-transform">Validating during transform</a>
      </div>

      <div class="heading h4">
        <a href="#relationship-to-refinements">Relationship to refinements</a>
      </div>

      <div class="heading h4">
        <a href="#async-transforms">Async transforms</a>
      </div>

      <div class="heading h3">
        <a href="#.default">.default</a>
      </div>

      <div class="heading h3">
        <a href="#.describe">.describe</a>
      </div>

      <div class="heading h3">
        <a href="#.catch">.catch</a>
      </div>

      <div class="heading h3">
        <a href="#.optional">.optional</a>
      </div>

      <div class="heading h3">
        <a href="#.nullable">.nullable</a>
      </div>

      <div class="heading h3">
        <a href="#.nullish">.nullish</a>
      </div>

      <div class="heading h3">
        <a href="#.array">.array</a>
      </div>

      <div class="heading h3">
        <a href="#.promise">.promise</a>
      </div>

      <div class="heading h3">
        <a href="#.or">.or</a>
      </div>

      <div class="heading h3">
        <a href="#.and">.and</a>
      </div>

      <div class="heading h3">
        <a href="#.brand">.brand</a>
      </div>

      <div class="heading h3">
        <a href="#.readonly">.readonly</a>
      </div>

      <div class="heading h3">
        <a href="#.pipe">.pipe</a>
      </div>

      <div class="heading h4">
        <a href="#you-can-use.pipe-to-fix-common-issues-with-z.coerce">You can use .pipe() to fix common issues with z.coerce.</a>
      </div>

      <div class="heading h2">
        <a href="#guides-and-concepts">Guides and concepts</a>
      </div>

      <div class="heading h3">
        <a href="#type-inference">Type inference</a>
      </div>

      <div class="heading h3">
        <a href="#writing-generic-functions">Writing generic functions</a>
      </div>

      <div class="heading h4">
        <a href="#inferring-the-inferred-type">Inferring the inferred type</a>
      </div>

      <div class="heading h4">
        <a href="#constraining-allowable-inputs">Constraining allowable inputs</a>
      </div>

      <div class="heading h3">
        <a href="#error-handling">Error handling</a>
      </div>

      <div class="heading h3">
        <a href="#error-formatting">Error formatting</a>
      </div>

      <div class="heading h2">
        <a href="#comparison">Comparison</a>
      </div>

      <div class="heading h3">
        <a href="#joi">Joi</a>
      </div>

      <div class="heading h3">
        <a href="#yup">Yup</a>
      </div>

      <div class="heading h3">
        <a href="#io-ts">io-ts</a>
      </div>

      <div class="heading h3">
        <a href="#runtypes">Runtypes</a>
      </div>

      <div class="heading h3">
        <a href="#ow">Ow</a>
      </div>

      <div class="heading h2">
        <a href="#changelog">Changelog</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><p align="center">
  <img src="logo.svg" width="200px" align="center" alt="Zod logo" />
  <div class="pilwrap" id="zod">
  <h1 align="center">
    <a href="#zod" name="zod" class="pilcrow"></a>
Zod
  </h1>
</div>
  <p align="center">
    ✨ <a href="https://zod.dev">https://zod.dev</a> ✨
    <br/>
    TypeScript-first schema validation with static type inference
  </p>
</p>
<br/>
<p align="center">
<a href="https://github.com/colinhacks/zod/actions?query=branch%3Amaster"><img src="https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&branch=master" alt="Zod CI status" /></a>
<a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell"></a>
<a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars"></a>
<a href="https://discord.gg/KaSRdyX2vc" rel="nofollow"><img src="https://img.shields.io/discord/893487829802418277?label=Discord&logo=discord&logoColor=white" alt="discord server"></a>
</p>
<div align="center">
  <a href="https://zod.dev">Documentation</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://discord.gg/RcG33DQJdf">Discord</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://www.npmjs.com/package/zod">npm</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://deno.land/x/zod">deno</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://github.com/colinhacks/zod/issues/new">Issues</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://twitter.com/colinhacks">@colinhacks</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://trpc.io">tRPC</a>
  <br />
</div>
<br/>
<br/>
<blockquote>
<p>Zod 3.23 is out! View the <a href="https://github.com/colinhacks/zod/releases/tag/v3.23.0">release notes</a>.</p>
</blockquote>
<blockquote>
<p>These docs have been translated into <a href="./README_ZH.md.html">Chinese</a>.</p>
</blockquote>
<div class="pilwrap" id="table-of-contents">
  <h2>
    <a href="#table-of-contents" name="table-of-contents" class="pilcrow"></a>
Table of contents
  </h2>
</div>
<!-- The full documentation is available both on the [official documentation site](https://zod.js.org/) (recommended) and in `README.md`.

#### Go to [zod.js.org](https://zod.js.org) >> -->
<ul>
<li><a href="#table-of-contents.html">Table of contents</a></li>
<li><a href="#introduction.html">Introduction</a>
<ul>
<li><a href="#sponsors.html">Sponsors</a>
<ul>
<li><a href="#gold.html">Gold</a></li>
<li><a href="#silver.html">Silver</a></li>
<li><a href="#bronze.html">Bronze</a></li>
<li><a href="#copper.html">Copper</a></li>
</ul>
</li>
<li><a href="#ecosystem.html">Ecosystem</a>
<ul>
<li><a href="#resources.html">Resources</a></li>
<li><a href="#api-libraries.html">API libraries</a></li>
<li><a href="#form-integrations.html">Form integrations</a></li>
<li><a href="#zod-to-x.html">Zod to X</a></li>
<li><a href="#x-to-zod.html">X to Zod</a></li>
<li><a href="#mocking.html">Mocking</a></li>
<li><a href="#powered-by-zod.html">Powered by Zod</a></li>
<li><a href="#utilities-for-zod.html">Utilities for Zod</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#installation.html">Installation</a>
<ul>
<li><a href="#requirements.html">Requirements</a></li>
<li><a href="#from-npm-nodebun.html">From <code>npm</code> (Node/Bun)</a></li>
<li><a href="#from-denolandx-deno.html">From <code>deno.land/x</code> (Deno)</a></li>
</ul>
</li>
<li><a href="#basic-usage.html">Basic usage</a></li>
<li><a href="#primitives.html">Primitives</a></li>
<li><a href="#coercion-for-primitives.html">Coercion for primitives</a></li>
<li><a href="#literals.html">Literals</a></li>
<li><a href="#strings.html">Strings</a>
<ul>
<li><a href="#datetimes.html">Datetimes</a></li>
<li><a href="#dates.html">Dates</a></li>
<li><a href="#times.html">Times</a></li>
<li><a href="#ip-addresses.html">IP addresses</a></li>
</ul>
</li>
<li><a href="#numbers.html">Numbers</a></li>
<li><a href="#bigints.html">BigInts</a></li>
<li><a href="#nans.html">NaNs</a></li>
<li><a href="#booleans.html">Booleans</a></li>
<li><a href="#dates.html">Dates</a></li>
<li><a href="#zod-enums.html">Zod enums</a></li>
<li><a href="#native-enums.html">Native enums</a></li>
<li><a href="#optionals.html">Optionals</a></li>
<li><a href="#nullables.html">Nullables</a></li>
<li><a href="#objects.html">Objects</a>
<ul>
<li><a href="#shape.html"><code>.shape</code></a></li>
<li><a href="#keyof.html"><code>.keyof</code></a></li>
<li><a href="#extend.html"><code>.extend</code></a></li>
<li><a href="#merge.html"><code>.merge</code></a></li>
<li><a href="#pickomit.html"><code>.pick/.omit</code></a></li>
<li><a href="#partial.html"><code>.partial</code></a></li>
<li><a href="#deeppartial.html"><code>.deepPartial</code></a></li>
<li><a href="#required.html"><code>.required</code></a></li>
<li><a href="#passthrough.html"><code>.passthrough</code></a></li>
<li><a href="#strict.html"><code>.strict</code></a></li>
<li><a href="#strip.html"><code>.strip</code></a></li>
<li><a href="#catchall.html"><code>.catchall</code></a></li>
</ul>
</li>
<li><a href="#arrays.html">Arrays</a>
<ul>
<li><a href="#element.html"><code>.element</code></a></li>
<li><a href="#nonempty.html"><code>.nonempty</code></a></li>
<li><a href="#minmaxlength.html"><code>.min/.max/.length</code></a></li>
</ul>
</li>
<li><a href="#tuples.html">Tuples</a></li>
<li><a href="#unions.html">Unions</a></li>
<li><a href="#discriminated-unions.html">Discriminated unions</a></li>
<li><a href="#records.html">Records</a>
<ul>
<li><a href="#record-key-type.html">Record key type</a></li>
</ul>
</li>
<li><a href="#maps.html">Maps</a></li>
<li><a href="#sets.html">Sets</a></li>
<li><a href="#intersections.html">Intersections</a></li>
<li><a href="#recursive-types.html">Recursive types</a>
<ul>
<li><a href="#zodtype-with-zodeffects.html">ZodType with ZodEffects</a></li>
<li><a href="#json-type.html">JSON type</a></li>
<li><a href="#cyclical-objects.html">Cyclical objects</a></li>
</ul>
</li>
<li><a href="#promises.html">Promises</a></li>
<li><a href="#instanceof.html">Instanceof</a></li>
<li><a href="#functions.html">Functions</a></li>
<li><a href="#preprocess.html">Preprocess</a></li>
<li><a href="#custom-schemas.html">Custom schemas</a></li>
<li><a href="#schema-methods.html">Schema methods</a>
<ul>
<li><a href="#parse.html"><code>.parse</code></a></li>
<li><a href="#parseasync.html"><code>.parseAsync</code></a></li>
<li><a href="#safeparse.html"><code>.safeParse</code></a></li>
<li><a href="#safeparseasync.html"><code>.safeParseAsync</code></a></li>
<li><a href="#refine.html"><code>.refine</code></a>
<ul>
<li><a href="#arguments.html">Arguments</a></li>
<li><a href="#customize-error-path.html">Customize error path</a></li>
<li><a href="#asynchronous-refinements.html">Asynchronous refinements</a></li>
<li><a href="#relationship-to-transforms.html">Relationship to transforms</a></li>
</ul>
</li>
<li><a href="#superrefine.html"><code>.superRefine</code></a>
<ul>
<li><a href="#abort-early.html">Abort early</a></li>
<li><a href="#type-refinements.html">Type refinements</a></li>
</ul>
</li>
<li><a href="#transform.html"><code>.transform</code></a>
<ul>
<li><a href="#chaining-order.html">Chaining order</a></li>
<li><a href="#validating-during-transform.html">Validating during transform</a></li>
<li><a href="#relationship-to-refinements.html">Relationship to refinements</a></li>
<li><a href="#async-transforms.html">Async transforms</a></li>
</ul>
</li>
<li><a href="#default.html"><code>.default</code></a></li>
<li><a href="#describe.html"><code>.describe</code></a></li>
<li><a href="#catch.html"><code>.catch</code></a></li>
<li><a href="#optional.html"><code>.optional</code></a></li>
<li><a href="#nullable.html"><code>.nullable</code></a></li>
<li><a href="#nullish.html"><code>.nullish</code></a></li>
<li><a href="#array.html"><code>.array</code></a></li>
<li><a href="#promise.html"><code>.promise</code></a></li>
<li><a href="#or.html"><code>.or</code></a></li>
<li><a href="#and.html"><code>.and</code></a></li>
<li><a href="#brand.html"><code>.brand</code></a></li>
<li><a href="#readonly.html"><code>.readonly</code></a></li>
<li><a href="#pipe.html"><code>.pipe</code></a>
<ul>
<li><a href="#you-can-use-pipe-to-fix-common-issues-with-zcoerce.html">You can use <code>.pipe()</code> to fix common issues with <code>z.coerce</code>.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#guides-and-concepts.html">Guides and concepts</a>
<ul>
<li><a href="#type-inference.html">Type inference</a></li>
<li><a href="#writing-generic-functions.html">Writing generic functions</a>
<ul>
<li><a href="#constraining-allowable-inputs.html">Constraining allowable inputs</a></li>
</ul>
</li>
<li><a href="#error-handling.html">Error handling</a></li>
<li><a href="#error-formatting.html">Error formatting</a></li>
</ul>
</li>
<li><a href="#comparison.html">Comparison</a>
<ul>
<li><a href="#joi.html">Joi</a></li>
<li><a href="#yup.html">Yup</a></li>
<li><a href="#io-ts.html">io-ts</a></li>
<li><a href="#runtypes.html">Runtypes</a></li>
<li><a href="#ow.html">Ow</a></li>
</ul>
</li>
<li><a href="#changelog.html">Changelog</a></li>
</ul>
<div class="pilwrap" id="introduction">
  <h2>
    <a href="#introduction" name="introduction" class="pilcrow"></a>
Introduction
  </h2>
</div>
<p>Zod is a TypeScript-first schema declaration and validation library. I'm using the term &quot;schema&quot; to broadly refer to any data type, from a simple <code>string</code> to a complex nested object.</p>
<p>Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator <em>once</em> and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.</p>
<p>Some other great aspects:</p>
<ul>
<li>Zero dependencies</li>
<li>Works in Node.js and all modern browsers</li>
<li>Tiny: 8kb minified + zipped</li>
<li>Immutable: methods (e.g. <code>.optional()</code>) return a new instance</li>
<li>Concise, chainable interface</li>
<li>Functional approach: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don't validate</a></li>
<li>Works with plain JavaScript too! You don't need to use TypeScript.</li>
</ul>
<div class="pilwrap" id="sponsors">
  <h3>
    <a href="#sponsors" name="sponsors" class="pilcrow"></a>
Sponsors
  </h3>
</div>
<p>Sponsorship at any level is appreciated and encouraged. For individual developers, consider the <a href="https://github.com/sponsors/colinhacks">Cup of Coffee tier</a>. If you built a paid product using Zod, consider one of the <a href="https://github.com/sponsors/colinhacks">podium tiers</a>.</p>
<div class="pilwrap" id="platinum">
  <h4>
    <a href="#platinum" name="platinum" class="pilcrow"></a>
Platinum
  </h4>
</div>
<blockquote>
<p><a href="mailto:colin@colinhacks.com.html">Email me</a> to discuss sponsoring Zod at this level.</p>
</blockquote>
<!-- <table>
  <tr>
    <td align="center">
      <a href="https://www.example.com" target="_blank">
        <img src="https://example.com/image.png" height="100px;" alt="XXX" />
      </a>
      <br />
      <b>XXX</b>
      <br />
      <a href="https://www.example.com" target="_blank">example.com</a>
    </td>
  </tr>
</table> -->
<div class="pilwrap" id="gold">
  <h4>
    <a href="#gold" name="gold" class="pilcrow"></a>
Gold
  </h4>
</div>
<table>
  <tr>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/80861386?s=200&v=4" height="45px;" alt="Cerbos" />
      <br />
      <a href="https://cerbos.dev/" target="_blank">Cerbos</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/301879?s=200&v=4" height="45px;" alt="Scalar.com logo" />
      <br />
      <a href="https://scalar.com/" target="_blank">Scalar</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/91446104?s=200&v=4" height="45px;" alt="Speakeasy API" />
      <br />
      <a href="https://speakeasyapi.dev/" target="_blank">Speakeasy</a>
    </td>
    <td align="center">
      <img src="https://avatars0.githubusercontent.com/u/15068039?s=200&v=4" height="45px;" alt="Deletype logo" />
      <br />
      <a href="https://deletype.com" target="_blank">Deletype</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/95297378?s=200&v=4" height="45px;" alt="Trigger.dev logo" />
      <br />
      <a href="https://trigger.dev" target="_blank">Trigger.dev</a>
    </td>
  </tr><tr>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/125754?s=200&v=4" height="45px;" alt="Transloadit logo" />
      <br />
      <a href="https://transloadit.com/?utm_source=zod&utm_medium=refe
    rral&utm_campaign=sponsorship&utm_content=github" target="_blank">Transloadit</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/107880645?s=200&v=4" height="45px;" alt="Infisical logo" />
      <br />
      <a href="https://infisical.com" target="_blank">Infisical</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/91036480?s=200&v=4" height="45px;" alt="Whop logo" />
      <br />
      <a href="https://whop.com/" target="_blank">Whop</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/36402888?s=200&v=4" height="45px;" alt="CryptoJobsList logo" />
      <br />
      <a href="https://cryptojobslist.com/" target="_blank">CryptoJobsList</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/70170949?s=200&v=4" height="45px;" alt="Plain logo" />
      <br />
      <a href="https://plain.com/" target="_blank">Plain.</a>
    </td>
  </tr><tr>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/78935958?s=200&v=4" height="45px;" alt="Inngest logo" />
      <br />
      <a href="https://inngest.com/" target="_blank">Inngest</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/13880908?s=200&v=4" height="45px;" alt="Storyblok CMS" />
      <br />
      <a href="https://storyblok.com/" target="_blank">Storyblok</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/16199997?s=200&v=4" height="45px;" alt="Mux logo" />
      <br />
      <a href="https://mux.link/zod" target="_blank">Mux</a>
    </td>
    <td align="center">
      <img src="https://avatars.githubusercontent.com/u/180984?v=4" height="45px;" alt="@emreb" />
      <br />
      <a href="https://github.com/emreb" target="_blank"><code>@emreb</code></a>
    </td>
  </tr>
</table>
<div class="pilwrap" id="silver">
  <h4>
    <a href="#silver" name="silver" class="pilcrow"></a>
Silver
  </h4>
</div>
<table>
  <tr>
    <td align="center">
      <a href="https://www.numeric.io">
        <img src="https://i.imgur.com/kTiLtZt.png" height="40px;" alt="Numeric logo" />
      </a>
    </td>
    <td>
      <a href="https://marcatopartners.com">
        <img src="https://avatars.githubusercontent.com/u/84106192?s=200&v=4" height="40px;" alt="Marcato Partners" />
      </a>
    </td>
    <td>
      <a href="https://interval.com">
        <img src="https://avatars.githubusercontent.com/u/67802063?s=200&v=4" height="40px;" alt="" />
      </a>
    </td>
    <td>
      <a href="https://seasoned.cc">
        <img src="https://avatars.githubusercontent.com/u/33913103?s=200&v=4" height="40px;" alt="" />
      </a>
    </td>
    <td>
      <a href="https://www.bamboocreative.nz/">
        <img src="https://avatars.githubusercontent.com/u/41406870?v=4" height="40px;" alt="Bamboo Creative logo" />
      </a>
    </td>
  </tr>
</table>
<div class="pilwrap" id="bronze">
  <h4>
    <a href="#bronze" name="bronze" class="pilcrow"></a>
Bronze
  </h4>
</div>
<table>
  <tr>
    <td>Brandon Bayer</td>
    <td>Jiří Brabec</td>
    <td>Alex Johansson</td>
    <td>Fungible Systems</td>
  </tr>
  <tr>
    <td>Adaptable</td>
    <td>Avana Wallet</td>
    <td>Jason Lengstorf</td>
    <td>Global Illumination, Inc.</td>
  </tr>
  <tr>
    <td>MasterBorn</td>
    <td>Ryan Palmer</td>
    <td>Michael Sweeney</td>
    <td>Nextbase</td>
  </tr>
  <tr>
    <td>Remotion</td>
    <td>Connor Sinnott</td>
    <td>Mohammad-Ali A'râbi</td>
    <td>Supatool</td>
  </tr>
  <tr>
    <td>Social Crow</td>
  </tr>
</table>
<div class="pilwrap" id="ecosystem">
  <h3>
    <a href="#ecosystem" name="ecosystem" class="pilcrow"></a>
Ecosystem
  </h3>
</div>
<p>There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it <a href="https://twitter.com/colinhacks">on Twitter</a> or <a href="https://github.com/colinhacks/zod/discussions">start a Discussion</a>. I'll add it below and tweet it out.</p>
<div class="pilwrap" id="resources">
  <h4>
    <a href="#resources" name="resources" class="pilcrow"></a>
Resources
  </h4>
</div>
<ul>
<li><a href="https://www.totaltypescript.com/tutorials/zod">Total TypeScript Zod Tutorial</a> by <a href="https://twitter.com/mattpocockuk">@mattpocockuk</a></li>
<li><a href="https://www.youtube.com/watch?v=rY_XqfSHock">Fixing TypeScript's Blindspot: Runtime Typechecking</a> by <a href="https://twitter.com/jherr">@jherr</a></li>
</ul>
<div class="pilwrap" id="api-libraries">
  <h4>
    <a href="#api-libraries" name="api-libraries" class="pilcrow"></a>
API libraries
  </h4>
</div>
<ul>
<li><a href="https://github.com/trpc/trpc"><code>tRPC</code></a>: Build end-to-end typesafe APIs without GraphQL.</li>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs"><code>@anatine/zod-nestjs</code></a>: Helper methods for using Zod in a NestJS project.</li>
<li><a href="https://github.com/flock-community/zod-endpoints"><code>zod-endpoints</code></a>: Contract-first strictly typed endpoints with Zod. OpenAPI compatible.</li>
<li><a href="https://github.com/evertdespiegeleer/zhttp"><code>zhttp</code></a>: An OpenAPI compatible, strictly typed http library with Zod input and response validation.</li>
<li><a href="https://github.com/SeasonedSoftware/domain-functions/"><code>domain-functions</code></a>: Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.</li>
<li><a href="https://github.com/ecyrbe/zodios"><code>@zodios/core</code></a>: A typescript API client with runtime and compile time validation backed by axios and zod.</li>
<li><a href="https://github.com/RobinTail/express-zod-api"><code>express-zod-api</code></a>: Build Express-based APIs with I/O schema validation and custom middlewares.</li>
<li><a href="https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md"><code>tapiduck</code></a>: End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.</li>
<li><a href="https://github.com/JakeFenley/koa-zod-router"><code>koa-zod-router</code></a>: Create typesafe routes in Koa with I/O validation using Zod.</li>
</ul>
<div class="pilwrap" id="form-integrations">
  <h4>
    <a href="#form-integrations" name="form-integrations" class="pilcrow"></a>
Form integrations
  </h4>
</div>
<ul>
<li><a href="https://github.com/react-hook-form/resolvers#zod"><code>react-hook-form</code></a>: A first-party Zod resolver for React Hook Form.</li>
<li><a href="https://github.com/causaly/zod-validation-error"><code>zod-validation-error</code></a>: Generate user-friendly error messages from <code>ZodError</code>s.</li>
<li><a href="https://github.com/robertLichtnow/zod-formik-adapter"><code>zod-formik-adapter</code></a>: A community-maintained Formik adapter for Zod.</li>
<li><a href="https://github.com/esamattis/react-zorm"><code>react-zorm</code></a>: Standalone <code>&lt;form&gt;</code> generation and validation for React using Zod.</li>
<li><a href="https://github.com/rileytomasek/zodix"><code>zodix</code></a>: Zod utilities for FormData and URLSearchParams in Remix loaders and actions.</li>
<li><a href="https://conform.guide/api/zod/parseWithZod"><code>conform</code></a>: A typesafe form validation library for progressive enhancement of HTML forms. Works with Remix and Next.js.</li>
<li><a href="https://github.com/kiliman/remix-params-helper"><code>remix-params-helper</code></a>: Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.</li>
<li><a href="https://github.com/glazy/formik-validator-zod"><code>formik-validator-zod</code></a>: Formik-compliant validator library that simplifies using Zod with Formik.</li>
<li><a href="https://github.com/aiji42/zod-i18n"><code>zod-i18n-map</code></a>: Useful for translating Zod error messages.</li>
<li><a href="https://github.com/fabian-hiller/modular-forms"><code>@modular-forms/solid</code></a>: Modular form library for SolidJS that supports Zod for validation.</li>
<li><a href="https://github.com/crutchcorn/houseform/"><code>houseform</code></a>: A React form library that uses Zod for validation.</li>
<li><a href="https://github.com/ciscoheat/sveltekit-superforms"><code>sveltekit-superforms</code></a>: Supercharged form library for SvelteKit with Zod validation.</li>
<li><a href="https://github.com/MonoidDev/mobx-zod-form"><code>mobx-zod-form</code></a>: Data-first form builder based on MobX &amp; Zod.</li>
<li><a href="https://github.com/logaretm/vee-validate/tree/main/packages/zod"><code>@vee-validate/zod</code></a>: Form library for Vue.js with Zod schema validation.</li>
</ul>
<div class="pilwrap" id="zod-to-x">
  <h4>
    <a href="#zod-to-x" name="zod-to-x" class="pilcrow"></a>
Zod to X
  </h4>
</div>
<ul>
<li><a href="https://github.com/sachinraja/zod-to-ts"><code>zod-to-ts</code></a>: Generate TypeScript definitions from Zod schemas.</li>
<li><a href="https://github.com/StefanTerdell/zod-to-json-schema"><code>zod-to-json-schema</code></a>: Convert your Zod schemas into <a href="https://json-schema.org/">JSON Schemas</a>.</li>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi"><code>@anatine/zod-openapi</code></a>: Converts a Zod schema to an OpenAPI v3.x <code>SchemaObject</code>.</li>
<li><a href="https://github.com/DavidTimms/zod-fast-check"><code>zod-fast-check</code></a>: Generate <code>fast-check</code> arbitraries from Zod schemas.</li>
<li><a href="https://github.com/kbkk/abitia/tree/master/packages/zod-dto"><code>zod-dto</code></a>: Generate Nest.js DTOs from a Zod schema.</li>
<li><a href="https://github.com/turkerdev/fastify-type-provider-zod"><code>fastify-type-provider-zod</code></a>: Create Fastify type providers from Zod schemas.</li>
<li><a href="https://github.com/asteasolutions/zod-to-openapi"><code>zod-to-openapi</code></a>: Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints &amp; parameters.</li>
<li><a href="https://github.com/incetarik/nestjs-graphql-zod"><code>nestjs-graphql-zod</code></a>: Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.</li>
<li><a href="https://github.com/samchungy/zod-openapi"><code>zod-openapi</code></a>: Create full OpenAPI v3.x documentation from Zod schemas.</li>
<li><a href="https://github.com/samchungy/fastify-zod-openapi"><code>fastify-zod-openapi</code></a>: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.</li>
<li><a href="https://typeschema.com/"><code>typeschema</code></a>: Universal adapter for schema validation.</li>
</ul>
<div class="pilwrap" id="x-to-zod">
  <h4>
    <a href="#x-to-zod" name="x-to-zod" class="pilcrow"></a>
X to Zod
  </h4>
</div>
<ul>
<li><a href="https://github.com/fabien0102/ts-to-zod"><code>ts-to-zod</code></a>: Convert TypeScript definitions into Zod schemas.</li>
<li><a href="https://github.com/johngeorgewright/runtyping/tree/master/packages/zod"><code>@runtyping/zod</code></a>: Generate Zod from static types &amp; JSON schema.</li>
<li><a href="https://github.com/StefanTerdell/json-schema-to-zod"><code>json-schema-to-zod</code></a>: Convert your <a href="https://json-schema.org/">JSON Schemas</a> into Zod schemas. <a href="https://StefanTerdell.github.io/json-schema-to-zod-react/">Live demo</a>.</li>
<li><a href="https://github.com/rsinohara/json-to-zod"><code>json-to-zod</code></a>: Convert JSON objects into Zod schemas. <a href="https://rsinohara.github.io/json-to-zod-react/">Live demo</a>.</li>
<li><a href="https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema"><code>graphql-codegen-typescript-validation-schema</code></a>: GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.</li>
<li><a href="https://github.com/CarterGrimmeisen/zod-prisma"><code>zod-prisma</code></a>: Generate Zod schemas from your Prisma schema.</li>
<li><a href="https://github.com/Southclaws/supervillain"><code>Supervillain</code></a>: Generate Zod schemas from your Go structs.</li>
<li><a href="https://github.com/omar-dulaimi/prisma-zod-generator"><code>prisma-zod-generator</code></a>: Emit Zod schemas from your Prisma schema.</li>
<li><a href="https://github.com/omar-dulaimi/prisma-trpc-generator"><code>prisma-trpc-generator</code></a>: Emit fully implemented tRPC routers and their validation schemas using Zod.</li>
<li><a href="https://github.com/chrishoermann/zod-prisma-types"><code>zod-prisma-types</code></a> Create Zod types from your Prisma models.</li>
<li><a href="https://app.quicktype.io/"><code>quicktype</code></a>: Convert JSON objects and JSON schemas into Zod schemas.</li>
<li><a href="https://github.com/saiichihashimoto/sanity-typed/tree/main/packages/zod"><code>@sanity-typed/zod</code></a>: Generate Zod Schemas from <a href="https://www.sanity.io/docs/schema-types">Sanity Schemas</a>.</li>
<li><a href="https://github.com/ivangreene/java-to-zod"><code>java-to-zod</code></a>: Convert POJOs to Zod schemas</li>
<li><a href="https://github.com/anymaniax/orval"><code>Orval</code></a>: Generate Zod schemas from OpenAPI schemas</li>
</ul>
<div class="pilwrap" id="mocking">
  <h4>
    <a href="#mocking" name="mocking" class="pilcrow"></a>
Mocking
  </h4>
</div>
<ul>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock"><code>@anatine/zod-mock</code></a>: Generate mock data from a Zod schema. Powered by <a href="https://github.com/faker-js/faker">faker.js</a>.</li>
<li><a href="https://github.com/dipasqualew/zod-mocking"><code>zod-mocking</code></a>: Generate mock data from your Zod schemas.</li>
<li><a href="https://github.com/timdeschryver/zod-fixture"><code>zod-fixture</code></a>: Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.</li>
<li><a href="https://zocker.sigrist.dev"><code>zocker</code></a>: Generate plausible mock-data from your schemas.</li>
<li><a href="https://github.com/ItMaga/zodock"><code>zodock</code></a> Generate mock data based on Zod schemas.</li>
</ul>
<div class="pilwrap" id="powered-by-zod">
  <h4>
    <a href="#powered-by-zod" name="powered-by-zod" class="pilcrow"></a>
Powered by Zod
  </h4>
</div>
<ul>
<li><a href="https://github.com/JacobWeisenburger/freerstore"><code>freerstore</code></a>: Firestore cost optimizer.</li>
<li><a href="https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference"><code>slonik</code></a>: Node.js Postgres client with strong Zod integration.</li>
<li><a href="https://github.com/mdbetancourt/soly"><code>soly</code></a>: Create CLI applications with zod.</li>
<li><a href="https://github.com/vadimdemedes/pastel"><code>pastel</code></a>: Create CLI applications with react, zod, and ink.</li>
<li><a href="https://github.com/sidwebworks/zod-xlsx"><code>zod-xlsx</code></a>: A xlsx based resource validator using Zod schemas.</li>
<li><a href="https://github.com/lostfictions/znv"><code>znv</code></a>: Type-safe environment parsing and validation for Node.js with Zod schemas.</li>
<li><a href="https://github.com/alexmarqs/zod-config"><code>zod-config</code></a>: Load configurations across multiple sources with flexible adapters, ensuring type safety with Zod.</li>
</ul>
<div class="pilwrap" id="utilities-for-zod">
  <h4>
    <a href="#utilities-for-zod" name="utilities-for-zod" class="pilcrow"></a>
Utilities for Zod
  </h4>
</div>
<ul>
<li><a href="https://github.com/JacobWeisenburger/zod_utilz"><code>zod_utilz</code></a>: Framework agnostic utilities for Zod.</li>
<li><a href="https://github.com/marilari88/zod-playground"><code>zod-playground</code></a>: A tool for learning and testing Zod schema validation functionalities. <a href="https://zod-playground.vercel.app/">Link</a>.</li>
<li><a href="https://github.com/nereumelo/zod-sandbox"><code>zod-sandbox</code></a>: Controlled environment for testing zod schemas. <a href="https://zod-sandbox.vercel.app/">Live demo</a>.</li>
<li><a href="https://github.com/schalkventer/zod-dev"><code>zod-dev</code></a>: Conditionally disables Zod runtime parsing in production.</li>
<li><a href="https://github.com/duplojs/duplojs-zod-accelerator"><code>zod-accelerator</code></a>: Accelerates Zod's throughput up to ~100x.</li>
</ul>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<div class="pilwrap" id="requirements">
  <h3>
    <a href="#requirements" name="requirements" class="pilcrow"></a>
Requirements
  </h3>
</div>
<ul>
<li>
<p>TypeScript 4.5+!</p>
</li>
<li>
<p>You must enable <code>strict</code> mode in your <code>tsconfig.json</code>. This is a best practice for all TypeScript projects.</p>
<pre><code class="ts"><span class="hljs-comment">// tsconfig.json</span>
{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-string">"compilerOptions"</span>: {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">"strict"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
</li>
</ul>
<div class="pilwrap" id="from-npm-nodebun">
  <h3>
    <a href="#from-npm-nodebun" name="from-npm-nodebun" class="pilcrow"></a>
From <code>npm</code> (Node/Bun)
  </h3>
</div>
<pre><code class="sh">npm install zod       <span class="hljs-comment"># npm</span>
yarn add zod          <span class="hljs-comment"># yarn</span>
bun add zod           <span class="hljs-comment"># bun</span>
pnpm add zod          <span class="hljs-comment"># pnpm</span>
</code></pre>
<p>Zod also publishes a canary version on every commit. To install the canary:</p>
<pre><code class="sh">npm install zod@canary       <span class="hljs-comment"># npm</span>
yarn add zod@canary          <span class="hljs-comment"># yarn</span>
bun add zod@canary           <span class="hljs-comment"># bun</span>
pnpm add zod@canary          <span class="hljs-comment"># pnpm</span>
</code></pre>
<div class="pilwrap" id="from-deno.landx-deno">
  <h3>
    <a href="#from-deno.landx-deno" name="from-deno.landx-deno" class="pilcrow"></a>
From <code>deno.land/x</code> (Deno)
  </h3>
</div>
<p>Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on <a href="https://deno.land/x">deno.land/x</a>. The latest version can be imported like so:</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"https://deno.land/x/zod/mod.ts"</span>;
</code></pre>
<p>You can also specify a particular version:</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"https://deno.land/x/zod@v3.16.1/mod.ts"</span>;
</code></pre>
<blockquote>
<p>The rest of this README assumes you are using npm and importing directly from the <code>&quot;zod&quot;</code> package.</p>
</blockquote>
<div class="pilwrap" id="basic-usage">
  <h2>
    <a href="#basic-usage" name="basic-usage" class="pilcrow"></a>
Basic usage
  </h2>
</div>
<p>Creating a simple string schema</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-comment">// creating a schema for strings</span>
<span class="hljs-keyword">const</span> mySchema = z.string();

<span class="hljs-comment">// parsing</span>
mySchema.parse(<span class="hljs-string">"tuna"</span>); <span class="hljs-comment">// =&gt; "tuna"</span>
mySchema.parse(<span class="hljs-number">12</span>); <span class="hljs-comment">// =&gt; throws ZodError</span>

<span class="hljs-comment">// "safe" parsing (doesn't throw error if validation fails)</span>
mySchema.safeParse(<span class="hljs-string">"tuna"</span>); <span class="hljs-comment">// =&gt; { success: true; data: "tuna" }</span>
mySchema.safeParse(<span class="hljs-number">12</span>); <span class="hljs-comment">// =&gt; { success: false; error: ZodError }</span>
</code></pre>
<p>Creating an object schema</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-keyword">const</span> User = z.object({
  username: z.string(),
});

User.parse({ username: <span class="hljs-string">"Ludwig"</span> });

<span class="hljs-comment">// extract the inferred type</span>
<span class="hljs-keyword">type</span> User = z.infer&lt;<span class="hljs-keyword">typeof</span> User&gt;;
<span class="hljs-comment">// { username: string }</span>
</code></pre>
<div class="pilwrap" id="primitives">
  <h2>
    <a href="#primitives" name="primitives" class="pilcrow"></a>
Primitives
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-comment">// primitive values</span>
z.string();
z.number();
z.bigint();
z.boolean();
z.date();
z.symbol();

<span class="hljs-comment">// empty types</span>
z.undefined();
z.null();
z.void(); <span class="hljs-comment">// accepts undefined</span>

<span class="hljs-comment">// catch-all types</span>
<span class="hljs-comment">// allows any value</span>
z.any();
z.unknown();

<span class="hljs-comment">// never type</span>
<span class="hljs-comment">// allows no values</span>
z.never();
</code></pre>
<div class="pilwrap" id="coercion-for-primitives">
  <h2>
    <a href="#coercion-for-primitives" name="coercion-for-primitives" class="pilcrow"></a>
Coercion for primitives
  </h2>
</div>
<p>Zod now provides a more convenient way to coerce primitive values.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z.coerce.string();
schema.parse(<span class="hljs-string">"tuna"</span>); <span class="hljs-comment">// =&gt; "tuna"</span>
schema.parse(<span class="hljs-number">12</span>); <span class="hljs-comment">// =&gt; "12"</span>
</code></pre>
<p>During the parsing step, the input is passed through the <code>String()</code> function, which is a JavaScript built-in for coercing data into strings.</p>
<pre><code class="ts">schema.parse(<span class="hljs-number">12</span>); <span class="hljs-comment">// =&gt; "12"</span>
schema.parse(<span class="hljs-literal">true</span>); <span class="hljs-comment">// =&gt; "true"</span>
schema.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; "undefined"</span>
schema.parse(<span class="hljs-literal">null</span>); <span class="hljs-comment">// =&gt; "null"</span>
</code></pre>
<p>The returned schema is a normal <code>ZodString</code> instance so you can use all string methods.</p>
<pre><code class="ts">z.coerce.string().email().min(<span class="hljs-number">5</span>);
</code></pre>
<p><strong>How coercion works</strong></p>
<p>All primitive types support coercion. Zod coerces all inputs using the built-in constructors: <code>String(input)</code>, <code>Number(input)</code>, <code>new Date(input)</code>, etc.</p>
<pre><code class="ts">z.coerce.string(); <span class="hljs-comment">// String(input)</span>
z.coerce.number(); <span class="hljs-comment">// Number(input)</span>
z.coerce.boolean(); <span class="hljs-comment">// Boolean(input)</span>
z.coerce.bigint(); <span class="hljs-comment">// BigInt(input)</span>
z.coerce.date(); <span class="hljs-comment">// new Date(input)</span>
</code></pre>
<p><strong>Note</strong> — Boolean coercion with <code>z.coerce.boolean()</code> may not work how you expect. Any <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy</a> value is coerced to <code>true</code>, and any <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a> value is coerced to <code>false</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z.coerce.boolean(); <span class="hljs-comment">// Boolean(input)</span>

schema.parse(<span class="hljs-string">"tuna"</span>); <span class="hljs-comment">// =&gt; true</span>
schema.parse(<span class="hljs-string">"true"</span>); <span class="hljs-comment">// =&gt; true</span>
schema.parse(<span class="hljs-string">"false"</span>); <span class="hljs-comment">// =&gt; true</span>
schema.parse(<span class="hljs-number">1</span>); <span class="hljs-comment">// =&gt; true</span>
schema.parse([]); <span class="hljs-comment">// =&gt; true</span>

schema.parse(<span class="hljs-number">0</span>); <span class="hljs-comment">// =&gt; false</span>
schema.parse(<span class="hljs-string">""</span>); <span class="hljs-comment">// =&gt; false</span>
schema.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; false</span>
schema.parse(<span class="hljs-literal">null</span>); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p>For more control over coercion logic, consider using <a href="#preprocess.html"><code>z.preprocess</code></a> or <a href="#pipe.html"><code>z.pipe()</code></a>.</p>
<div class="pilwrap" id="literals">
  <h2>
    <a href="#literals" name="literals" class="pilcrow"></a>
Literals
  </h2>
</div>
<p>Literal schemas represent a <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">literal type</a>, like <code>&quot;hello world&quot;</code> or <code>5</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> tuna = z.literal(<span class="hljs-string">"tuna"</span>);
<span class="hljs-keyword">const</span> twelve = z.literal(<span class="hljs-number">12</span>);
<span class="hljs-keyword">const</span> twobig = z.literal(<span class="hljs-number">2n</span>); <span class="hljs-comment">// bigint literal</span>
<span class="hljs-keyword">const</span> tru = z.literal(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> terrificSymbol = Symbol(<span class="hljs-string">"terrific"</span>);
<span class="hljs-keyword">const</span> terrific = z.literal(terrificSymbol);

<span class="hljs-comment">// retrieve literal value</span>
tuna.value; <span class="hljs-comment">// "tuna"</span>
</code></pre>
<blockquote>
<p>Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.</p>
</blockquote>
<div class="pilwrap" id="strings">
  <h2>
    <a href="#strings" name="strings" class="pilcrow"></a>
Strings
  </h2>
</div>
<p>Zod includes a handful of string-specific validations.</p>
<pre><code class="ts"><span class="hljs-comment">// validations</span>
z.string().max(<span class="hljs-number">5</span>);
z.string().min(<span class="hljs-number">5</span>);
z.string().length(<span class="hljs-number">5</span>);
z.string().email();
z.string().url();
z.string().emoji();
z.string().uuid();
z.string().nanoid();
z.string().cuid();
z.string().cuid2();
z.string().ulid();
z.string().regex(regex);
z.string().includes(<span class="hljs-built_in">string</span>);
z.string().startsWith(<span class="hljs-built_in">string</span>);
z.string().endsWith(<span class="hljs-built_in">string</span>);
z.string().datetime(); <span class="hljs-comment">// ISO 8601; by default only `Z` timezone allowed</span>
z.string().ip(); <span class="hljs-comment">// defaults to allow both IPv4 and IPv6</span>

<span class="hljs-comment">// transforms</span>
z.string().trim(); <span class="hljs-comment">// trim whitespace</span>
z.string().toLowerCase(); <span class="hljs-comment">// toLowerCase</span>
z.string().toUpperCase(); <span class="hljs-comment">// toUpperCase</span>

<span class="hljs-comment">// added in Zod 3.23</span>
z.string().date(); <span class="hljs-comment">// ISO date format (YYYY-MM-DD)</span>
z.string().time(); <span class="hljs-comment">// ISO time format (HH:mm:ss[.SSSSSS])</span>
z.string().duration(); <span class="hljs-comment">// ISO 8601 duration</span>
z.string().base64();
</code></pre>
<blockquote>
<p>Check out <a href="https://github.com/validatorjs/validator.js">validator.js</a> for a bunch of other useful string validation functions that can be used in conjunction with <a href="#refine.html">Refinements</a>.</p>
</blockquote>
<p>You can customize some common error messages when creating a string schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> name = z.string({
  required_error: <span class="hljs-string">"Name is required"</span>,
  invalid_type_error: <span class="hljs-string">"Name must be a string"</span>,
});
</code></pre>
<p>When using validation methods, you can pass in an additional argument to provide a custom error message.</p>
<pre><code class="ts">z.string().min(<span class="hljs-number">5</span>, { message: <span class="hljs-string">"Must be 5 or more characters long"</span> });
z.string().max(<span class="hljs-number">5</span>, { message: <span class="hljs-string">"Must be 5 or fewer characters long"</span> });
z.string().length(<span class="hljs-number">5</span>, { message: <span class="hljs-string">"Must be exactly 5 characters long"</span> });
z.string().email({ message: <span class="hljs-string">"Invalid email address"</span> });
z.string().url({ message: <span class="hljs-string">"Invalid url"</span> });
z.string().emoji({ message: <span class="hljs-string">"Contains non-emoji characters"</span> });
z.string().uuid({ message: <span class="hljs-string">"Invalid UUID"</span> });
z.string().includes(<span class="hljs-string">"tuna"</span>, { message: <span class="hljs-string">"Must include tuna"</span> });
z.string().startsWith(<span class="hljs-string">"https://"</span>, { message: <span class="hljs-string">"Must provide secure URL"</span> });
z.string().endsWith(<span class="hljs-string">".com"</span>, { message: <span class="hljs-string">"Only .com domains allowed"</span> });
z.string().datetime({ message: <span class="hljs-string">"Invalid datetime string! Must be UTC."</span> });
z.string().date({ message: <span class="hljs-string">"Invalid date string!"</span> });
z.string().time({ message: <span class="hljs-string">"Invalid time string!"</span> });
z.string().ip({ message: <span class="hljs-string">"Invalid IP address"</span> });
</code></pre>
<div class="pilwrap" id="datetimes">
  <h3>
    <a href="#datetimes" name="datetimes" class="pilcrow"></a>
Datetimes
  </h3>
</div>
<p>As you may have noticed, Zod string includes a few date/time related validations. These validations are regular expression based, so they are not as strict as a full date/time library. However, they are very convenient for validating user input.</p>
<p>The <code>z.string().datetime()</code> method enforces ISO 8601; default is no timezone offsets and arbitrary sub-second decimal precision.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> datetime = z.string().datetime();

datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00Z"</span>); <span class="hljs-comment">// pass</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123Z"</span>); <span class="hljs-comment">// pass</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123456Z"</span>); <span class="hljs-comment">// pass (arbitrary precision)</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00+02:00"</span>); <span class="hljs-comment">// fail (no offsets allowed)</span>
</code></pre>
<p>Timezone offsets can be allowed by setting the <code>offset</code> option to <code>true</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> datetime = z.string().datetime({ offset: <span class="hljs-literal">true</span> });

datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00+02:00"</span>); <span class="hljs-comment">// pass</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123+02:00"</span>); <span class="hljs-comment">// pass (millis optional)</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123+0200"</span>); <span class="hljs-comment">// pass (millis optional)</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123+02"</span>); <span class="hljs-comment">// pass (only offset hours)</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00Z"</span>); <span class="hljs-comment">// pass (Z still supported)</span>
</code></pre>
<p>You can additionally constrain the allowable <code>precision</code>. By default, arbitrary sub-second precision is supported (but optional).</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> datetime = z.string().datetime({ precision: <span class="hljs-number">3</span> });

datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123Z"</span>); <span class="hljs-comment">// pass</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00Z"</span>); <span class="hljs-comment">// fail</span>
datetime.parse(<span class="hljs-string">"2020-01-01T00:00:00.123456Z"</span>); <span class="hljs-comment">// fail</span>
</code></pre>
<div class="pilwrap" id="dates">
  <h3>
    <a href="#dates" name="dates" class="pilcrow"></a>
Dates
  </h3>
</div>
<blockquote>
<p>Added in Zod 3.23</p>
</blockquote>
<p>The <code>z.string().date()</code> method validates strings in the format <code>YYYY-MM-DD</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> date = z.string().date();

date.parse(<span class="hljs-string">"2020-01-01"</span>); <span class="hljs-comment">// pass</span>
date.parse(<span class="hljs-string">"2020-1-1"</span>); <span class="hljs-comment">// fail</span>
date.parse(<span class="hljs-string">"2020-01-32"</span>); <span class="hljs-comment">// fail</span>
</code></pre>
<div class="pilwrap" id="times">
  <h3>
    <a href="#times" name="times" class="pilcrow"></a>
Times
  </h3>
</div>
<blockquote>
<p>Added in Zod 3.23</p>
</blockquote>
<p>The <code>z.string().time()</code> method validates strings in the format <code>HH:MM:SS[.s+]</code>. The second can include arbitrary decimal precision. It does not allow timezone offsets of any kind.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> time = z.string().time();

time.parse(<span class="hljs-string">"00:00:00"</span>); <span class="hljs-comment">// pass</span>
time.parse(<span class="hljs-string">"09:52:31"</span>); <span class="hljs-comment">// pass</span>
time.parse(<span class="hljs-string">"23:59:59.9999999"</span>); <span class="hljs-comment">// pass (arbitrary precision)</span>

time.parse(<span class="hljs-string">"00:00:00.123Z"</span>); <span class="hljs-comment">// fail (no `Z` allowed)</span>
time.parse(<span class="hljs-string">"00:00:00.123+02:00"</span>); <span class="hljs-comment">// fail (no offsets allowed)</span>
</code></pre>
<p>You can set the <code>precision</code> option to constrain the allowable decimal precision.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> time = z.string().time({ precision: <span class="hljs-number">3</span> });

time.parse(<span class="hljs-string">"00:00:00.123"</span>); <span class="hljs-comment">// pass</span>
time.parse(<span class="hljs-string">"00:00:00.123456"</span>); <span class="hljs-comment">// fail</span>
time.parse(<span class="hljs-string">"00:00:00"</span>); <span class="hljs-comment">// fail</span>
</code></pre>
<div class="pilwrap" id="ip-addresses">
  <h3>
    <a href="#ip-addresses" name="ip-addresses" class="pilcrow"></a>
IP addresses
  </h3>
</div>
<p>The <code>z.string().ip()</code> method by default validate IPv4 and IPv6.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> ip = z.string().ip();

ip.parse(<span class="hljs-string">"192.168.1.1"</span>); <span class="hljs-comment">// pass</span>
ip.parse(<span class="hljs-string">"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"</span>); <span class="hljs-comment">// pass</span>
ip.parse(<span class="hljs-string">"84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1"</span>); <span class="hljs-comment">// pass</span>

ip.parse(<span class="hljs-string">"256.1.1.1"</span>); <span class="hljs-comment">// fail</span>
ip.parse(<span class="hljs-string">"84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003"</span>); <span class="hljs-comment">// fail</span>
</code></pre>
<p>You can additionally set the IP <code>version</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> ipv4 = z.string().ip({ version: <span class="hljs-string">"v4"</span> });
ipv4.parse(<span class="hljs-string">"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003"</span>); <span class="hljs-comment">// fail</span>

<span class="hljs-keyword">const</span> ipv6 = z.string().ip({ version: <span class="hljs-string">"v6"</span> });
ipv6.parse(<span class="hljs-string">"192.168.1.1"</span>); <span class="hljs-comment">// fail</span>
</code></pre>
<div class="pilwrap" id="numbers">
  <h2>
    <a href="#numbers" name="numbers" class="pilcrow"></a>
Numbers
  </h2>
</div>
<p>You can customize certain error messages when creating a number schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> age = z.number({
  required_error: <span class="hljs-string">"Age is required"</span>,
  invalid_type_error: <span class="hljs-string">"Age must be a number"</span>,
});
</code></pre>
<p>Zod includes a handful of number-specific validations.</p>
<pre><code class="ts">z.number().gt(<span class="hljs-number">5</span>);
z.number().gte(<span class="hljs-number">5</span>); <span class="hljs-comment">// alias .min(5)</span>
z.number().lt(<span class="hljs-number">5</span>);
z.number().lte(<span class="hljs-number">5</span>); <span class="hljs-comment">// alias .max(5)</span>

z.number().int(); <span class="hljs-comment">// value must be an integer</span>

z.number().positive(); <span class="hljs-comment">//     &gt; 0</span>
z.number().nonnegative(); <span class="hljs-comment">//  &gt;= 0</span>
z.number().negative(); <span class="hljs-comment">//     &lt; 0</span>
z.number().nonpositive(); <span class="hljs-comment">//  &lt;= 0</span>

z.number().multipleOf(<span class="hljs-number">5</span>); <span class="hljs-comment">// Evenly divisible by 5. Alias .step(5)</span>

z.number().finite(); <span class="hljs-comment">// value must be finite, not Infinity or -Infinity</span>
z.number().safe(); <span class="hljs-comment">// value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER</span>
</code></pre>
<p>Optionally, you can pass in a second argument to provide a custom error message.</p>
<pre><code class="ts">z.number().lte(<span class="hljs-number">5</span>, { message: <span class="hljs-string">"this👏is👏too👏big"</span> });
</code></pre>
<div class="pilwrap" id="bigints">
  <h2>
    <a href="#bigints" name="bigints" class="pilcrow"></a>
BigInts
  </h2>
</div>
<p>Zod includes a handful of bigint-specific validations.</p>
<pre><code class="ts">z.bigint().gt(<span class="hljs-number">5n</span>);
z.bigint().gte(<span class="hljs-number">5n</span>); <span class="hljs-comment">// alias `.min(5n)`</span>
z.bigint().lt(<span class="hljs-number">5n</span>);
z.bigint().lte(<span class="hljs-number">5n</span>); <span class="hljs-comment">// alias `.max(5n)`</span>

z.bigint().positive(); <span class="hljs-comment">// &gt; 0n</span>
z.bigint().nonnegative(); <span class="hljs-comment">// &gt;= 0n</span>
z.bigint().negative(); <span class="hljs-comment">// &lt; 0n</span>
z.bigint().nonpositive(); <span class="hljs-comment">// &lt;= 0n</span>

z.bigint().multipleOf(<span class="hljs-number">5n</span>); <span class="hljs-comment">// Evenly divisible by 5n.</span>
</code></pre>
<div class="pilwrap" id="nans">
  <h2>
    <a href="#nans" name="nans" class="pilcrow"></a>
NaNs
  </h2>
</div>
<p>You can customize certain error messages when creating a nan schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> <span class="hljs-built_in">isNaN</span> = z.nan({
  required_error: <span class="hljs-string">"isNaN is required"</span>,
  invalid_type_error: <span class="hljs-string">"isNaN must be 'not a number'"</span>,
});
</code></pre>
<div class="pilwrap" id="booleans">
  <h2>
    <a href="#booleans" name="booleans" class="pilcrow"></a>
Booleans
  </h2>
</div>
<p>You can customize certain error messages when creating a boolean schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> isActive = z.boolean({
  required_error: <span class="hljs-string">"isActive is required"</span>,
  invalid_type_error: <span class="hljs-string">"isActive must be a boolean"</span>,
});
</code></pre>
<div class="pilwrap" id="dates-1">
  <h2>
    <a href="#dates-1" name="dates-1" class="pilcrow"></a>
Dates
  </h2>
</div>
<p>Use z.date() to validate <code>Date</code> instances.</p>
<pre><code class="ts">z.date().safeParse(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// success: true</span>
z.date().safeParse(<span class="hljs-string">"2022-01-12T00:00:00.000Z"</span>); <span class="hljs-comment">// success: false</span>
</code></pre>
<p>You can customize certain error messages when creating a date schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> myDateSchema = z.date({
  required_error: <span class="hljs-string">"Please select a date and time"</span>,
  invalid_type_error: <span class="hljs-string">"That's not a date!"</span>,
});
</code></pre>
<p>Zod provides a handful of date-specific validations.</p>
<pre><code class="ts">z.date().min(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"1900-01-01"</span>), { message: <span class="hljs-string">"Too old"</span> });
z.date().max(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), { message: <span class="hljs-string">"Too young!"</span> });
</code></pre>
<p><strong>Coercion to Date</strong></p>
<p>Since <a href="https://github.com/colinhacks/zod/releases/tag/v3.20">zod 3.20</a>, use <a href="#coercion-for-primitives.html"><code>z.coerce.date()</code></a> to pass the input through <code>new Date(input)</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> dateSchema = z.coerce.date();
<span class="hljs-keyword">type</span> DateSchema = z.infer&lt;<span class="hljs-keyword">typeof</span> dateSchema&gt;;
<span class="hljs-comment">// type DateSchema = Date</span>

<span class="hljs-comment">/* valid dates */</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-string">"2023-01-10T00:00:00.000Z"</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-string">"2023-01-10"</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-string">"1/10/23"</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"1/10/23"</span>)).success); <span class="hljs-comment">// true</span>

<span class="hljs-comment">/* invalid dates */</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-string">"2023-13-10"</span>).success); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(dateSchema.safeParse(<span class="hljs-string">"0000-00-00"</span>).success); <span class="hljs-comment">// false</span>
</code></pre>
<p>For older zod versions, use <a href="#preprocess.html"><code>z.preprocess</code></a> like <a href="https://github.com/colinhacks/zod/discussions/879#discussioncomment-2036276">described in this thread</a>.</p>
<div class="pilwrap" id="zod-enums">
  <h2>
    <a href="#zod-enums" name="zod-enums" class="pilcrow"></a>
Zod enums
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> FishEnum = z.enum([<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Tuna"</span>, <span class="hljs-string">"Trout"</span>]);
<span class="hljs-keyword">type</span> FishEnum = z.infer&lt;<span class="hljs-keyword">typeof</span> FishEnum&gt;;
<span class="hljs-comment">// 'Salmon' | 'Tuna' | 'Trout'</span>
</code></pre>
<p><code>z.enum</code> is a Zod-native way to declare a schema with a fixed set of allowable <em>string</em> values. Pass the array of values directly into <code>z.enum()</code>. Alternatively, use <code>as const</code> to define your enum values as a tuple of strings. See the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">const assertion docs</a> for details.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> VALUES = [<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Tuna"</span>, <span class="hljs-string">"Trout"</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">const</span> FishEnum = z.enum(VALUES);
</code></pre>
<p>This is not allowed, since Zod isn't able to infer the exact values of each element.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> fish = [<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Tuna"</span>, <span class="hljs-string">"Trout"</span>];
<span class="hljs-keyword">const</span> FishEnum = z.enum(fish);
</code></pre>
<p><strong><code>.enum</code></strong></p>
<p>To get autocompletion with a Zod enum, use the <code>.enum</code> property of your schema:</p>
<pre><code class="ts">FishEnum.enum.Salmon; <span class="hljs-comment">// =&gt; autocompletes</span>

FishEnum.enum;
<span class="hljs-comment">/*
=&gt; {
  Salmon: "Salmon",
  Tuna: "Tuna",
  Trout: "Trout",
}
*/</span>
</code></pre>
<p>You can also retrieve the list of options as a tuple with the <code>.options</code> property:</p>
<pre><code class="ts">FishEnum.options; <span class="hljs-comment">// ["Salmon", "Tuna", "Trout"];</span>
</code></pre>
<p><strong><code>.exclude/.extract()</code></strong></p>
<p>You can create subsets of a Zod enum with the <code>.exclude</code> and <code>.extract</code> methods.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> FishEnum = z.enum([<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Tuna"</span>, <span class="hljs-string">"Trout"</span>]);
<span class="hljs-keyword">const</span> SalmonAndTrout = FishEnum.extract([<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Trout"</span>]);
<span class="hljs-keyword">const</span> TunaOnly = FishEnum.exclude([<span class="hljs-string">"Salmon"</span>, <span class="hljs-string">"Trout"</span>]);
</code></pre>
<div class="pilwrap" id="native-enums">
  <h2>
    <a href="#native-enums" name="native-enums" class="pilcrow"></a>
Native enums
  </h2>
</div>
<p>Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use <code>z.nativeEnum()</code>.</p>
<p><strong>Numeric enums</strong></p>
<pre><code class="ts"><span class="hljs-keyword">enum</span> Fruits {
  Apple,
  Banana,
}

<span class="hljs-keyword">const</span> FruitEnum = z.nativeEnum(Fruits);
<span class="hljs-keyword">type</span> FruitEnum = z.infer&lt;<span class="hljs-keyword">typeof</span> FruitEnum&gt;; <span class="hljs-comment">// Fruits</span>

FruitEnum.parse(Fruits.Apple); <span class="hljs-comment">// passes</span>
FruitEnum.parse(Fruits.Banana); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-number">0</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-number">1</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-number">3</span>); <span class="hljs-comment">// fails</span>
</code></pre>
<p><strong>String enums</strong></p>
<pre><code class="ts"><span class="hljs-keyword">enum</span> Fruits {
  Apple = <span class="hljs-string">"apple"</span>,
  Banana = <span class="hljs-string">"banana"</span>,
  Cantaloupe, <span class="hljs-comment">// you can mix numerical and string enums</span>
}

<span class="hljs-keyword">const</span> FruitEnum = z.nativeEnum(Fruits);
<span class="hljs-keyword">type</span> FruitEnum = z.infer&lt;<span class="hljs-keyword">typeof</span> FruitEnum&gt;; <span class="hljs-comment">// Fruits</span>

FruitEnum.parse(Fruits.Apple); <span class="hljs-comment">// passes</span>
FruitEnum.parse(Fruits.Cantaloupe); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-string">"apple"</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-number">0</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-string">"Cantaloupe"</span>); <span class="hljs-comment">// fails</span>
</code></pre>
<p><strong>Const enums</strong></p>
<p>The <code>.nativeEnum()</code> function works for <code>as const</code> objects as well. ⚠️ <code>as const</code> requires TypeScript 3.4+!</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Fruits = {
  Apple: <span class="hljs-string">"apple"</span>,
  Banana: <span class="hljs-string">"banana"</span>,
  Cantaloupe: <span class="hljs-number">3</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

<span class="hljs-keyword">const</span> FruitEnum = z.nativeEnum(Fruits);
<span class="hljs-keyword">type</span> FruitEnum = z.infer&lt;<span class="hljs-keyword">typeof</span> FruitEnum&gt;; <span class="hljs-comment">// "apple" | "banana" | 3</span>

FruitEnum.parse(<span class="hljs-string">"apple"</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-string">"banana"</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-number">3</span>); <span class="hljs-comment">// passes</span>
FruitEnum.parse(<span class="hljs-string">"Cantaloupe"</span>); <span class="hljs-comment">// fails</span>
</code></pre>
<p>You can access the underlying object with the <code>.enum</code> property:</p>
<pre><code class="ts">FruitEnum.enum.Apple; <span class="hljs-comment">// "apple"</span>
</code></pre>
<div class="pilwrap" id="optionals">
  <h2>
    <a href="#optionals" name="optionals" class="pilcrow"></a>
Optionals
  </h2>
</div>
<p>You can make any schema optional with <code>z.optional()</code>. This wraps the schema in a <code>ZodOptional</code> instance and returns the result.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z.optional(z.string());

schema.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; returns undefined</span>
<span class="hljs-keyword">type</span> A = z.infer&lt;<span class="hljs-keyword">typeof</span> schema&gt;; <span class="hljs-comment">// string | undefined</span>
</code></pre>
<p>For convenience, you can also call the <code>.optional()</code> method on an existing schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> user = z.object({
  username: z.string().optional(),
});
<span class="hljs-keyword">type</span> C = z.infer&lt;<span class="hljs-keyword">typeof</span> user&gt;; <span class="hljs-comment">// { username?: string | undefined };</span>
</code></pre>
<p>You can extract the wrapped schema from a <code>ZodOptional</code> instance with <code>.unwrap()</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringSchema = z.string();
<span class="hljs-keyword">const</span> optionalString = stringSchema.optional();
optionalString.unwrap() === stringSchema; <span class="hljs-comment">// true</span>
</code></pre>
<div class="pilwrap" id="nullables">
  <h2>
    <a href="#nullables" name="nullables" class="pilcrow"></a>
Nullables
  </h2>
</div>
<p>Similarly, you can create nullable types with <code>z.nullable()</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nullableString = z.nullable(z.string());
nullableString.parse(<span class="hljs-string">"asdf"</span>); <span class="hljs-comment">// =&gt; "asdf"</span>
nullableString.parse(<span class="hljs-literal">null</span>); <span class="hljs-comment">// =&gt; null</span>
</code></pre>
<p>Or use the <code>.nullable()</code> method.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> E = z.string().nullable(); <span class="hljs-comment">// equivalent to nullableString</span>
<span class="hljs-keyword">type</span> E = z.infer&lt;<span class="hljs-keyword">typeof</span> E&gt;; <span class="hljs-comment">// string | null</span>
</code></pre>
<p>Extract the inner schema with <code>.unwrap()</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringSchema = z.string();
<span class="hljs-keyword">const</span> nullableString = stringSchema.nullable();
nullableString.unwrap() === stringSchema; <span class="hljs-comment">// true</span>
</code></pre>
<div class="pilwrap" id="objects">
  <h2>
    <a href="#objects" name="objects" class="pilcrow"></a>
Objects
  </h2>
</div>
<pre><code class="ts"><span class="hljs-comment">// all properties are required by default</span>
<span class="hljs-keyword">const</span> Dog = z.object({
  name: z.string(),
  age: z.number(),
});

<span class="hljs-comment">// extract the inferred type like this</span>
<span class="hljs-keyword">type</span> Dog = z.infer&lt;<span class="hljs-keyword">typeof</span> Dog&gt;;

<span class="hljs-comment">// equivalent to:</span>
<span class="hljs-keyword">type</span> Dog = {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">number</span>;
};
</code></pre>
<div class="pilwrap" id=".shape">
  <h3>
    <a href="#.shape" name=".shape" class="pilcrow"></a>
<code>.shape</code>
  </h3>
</div>
<p>Use <code>.shape</code> to access the schemas for a particular key.</p>
<pre><code class="ts">Dog.shape.name; <span class="hljs-comment">// =&gt; string schema</span>
Dog.shape.age; <span class="hljs-comment">// =&gt; number schema</span>
</code></pre>
<div class="pilwrap" id=".keyof">
  <h3>
    <a href="#.keyof" name=".keyof" class="pilcrow"></a>
<code>.keyof</code>
  </h3>
</div>
<p>Use <code>.keyof</code> to create a <code>ZodEnum</code> schema from the keys of an object schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> keySchema = Dog.keyof();
keySchema; <span class="hljs-comment">// ZodEnum&lt;["name", "age"]&gt;</span>
</code></pre>
<div class="pilwrap" id=".extend">
  <h3>
    <a href="#.extend" name=".extend" class="pilcrow"></a>
<code>.extend</code>
  </h3>
</div>
<p>You can add additional fields to an object schema with the <code>.extend</code> method.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> DogWithBreed = Dog.extend({
  breed: z.string(),
});
</code></pre>
<p>You can use <code>.extend</code> to overwrite fields! Be careful with this power!</p>
<div class="pilwrap" id=".merge">
  <h3>
    <a href="#.merge" name=".merge" class="pilcrow"></a>
<code>.merge</code>
  </h3>
</div>
<p>Equivalent to <code>A.extend(B.shape)</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> BaseTeacher = z.object({ students: z.array(z.string()) });
<span class="hljs-keyword">const</span> HasID = z.object({ id: z.string() });

<span class="hljs-keyword">const</span> Teacher = BaseTeacher.merge(HasID);
<span class="hljs-keyword">type</span> Teacher = z.infer&lt;<span class="hljs-keyword">typeof</span> Teacher&gt;; <span class="hljs-comment">// =&gt; { students: string[], id: string }</span>
</code></pre>
<blockquote>
<p>If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the &quot;unknownKeys&quot; policy (strip/strict/passthrough) and the catchall schema of B.</p>
</blockquote>
<div class="pilwrap" id=".pick.omit">
  <h3>
    <a href="#.pick.omit" name=".pick.omit" class="pilcrow"></a>
<code>.pick/.omit</code>
  </h3>
</div>
<p>Inspired by TypeScript's built-in <code>Pick</code> and <code>Omit</code> utility types, all Zod object schemas have <code>.pick</code> and <code>.omit</code> methods that return a modified version. Consider this Recipe schema:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});
</code></pre>
<p>To only keep certain keys, use <code>.pick</code> .</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> JustTheName = Recipe.pick({ name: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">type</span> JustTheName = z.infer&lt;<span class="hljs-keyword">typeof</span> JustTheName&gt;;
<span class="hljs-comment">// =&gt; { name: string }</span>
</code></pre>
<p>To remove certain keys, use <code>.omit</code> .</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> NoIDRecipe = Recipe.omit({ id: <span class="hljs-literal">true</span> });

<span class="hljs-keyword">type</span> NoIDRecipe = z.infer&lt;<span class="hljs-keyword">typeof</span> NoIDRecipe&gt;;
<span class="hljs-comment">// =&gt; { name: string, ingredients: string[] }</span>
</code></pre>
<div class="pilwrap" id=".partial">
  <h3>
    <a href="#.partial" name=".partial" class="pilcrow"></a>
<code>.partial</code>
  </h3>
</div>
<p>Inspired by the built-in TypeScript utility type <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype">Partial</a>, the <code>.partial</code> method makes all properties optional.</p>
<p>Starting from this object:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> user = z.object({
  email: z.string(),
  username: z.string(),
});
<span class="hljs-comment">// { email: string; username: string }</span>
</code></pre>
<p>We can create a partial version:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> partialUser = user.partial();
<span class="hljs-comment">// { email?: string | undefined; username?: string | undefined }</span>
</code></pre>
<p>You can also specify which properties to make optional:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> optionalEmail = user.partial({
  email: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">/*
{
  email?: string | undefined;
  username: string
}
*/</span>
</code></pre>
<div class="pilwrap" id=".deeppartial">
  <h3>
    <a href="#.deeppartial" name=".deeppartial" class="pilcrow"></a>
<code>.deepPartial</code>
  </h3>
</div>
<p>The <code>.partial</code> method is shallow — it only applies one level deep. There is also a &quot;deep&quot; version:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> user = z.object({
  username: z.string(),
  location: z.object({
    latitude: z.number(),
    longitude: z.number(),
  }),
  strings: z.array(z.object({ value: z.string() })),
});

<span class="hljs-keyword">const</span> deepPartialUser = user.deepPartial();

<span class="hljs-comment">/*
{
  username?: string | undefined,
  location?: {
    latitude?: number | undefined;
    longitude?: number | undefined;
  } | undefined,
  strings?: { value?: string}[]
}
*/</span>
</code></pre>
<blockquote>
<p>Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.</p>
</blockquote>
<div class="pilwrap" id=".required">
  <h3>
    <a href="#.required" name=".required" class="pilcrow"></a>
<code>.required</code>
  </h3>
</div>
<p>Contrary to the <code>.partial</code> method, the <code>.required</code> method makes all properties required.</p>
<p>Starting from this object:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> user = z
  .object({
    email: z.string(),
    username: z.string(),
  })
  .partial();
<span class="hljs-comment">// { email?: string | undefined; username?: string | undefined }</span>
</code></pre>
<p>We can create a required version:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> requiredUser = user.required();
<span class="hljs-comment">// { email: string; username: string }</span>
</code></pre>
<p>You can also specify which properties to make required:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> requiredEmail = user.required({
  email: <span class="hljs-literal">true</span>,
});
<span class="hljs-comment">/*
{
  email: string;
  username?: string | undefined;
}
*/</span>
</code></pre>
<div class="pilwrap" id=".passthrough">
  <h3>
    <a href="#.passthrough" name=".passthrough" class="pilcrow"></a>
<code>.passthrough</code>
  </h3>
</div>
<p>By default Zod object schemas strip out unrecognized keys during parsing.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> person = z.object({
  name: z.string(),
});

person.parse({
  name: <span class="hljs-string">"bob dylan"</span>,
  extraKey: <span class="hljs-number">61</span>,
});
<span class="hljs-comment">// =&gt; { name: "bob dylan" }</span>
<span class="hljs-comment">// extraKey has been stripped</span>
</code></pre>
<p>Instead, if you want to pass through unknown keys, use <code>.passthrough()</code> .</p>
<pre><code class="ts">person.passthrough().parse({
  name: <span class="hljs-string">"bob dylan"</span>,
  extraKey: <span class="hljs-number">61</span>,
});
<span class="hljs-comment">// =&gt; { name: "bob dylan", extraKey: 61 }</span>
</code></pre>
<div class="pilwrap" id=".strict">
  <h3>
    <a href="#.strict" name=".strict" class="pilcrow"></a>
<code>.strict</code>
  </h3>
</div>
<p>By default Zod object schemas strip out unrecognized keys during parsing. You can <em>disallow</em> unknown keys with <code>.strict()</code> . If there are any unknown keys in the input, Zod will throw an error.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: <span class="hljs-string">"bob dylan"</span>,
  extraKey: <span class="hljs-number">61</span>,
});
<span class="hljs-comment">// =&gt; throws ZodError</span>
</code></pre>
<div class="pilwrap" id=".strip">
  <h3>
    <a href="#.strip" name=".strip" class="pilcrow"></a>
<code>.strip</code>
  </h3>
</div>
<p>You can use the <code>.strip</code> method to reset an object schema to the default behavior (stripping unrecognized keys).</p>
<div class="pilwrap" id=".catchall">
  <h3>
    <a href="#.catchall" name=".catchall" class="pilcrow"></a>
<code>.catchall</code>
  </h3>
</div>
<p>You can pass a &quot;catchall&quot; schema into an object schema. All unknown keys will be validated against it.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> person = z
  .object({
    name: z.string(),
  })
  .catchall(z.number());

person.parse({
  name: <span class="hljs-string">"bob dylan"</span>,
  validExtraKey: <span class="hljs-number">61</span>, <span class="hljs-comment">// works fine</span>
});

person.parse({
  name: <span class="hljs-string">"bob dylan"</span>,
  validExtraKey: <span class="hljs-literal">false</span>, <span class="hljs-comment">// fails</span>
});
<span class="hljs-comment">// =&gt; throws ZodError</span>
</code></pre>
<p>Using <code>.catchall()</code> obviates <code>.passthrough()</code> , <code>.strip()</code> , or <code>.strict()</code>. All keys are now considered &quot;known&quot;.</p>
<div class="pilwrap" id="arrays">
  <h2>
    <a href="#arrays" name="arrays" class="pilcrow"></a>
Arrays
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringArray = z.array(z.string());

<span class="hljs-comment">// equivalent</span>
<span class="hljs-keyword">const</span> stringArray = z.string().array();
</code></pre>
<p>Be careful with the <code>.array()</code> method. It returns a new <code>ZodArray</code> instance. This means the <em>order</em> in which you call methods matters. For instance:</p>
<pre><code class="ts">z.string().optional().array(); <span class="hljs-comment">// (string | undefined)[]</span>
z.string().array().optional(); <span class="hljs-comment">// string[] | undefined</span>
</code></pre>
<div class="pilwrap" id=".element">
  <h3>
    <a href="#.element" name=".element" class="pilcrow"></a>
<code>.element</code>
  </h3>
</div>
<p>Use <code>.element</code> to access the schema for an element of the array.</p>
<pre><code class="ts">stringArray.element; <span class="hljs-comment">// =&gt; string schema</span>
</code></pre>
<div class="pilwrap" id=".nonempty">
  <h3>
    <a href="#.nonempty" name=".nonempty" class="pilcrow"></a>
<code>.nonempty</code>
  </h3>
</div>
<p>If you want to ensure that an array contains at least one element, use <code>.nonempty()</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nonEmptyStrings = z.string().array().nonempty();
<span class="hljs-comment">// the inferred type is now</span>
<span class="hljs-comment">// [string, ...string[]]</span>

nonEmptyStrings.parse([]); <span class="hljs-comment">// throws: "Array cannot be empty"</span>
nonEmptyStrings.parse([<span class="hljs-string">"Ariana Grande"</span>]); <span class="hljs-comment">// passes</span>
</code></pre>
<p>You can optionally specify a custom error message:</p>
<pre><code class="ts"><span class="hljs-comment">// optional custom error message</span>
<span class="hljs-keyword">const</span> nonEmptyStrings = z.string().array().nonempty({
  message: <span class="hljs-string">"Can't be empty!"</span>,
});
</code></pre>
<div class="pilwrap" id=".min.max.length">
  <h3>
    <a href="#.min.max.length" name=".min.max.length" class="pilcrow"></a>
<code>.min/.max/.length</code>
  </h3>
</div>
<pre><code class="ts">z.string().array().min(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 or more items</span>
z.string().array().max(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 or fewer items</span>
z.string().array().length(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 items exactly</span>
</code></pre>
<p>Unlike <code>.nonempty()</code> these methods do not change the inferred type.</p>
<div class="pilwrap" id="tuples">
  <h2>
    <a href="#tuples" name="tuples" class="pilcrow"></a>
Tuples
  </h2>
</div>
<p>Unlike arrays, tuples have a fixed number of elements and each element can have a different type.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> athleteSchema = z.tuple([
  z.string(), <span class="hljs-comment">// name</span>
  z.number(), <span class="hljs-comment">// jersey number</span>
  z.object({
    pointsScored: z.number(),
  }), <span class="hljs-comment">// statistics</span>
]);

<span class="hljs-keyword">type</span> Athlete = z.infer&lt;<span class="hljs-keyword">typeof</span> athleteSchema&gt;;
<span class="hljs-comment">// type Athlete = [string, number, { pointsScored: number }]</span>
</code></pre>
<p>A variadic (&quot;rest&quot;) argument can be added with the <code>.rest</code> method.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> variadicTuple = z.tuple([z.string()]).rest(z.number());
<span class="hljs-keyword">const</span> result = variadicTuple.parse([<span class="hljs-string">"hello"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// =&gt; [string, ...number[]];</span>
</code></pre>
<div class="pilwrap" id="unions">
  <h2>
    <a href="#unions" name="unions" class="pilcrow"></a>
Unions
  </h2>
</div>
<p>Zod includes a built-in <code>z.union</code> method for composing &quot;OR&quot; types.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringOrNumber = z.union([z.string(), z.number()]);

stringOrNumber.parse(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// passes</span>
stringOrNumber.parse(<span class="hljs-number">14</span>); <span class="hljs-comment">// passes</span>
</code></pre>
<p>Zod will test the input against each of the &quot;options&quot; in order and return the first value that validates successfully.</p>
<p>For convenience, you can also use the <a href="#or.html"><code>.or</code> method</a>:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringOrNumber = z.string().or(z.number());
</code></pre>
<p><strong>Optional string validation:</strong></p>
<p>To validate an optional form input, you can union the desired string validation with an empty string <a href="#literals.html">literal</a>.</p>
<p>This example validates an input that is optional but needs to contain a <a href="#strings.html">valid URL</a>:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> optionalUrl = z.union([z.string().url().nullish(), z.literal(<span class="hljs-string">""</span>)]);

<span class="hljs-built_in">console</span>.log(optionalUrl.safeParse(<span class="hljs-literal">undefined</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(optionalUrl.safeParse(<span class="hljs-literal">null</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(optionalUrl.safeParse(<span class="hljs-string">""</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(optionalUrl.safeParse(<span class="hljs-string">"https://zod.dev"</span>).success); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(optionalUrl.safeParse(<span class="hljs-string">"not a valid url"</span>).success); <span class="hljs-comment">// false</span>
</code></pre>
<div class="pilwrap" id="discriminated-unions">
  <h2>
    <a href="#discriminated-unions" name="discriminated-unions" class="pilcrow"></a>
Discriminated unions
  </h2>
</div>
<p>A discriminated union is a union of object schemas that all share a particular key.</p>
<pre><code class="ts"><span class="hljs-keyword">type</span> MyUnion =
  | { status: <span class="hljs-string">"success"</span>; data: <span class="hljs-built_in">string</span> }
  | { status: <span class="hljs-string">"failed"</span>; error: <span class="hljs-built_in">Error</span> };
</code></pre>
<p>Such unions can be represented with the <code>z.discriminatedUnion</code> method. This enables faster evaluation, because Zod can check the <em>discriminator key</em> (<code>status</code> in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.</p>
<p>With the basic union method, the input is tested against each of the provided &quot;options&quot;, and in the case of invalidity, issues for all the &quot;options&quot; are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the &quot;options&quot;, testing against it, and showing only the issues related to this &quot;option&quot;.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> myUnion = z.discriminatedUnion(<span class="hljs-string">"status"</span>, [
  z.object({ status: z.literal(<span class="hljs-string">"success"</span>), data: z.string() }),
  z.object({ status: z.literal(<span class="hljs-string">"failed"</span>), error: z.instanceof(<span class="hljs-built_in">Error</span>) }),
]);

myUnion.parse({ status: <span class="hljs-string">"success"</span>, data: <span class="hljs-string">"yippie ki yay"</span> });
</code></pre>
<p>You can extract a reference to the array of schemas with the <code>.options</code> property.</p>
<pre><code class="ts">myUnion.options; <span class="hljs-comment">// [ZodObject&lt;...&gt;, ZodObject&lt;...&gt;]</span>
</code></pre>
<p>To merge two or more discriminated unions, use <code>.options</code> with destructuring.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> A = z.discriminatedUnion(<span class="hljs-string">"status"</span>, [
  <span class="hljs-comment">/* options */</span>
]);
<span class="hljs-keyword">const</span> B = z.discriminatedUnion(<span class="hljs-string">"status"</span>, [
  <span class="hljs-comment">/* options */</span>
]);

<span class="hljs-keyword">const</span> AB = z.discriminatedUnion(<span class="hljs-string">"status"</span>, [...A.options, ...B.options]);
</code></pre>
<div class="pilwrap" id="records">
  <h2>
    <a href="#records" name="records" class="pilcrow"></a>
Records
  </h2>
</div>
<p>Record schemas are used to validate types such as <code>Record&lt;string, number&gt;</code>. This is particularly useful for storing or caching items by ID.</p>
<!-- If you want to validate the _values_ of an object against some schema but don't care about the keys, use `z.record(valueType)`:

```ts
const NumberCache = z.record(z.number());

type NumberCache = z.infer<typeof NumberCache>;
// => { [k: string]: number }
``` -->
<pre><code class="ts"><span class="hljs-keyword">const</span> User = z.object({ name: z.string() });

<span class="hljs-keyword">const</span> UserStore = z.record(z.string(), User);
<span class="hljs-keyword">type</span> UserStore = z.infer&lt;<span class="hljs-keyword">typeof</span> UserStore&gt;;
<span class="hljs-comment">// =&gt; Record&lt;string, { name: string }&gt;</span>
</code></pre>
<p>The schema and inferred type can be used like so:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> userStore: UserStore = {};

userStore[<span class="hljs-string">"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"</span>] = {
  name: <span class="hljs-string">"Carlotta"</span>,
}; <span class="hljs-comment">// passes</span>

userStore[<span class="hljs-string">"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"</span>] = {
  whatever: <span class="hljs-string">"Ice cream sundae"</span>,
}; <span class="hljs-comment">// TypeError</span>
</code></pre>
<p><strong>A note on numerical keys</strong></p>
<p>While <code>z.record(keyType, valueType)</code> is able to accept numerical key types and TypeScript's built-in Record type is <code>Record&lt;KeyType, ValueType&gt;</code>, it's hard to represent the TypeScript type <code>Record&lt;number, any&gt;</code> in Zod.</p>
<p>As it turns out, TypeScript's behavior surrounding <code>[k: number]</code> is a little unintuitive:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> testMap: { [k: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span> } = {
  <span class="hljs-number">1</span>: <span class="hljs-string">"one"</span>,
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> testMap) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${<span class="hljs-keyword">typeof</span> key}</span>`</span>);
}
<span class="hljs-comment">// prints: `1: string`</span>
</code></pre>
<p>As you can see, JavaScript automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.</p>
<div class="pilwrap" id="maps">
  <h2>
    <a href="#maps" name="maps" class="pilcrow"></a>
Maps
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringNumberMap = z.map(z.string(), z.number());

<span class="hljs-keyword">type</span> StringNumberMap = z.infer&lt;<span class="hljs-keyword">typeof</span> stringNumberMap&gt;;
<span class="hljs-comment">// type StringNumberMap = Map&lt;string, number&gt;</span>
</code></pre>
<div class="pilwrap" id="sets">
  <h2>
    <a href="#sets" name="sets" class="pilcrow"></a>
Sets
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberSet = z.set(z.number());
<span class="hljs-keyword">type</span> NumberSet = z.infer&lt;<span class="hljs-keyword">typeof</span> numberSet&gt;;
<span class="hljs-comment">// type NumberSet = Set&lt;number&gt;</span>
</code></pre>
<p>Set schemas can be further constrained with the following utility methods.</p>
<pre><code class="ts">z.set(z.string()).nonempty(); <span class="hljs-comment">// must contain at least one item</span>
z.set(z.string()).min(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 or more items</span>
z.set(z.string()).max(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 or fewer items</span>
z.set(z.string()).size(<span class="hljs-number">5</span>); <span class="hljs-comment">// must contain 5 items exactly</span>
</code></pre>
<div class="pilwrap" id="intersections">
  <h2>
    <a href="#intersections" name="intersections" class="pilcrow"></a>
Intersections
  </h2>
</div>
<p>Intersections are useful for creating &quot;logical AND&quot; types. This is useful for intersecting two object types.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Person = z.object({
  name: z.string(),
});

<span class="hljs-keyword">const</span> Employee = z.object({
  role: z.string(),
});

<span class="hljs-keyword">const</span> EmployedPerson = z.intersection(Person, Employee);

<span class="hljs-comment">// equivalent to:</span>
<span class="hljs-keyword">const</span> EmployedPerson = Person.and(Employee);
</code></pre>
<p>Though in many cases, it is recommended to use <code>A.merge(B)</code> to merge two objects. The <code>.merge</code> method returns a new <code>ZodObject</code> instance, whereas <code>A.and(B)</code> returns a less useful <code>ZodIntersection</code> instance that lacks common object methods like <code>pick</code> and <code>omit</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> a = z.union([z.number(), z.string()]);
<span class="hljs-keyword">const</span> b = z.union([z.number(), z.boolean()]);
<span class="hljs-keyword">const</span> c = z.intersection(a, b);

<span class="hljs-keyword">type</span> c = z.infer&lt;<span class="hljs-keyword">typeof</span> c&gt;; <span class="hljs-comment">// =&gt; number</span>
</code></pre>
<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->
<!--

``` ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);

type Teacher = z.infer<typeof Teacher>;
// { id:string; name:string };
```  -->
<div class="pilwrap" id="recursive-types">
  <h2>
    <a href="#recursive-types" name="recursive-types" class="pilcrow"></a>
Recursive types
  </h2>
</div>
<p>You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a &quot;type hint&quot;.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> baseCategorySchema = z.object({
  name: z.string(),
});

<span class="hljs-keyword">type</span> Category = z.infer&lt;<span class="hljs-keyword">typeof</span> baseCategorySchema&gt; &amp; {
  subcategories: Category[];
};

<span class="hljs-keyword">const</span> categorySchema: z.ZodType&lt;Category&gt; = baseCategorySchema.extend({
  subcategories: z.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> categorySchema.array()),
});

categorySchema.parse({
  name: <span class="hljs-string">"People"</span>,
  subcategories: [
    {
      name: <span class="hljs-string">"Politicians"</span>,
      subcategories: [
        {
          name: <span class="hljs-string">"Presidents"</span>,
          subcategories: [],
        },
      ],
    },
  ],
}); <span class="hljs-comment">// passes</span>
</code></pre>
<p>Thanks to <a href="https://github.com/crasite">crasite</a> for this example.</p>
<div class="pilwrap" id="zodtype-with-zodeffects">
  <h3>
    <a href="#zodtype-with-zodeffects" name="zodtype-with-zodeffects" class="pilcrow"></a>
ZodType with ZodEffects
  </h3>
</div>
<p>When using <code>z.ZodType</code> with <code>z.ZodEffects</code> (
<a href="https://github.com/colinhacks/zod#refine"><code>.refine</code></a>,
<a href="https://github.com/colinhacks/zod#transform"><code>.transform</code></a>,
<a href="https://github.com/colinhacks/zod#preprocess"><code>preprocess</code></a>,
etc...
), you will need to define the input and output types of the schema. <code>z.ZodType&lt;Output, z.ZodTypeDef, Input&gt;</code></p>
<pre><code class="ts"><span class="hljs-keyword">const</span> isValidId = (id: <span class="hljs-built_in">string</span>): id is <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>/<span class="hljs-subst">${<span class="hljs-built_in">string</span>}</span>`</span> =&gt;
  id.split(<span class="hljs-string">"/"</span>).length === <span class="hljs-number">2</span>;

<span class="hljs-keyword">const</span> baseSchema = z.object({
  id: z.string().refine(isValidId),
});

<span class="hljs-keyword">type</span> Input = z.input&lt;<span class="hljs-keyword">typeof</span> baseSchema&gt; &amp; {
  children: Input[];
};

<span class="hljs-keyword">type</span> Output = z.output&lt;<span class="hljs-keyword">typeof</span> baseSchema&gt; &amp; {
  children: Output[];
};

<span class="hljs-keyword">const</span> schema: z.ZodType&lt;Output, z.ZodTypeDef, Input&gt; = baseSchema.extend({
  children: z.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> schema.array()),
});
</code></pre>
<p>Thanks to <a href="https://github.com/marcus13371337">marcus13371337</a> and <a href="https://github.com/JoelBeeldi">JoelBeeldi</a> for this example.</p>
<div class="pilwrap" id="json-type">
  <h3>
    <a href="#json-type" name="json-type" class="pilcrow"></a>
JSON type
  </h3>
</div>
<p>If you want to validate any JSON value, you can use the snippet below.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
<span class="hljs-keyword">type</span> Literal = z.infer&lt;<span class="hljs-keyword">typeof</span> literalSchema&gt;;
<span class="hljs-keyword">type</span> Json = Literal | { [key: <span class="hljs-built_in">string</span>]: Json } | Json[];
<span class="hljs-keyword">const</span> jsonSchema: z.ZodType&lt;Json&gt; = z.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);

jsonSchema.parse(data);
</code></pre>
<p>Thanks to <a href="https://github.com/ggoodman">ggoodman</a> for suggesting this.</p>
<div class="pilwrap" id="cyclical-objects">
  <h3>
    <a href="#cyclical-objects" name="cyclical-objects" class="pilcrow"></a>
Cyclical objects
  </h3>
</div>
<p>Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop in some cases.</p>
<blockquote>
<p>To detect cyclical objects before they cause problems, consider <a href="https://gist.github.com/colinhacks/d35825e505e635df27cc950776c5500b">this approach</a>.</p>
</blockquote>
<div class="pilwrap" id="promises">
  <h2>
    <a href="#promises" name="promises" class="pilcrow"></a>
Promises
  </h2>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberPromise = z.promise(z.number());
</code></pre>
<p>&quot;Parsing&quot; works a little differently with promise schemas. Validation happens in two parts:</p>
<ol>
<li>Zod synchronously checks that the input is an instance of Promise (i.e. an object with <code>.then</code> and <code>.catch</code> methods.).</li>
<li>Zod uses <code>.then</code> to attach an additional validation step onto the existing Promise. You'll have to use <code>.catch</code> on the returned Promise to handle validation failures.</li>
</ol>
<pre><code class="ts">numberPromise.parse(<span class="hljs-string">"tuna"</span>);
<span class="hljs-comment">// ZodError: Non-Promise type: string</span>

numberPromise.parse(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">"tuna"</span>));
<span class="hljs-comment">// =&gt; Promise&lt;number&gt;</span>

<span class="hljs-keyword">const</span> test = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> numberPromise.parse(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">"tuna"</span>));
  <span class="hljs-comment">// ZodError: Non-number type: string</span>

  <span class="hljs-keyword">await</span> numberPromise.parse(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3.14</span>));
  <span class="hljs-comment">// =&gt; 3.14</span>
};
</code></pre>
<!-- #### Non-native promise implementations

When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->
<div class="pilwrap" id="instanceof">
  <h2>
    <a href="#instanceof" name="instanceof" class="pilcrow"></a>
Instanceof
  </h2>
</div>
<p>You can use <code>z.instanceof</code> to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.</p>
<pre><code class="ts"><span class="hljs-keyword">class</span> Test {
  name: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> TestSchema = z.instanceof(Test);

<span class="hljs-keyword">const</span> blob: <span class="hljs-built_in">any</span> = <span class="hljs-string">"whatever"</span>;
TestSchema.parse(<span class="hljs-keyword">new</span> Test()); <span class="hljs-comment">// passes</span>
TestSchema.parse(blob); <span class="hljs-comment">// throws</span>
</code></pre>
<div class="pilwrap" id="functions">
  <h2>
    <a href="#functions" name="functions" class="pilcrow"></a>
Functions
  </h2>
</div>
<p>Zod also lets you define &quot;function schemas&quot;. This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and &quot;business logic&quot;.</p>
<p>You can create a function schema with <code>z.function(args, returnType)</code> .</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> myFunction = z<span class="hljs-function">.<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>;

<span class="hljs-keyword">type</span> myFunction = z.infer&lt;<span class="hljs-keyword">typeof</span> myFunction&gt;;
<span class="hljs-comment">// =&gt; ()=&gt;unknown</span>
</code></pre>
<p>Define inputs and outputs.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> myFunction = z
  <span class="hljs-function">.<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
  .<span class="hljs-title">args</span>(<span class="hljs-params">z.<span class="hljs-built_in">string</span>(), z.<span class="hljs-built_in">number</span>()</span>) // <span class="hljs-title">accepts</span> <span class="hljs-title">an</span> <span class="hljs-title">arbitrary</span> <span class="hljs-title">number</span> <span class="hljs-title">of</span> <span class="hljs-title">arguments</span>
  .<span class="hljs-title">returns</span>(<span class="hljs-params">z.<span class="hljs-built_in">boolean</span>()</span>)</span>;

<span class="hljs-keyword">type</span> myFunction = z.infer&lt;<span class="hljs-keyword">typeof</span> myFunction&gt;;
<span class="hljs-comment">// =&gt; (arg0: string, arg1: number)=&gt;boolean</span>
</code></pre>
<!--

``` ts
const args = z.tuple([z.string()]);

const returnType = z.number();

const myFunction = z.function(args, returnType);
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string)=>number
``` -->
<p>Function schemas have an <code>.implement()</code> method which accepts a function and returns a new function that automatically validates its inputs and outputs.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> trimmedLength = z
  <span class="hljs-function">.<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
  .<span class="hljs-title">args</span>(<span class="hljs-params">z.<span class="hljs-built_in">string</span>()</span>) // <span class="hljs-title">accepts</span> <span class="hljs-title">an</span> <span class="hljs-title">arbitrary</span> <span class="hljs-title">number</span> <span class="hljs-title">of</span> <span class="hljs-title">arguments</span>
  .<span class="hljs-title">returns</span>(<span class="hljs-params">z.<span class="hljs-built_in">number</span>()</span>)
  .<span class="hljs-title">implement</span>(<span class="hljs-params">(x) =&gt; {
    <span class="hljs-comment">// TypeScript knows x is a string!</span>
    <span class="hljs-keyword">return</span> x.trim().length;
  }</span>)</span>;

trimmedLength(<span class="hljs-string">"sandwich"</span>); <span class="hljs-comment">// =&gt; 8</span>
trimmedLength(<span class="hljs-string">" asdf "</span>); <span class="hljs-comment">// =&gt; 4</span>
</code></pre>
<p>If you only care about validating inputs, just don't call the <code>.returns()</code> method. The output type will be inferred from the implementation.</p>
<blockquote>
<p>You can use the special <code>z.void()</code> option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)</p>
</blockquote>
<pre><code class="ts"><span class="hljs-keyword">const</span> myFunction = z
  <span class="hljs-function">.<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)
  .<span class="hljs-title">args</span>(<span class="hljs-params">z.<span class="hljs-built_in">string</span>()</span>)
  .<span class="hljs-title">implement</span>(<span class="hljs-params">(arg) =&gt; {
    <span class="hljs-keyword">return</span> [arg.length];
  }</span>)</span>;

myFunction; <span class="hljs-comment">// (arg: string)=&gt;number[]</span>
</code></pre>
<p>Extract the input and output schemas from a function schema.</p>
<pre><code class="ts">myFunction.parameters();
<span class="hljs-comment">// =&gt; ZodTuple&lt;[ZodString, ZodNumber]&gt;</span>

myFunction.returnType();
<span class="hljs-comment">// =&gt; ZodBoolean</span>
</code></pre>
<!-- `z.function()` accepts two arguments:

* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).
* `returnType: any Zod schema` The second argument is the function's return type. This can be any Zod schema. -->
<div class="pilwrap" id="preprocess">
  <h2>
    <a href="#preprocess" name="preprocess" class="pilcrow"></a>
Preprocess
  </h2>
</div>
<blockquote>
<p>Zod now supports primitive coercion without the need for <code>.preprocess()</code>. See the <a href="#coercion-for-primitives.html">coercion docs</a> for more information.</p>
</blockquote>
<p>Typically Zod operates under a &quot;parse then transform&quot; paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the <a href="#transform.html">.transform docs</a>.)</p>
<p>But sometimes you want to apply some transform to the input <em>before</em> parsing happens. A common use case: type coercion. Zod enables this with the <code>z.preprocess()</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> castToString = z.preprocess(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-built_in">String</span>(val), z.string());
</code></pre>
<p>This returns a <code>ZodEffects</code> instance. <code>ZodEffects</code> is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.</p>
<div class="pilwrap" id="custom-schemas">
  <h2>
    <a href="#custom-schemas" name="custom-schemas" class="pilcrow"></a>
Custom schemas
  </h2>
</div>
<p>You can create a Zod schema for any TypeScript type by using <code>z.custom()</code>. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> px = z.custom&lt;<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">number</span>}</span>px`</span>&gt;<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">val</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === "<span class="hljs-built_in">string</span>" ? /^\d+px$/.test(<span class="hljs-params">val</span>) : <span class="hljs-literal">false</span>;
}</span>);

<span class="hljs-params">type</span> <span class="hljs-params">px</span> = <span class="hljs-params">z</span>.<span class="hljs-params">infer</span>&lt;<span class="hljs-params">typeof</span> <span class="hljs-params">px</span>&gt;; // `${<span class="hljs-params">number</span>}<span class="hljs-params">px</span>`

<span class="hljs-params">px</span>.<span class="hljs-params">parse</span>(<span class="hljs-params">"42px"</span>); // "42<span class="hljs-params">px</span>"
<span class="hljs-params">px</span>.<span class="hljs-params">parse</span>(<span class="hljs-params">"42vw"</span>); // <span class="hljs-params">throws</span>;
</span></code></pre>
<p>If you don't provide a validation function, Zod will allow any value. This can be dangerous!</p>
<pre><code class="ts">z.custom&lt;{ arg: <span class="hljs-built_in">string</span> }&gt;(); <span class="hljs-comment">// performs no validation</span>
</code></pre>
<p>You can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of <a href="#refine.html"><code>.refine</code></a>.</p>
<pre><code class="ts">z.custom&lt;...&gt;<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">val</span>) =&gt; ..., "custom error message"</span>);
</span></code></pre>
<div class="pilwrap" id="schema-methods">
  <h2>
    <a href="#schema-methods" name="schema-methods" class="pilcrow"></a>
Schema methods
  </h2>
</div>
<p>All Zod schemas contain certain methods.</p>
<div class="pilwrap" id=".parse">
  <h3>
    <a href="#.parse" name=".parse" class="pilcrow"></a>
<code>.parse</code>
  </h3>
</div>
<p><code>.parse(data: unknown): T</code></p>
<p>Given any Zod schema, you can call its <code>.parse</code> method to check <code>data</code> is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.</p>
<blockquote>
<p>IMPORTANT: The value returned by <code>.parse</code> is a <em>deep clone</em> of the variable you passed in.</p>
</blockquote>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringSchema = z.string();

stringSchema.parse(<span class="hljs-string">"fish"</span>); <span class="hljs-comment">// =&gt; returns "fish"</span>
stringSchema.parse(<span class="hljs-number">12</span>); <span class="hljs-comment">// throws error</span>
</code></pre>
<div class="pilwrap" id=".parseasync">
  <h3>
    <a href="#.parseasync" name=".parseasync" class="pilcrow"></a>
<code>.parseAsync</code>
  </h3>
</div>
<p><code>.parseAsync(data:unknown): Promise&lt;T&gt;</code></p>
<p>If you use asynchronous <a href="#refine.html">refinements</a> or <a href="#transform.html">transforms</a> (more on those later), you'll need to use <code>.parseAsync</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringSchema = z.string().refine(<span class="hljs-keyword">async</span> (val) =&gt; val.length &lt;= <span class="hljs-number">8</span>);

<span class="hljs-keyword">await</span> stringSchema.parseAsync(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// =&gt; returns "hello"</span>
<span class="hljs-keyword">await</span> stringSchema.parseAsync(<span class="hljs-string">"hello world"</span>); <span class="hljs-comment">// =&gt; throws error</span>
</code></pre>
<div class="pilwrap" id=".safeparse">
  <h3>
    <a href="#.safeparse" name=".safeparse" class="pilcrow"></a>
<code>.safeParse</code>
  </h3>
</div>
<p><code>.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }</code></p>
<p>If you don't want Zod to throw errors when validation fails, use <code>.safeParse</code>. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.</p>
<pre><code class="ts">stringSchema.safeParse(<span class="hljs-number">12</span>);
<span class="hljs-comment">// =&gt; { success: false; error: ZodError }</span>

stringSchema.safeParse(<span class="hljs-string">"billie"</span>);
<span class="hljs-comment">// =&gt; { success: true; data: 'billie' }</span>
</code></pre>
<p>The result is a <em>discriminated union</em>, so you can handle errors very conveniently:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> result = stringSchema.safeParse(<span class="hljs-string">"billie"</span>);
<span class="hljs-keyword">if</span> (!result.success) {
  <span class="hljs-comment">// handle error then return</span>
  result.error;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// do something</span>
  result.data;
}
</code></pre>
<div class="pilwrap" id=".safeparseasync">
  <h3>
    <a href="#.safeparseasync" name=".safeparseasync" class="pilcrow"></a>
<code>.safeParseAsync</code>
  </h3>
</div>
<blockquote>
<p>Alias: <code>.spa</code></p>
</blockquote>
<p>An asynchronous version of <code>safeParse</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">await</span> stringSchema.safeParseAsync(<span class="hljs-string">"billie"</span>);
</code></pre>
<p>For convenience, this has been aliased to <code>.spa</code>:</p>
<pre><code class="ts"><span class="hljs-keyword">await</span> stringSchema.spa(<span class="hljs-string">"billie"</span>);
</code></pre>
<div class="pilwrap" id=".refine">
  <h3>
    <a href="#.refine" name=".refine" class="pilcrow"></a>
<code>.refine</code>
  </h3>
</div>
<p><code>.refine(validator: (data:T)=&gt;any, params?: RefineParams)</code></p>
<p>Zod lets you provide custom validation logic via <em>refinements</em>. (For advanced features like creating multiple issues and customizing error codes, see <a href="#superrefine.html"><code>.superRefine</code></a>.)</p>
<p>Zod was designed to mirror TypeScript as closely as possible. But there are many so-called &quot;refinement types&quot; you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.</p>
<p>For example, you can define a custom validation check on <em>any</em> Zod schema with <code>.refine</code> :</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> myString = z.string().refine(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length &lt;= <span class="hljs-number">255</span>, {
  message: <span class="hljs-string">"String can't be more than 255 characters"</span>,
});
</code></pre>
<blockquote>
<p>⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.</p>
</blockquote>
<div class="pilwrap" id="arguments">
  <h4>
    <a href="#arguments" name="arguments" class="pilcrow"></a>
Arguments
  </h4>
</div>
<p>As you can see, <code>.refine</code> takes two arguments.</p>
<ol>
<li>The first is the validation function. This function takes one input (of type <code>T</code> — the inferred type of the schema) and returns <code>any</code>. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)</li>
<li>The second argument accepts some options. You can use this to customize certain error-handling behavior:</li>
</ol>
<pre><code class="ts"><span class="hljs-keyword">type</span> RefineParams = {
  <span class="hljs-comment">// override error message</span>
  message?: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// appended to error path</span>
  path?: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[];

  <span class="hljs-comment">// params object you can use to customize message</span>
  <span class="hljs-comment">// in error map</span>
  params?: object;
};
</code></pre>
<p>For advanced cases, the second argument can also be a function that returns <code>RefineParams</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> longString = z.string().refine(
  <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length &gt; <span class="hljs-number">10</span>,
  <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> ({ message: <span class="hljs-string">`<span class="hljs-subst">${val}</span> is not more than 10 characters`</span> })
);
</code></pre>
<div class="pilwrap" id="customize-error-path">
  <h4>
    <a href="#customize-error-path" name="customize-error-path" class="pilcrow"></a>
Customize error path
  </h4>
</div>
<pre><code class="ts"><span class="hljs-keyword">const</span> passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> data.password === data.confirm, {
    message: <span class="hljs-string">"Passwords don't match"</span>,
    path: [<span class="hljs-string">"confirm"</span>], <span class="hljs-comment">// path of error</span>
  });

passwordForm.parse({ password: <span class="hljs-string">"asdf"</span>, confirm: <span class="hljs-string">"qwer"</span> });
</code></pre>
<p>Because you provided a <code>path</code> parameter, the resulting error will be:</p>
<pre><code class="ts">ZodError {
  issues: [{
    <span class="hljs-string">"code"</span>: <span class="hljs-string">"custom"</span>,
    <span class="hljs-string">"path"</span>: [ <span class="hljs-string">"confirm"</span> ],
    <span class="hljs-string">"message"</span>: <span class="hljs-string">"Passwords don't match"</span>
  }]
}
</code></pre>
<div class="pilwrap" id="asynchronous-refinements">
  <h4>
    <a href="#asynchronous-refinements" name="asynchronous-refinements" class="pilcrow"></a>
Asynchronous refinements
  </h4>
</div>
<p>Refinements can also be async:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> userId = z.string().refine(<span class="hljs-keyword">async</span> (id) =&gt; {
  <span class="hljs-comment">// verify that ID exists in database</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});
</code></pre>
<blockquote>
<p>⚠️ If you use async refinements, you must use the <code>.parseAsync</code> method to parse data! Otherwise Zod will throw an error.</p>
</blockquote>
<div class="pilwrap" id="relationship-to-transforms">
  <h4>
    <a href="#relationship-to-transforms" name="relationship-to-transforms" class="pilcrow"></a>
Relationship to transforms
  </h4>
</div>
<p>Transforms and refinements can be interleaved:</p>
<pre><code class="ts">z.string()
  .transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length)
  .refine(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val &gt; <span class="hljs-number">25</span>);
</code></pre>
<!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.

```ts
const allForms = z.object({ passwordForm }).parse({
  passwordForm: {
    password: "asdf",
    confirm: "qwer",
  },
});
```

would result in

```

ZodError {
  issues: [{
    "code": "custom",
    "path": [ "passwordForm", "confirm" ],
    "message": "Passwords don't match"
  }]
}
``` -->
<div class="pilwrap" id=".superrefine">
  <h3>
    <a href="#.superrefine" name=".superrefine" class="pilcrow"></a>
<code>.superRefine</code>
  </h3>
</div>
<p>The <code>.refine</code> method is actually syntactic sugar atop a more versatile (and verbose) method called <code>superRefine</code>. Here's an example:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Strings = z.array(z.string()).superRefine(<span class="hljs-function">(<span class="hljs-params">val, ctx</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (val.length &gt; <span class="hljs-number">3</span>) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: <span class="hljs-number">3</span>,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">"array"</span>,
      inclusive: <span class="hljs-literal">true</span>,
      message: <span class="hljs-string">"Too many items 😡"</span>,
    });
  }

  <span class="hljs-keyword">if</span> (val.length !== <span class="hljs-keyword">new</span> Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: <span class="hljs-string">`No duplicates allowed.`</span>,
    });
  }
});
</code></pre>
<p>You can add as many issues as you like. If <code>ctx.addIssue</code> is <em>not</em> called during the execution of the function, validation passes.</p>
<p>Normally refinements always create issues with a <code>ZodIssueCode.custom</code> error code, but with <code>superRefine</code> it's possible to throw issues of any <code>ZodIssueCode</code>. Each issue code is described in detail in the Error Handling guide: <a href="ERROR_HANDLING.md.html">ERROR_HANDLING.md</a>.</p>
<div class="pilwrap" id="abort-early">
  <h4>
    <a href="#abort-early" name="abort-early" class="pilcrow"></a>
Abort early
  </h4>
</div>
<p>By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to <em>abort early</em> to prevent later refinements from being executed. To achieve this, pass the <code>fatal</code> flag to <code>ctx.addIssue</code> and return <code>z.NEVER</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z.number().superRefine(<span class="hljs-function">(<span class="hljs-params">val, ctx</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">10</span>) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: <span class="hljs-string">"should be &gt;= 10"</span>,
      fatal: <span class="hljs-literal">true</span>,
    });

    <span class="hljs-keyword">return</span> z.NEVER;
  }

  <span class="hljs-keyword">if</span> (val !== <span class="hljs-number">12</span>) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: <span class="hljs-string">"should be twelve"</span>,
    });
  }
});
</code></pre>
<div class="pilwrap" id="type-refinements">
  <h4>
    <a href="#type-refinements" name="type-refinements" class="pilcrow"></a>
Type refinements
  </h4>
</div>
<p>If you provide a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type predicate</a> to <code>.refine()</code> or <code>.superRefine()</code>, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z
  .object({
    first: z.string(),
    second: z.number(),
  })
  .nullable()
  .superRefine((arg, ctx): arg is { first: <span class="hljs-built_in">string</span>; second: <span class="hljs-built_in">number</span> } =&gt; {
    <span class="hljs-keyword">if</span> (!arg) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom, <span class="hljs-comment">// customize your issue</span>
        message: <span class="hljs-string">"object should exist"</span>,
      });
    }

    <span class="hljs-keyword">return</span> z.NEVER; <span class="hljs-comment">// The return value is not used, but we need to return something to satisfy the typing</span>
  })
  <span class="hljs-comment">// here, TS knows that arg is not null</span>
  .refine(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> arg.first === <span class="hljs-string">"bob"</span>, <span class="hljs-string">"`first` is not `bob`!"</span>);
</code></pre>
<blockquote>
<p>⚠️ You <strong>must</strong> use <code>ctx.addIssue()</code> instead of returning a boolean value to indicate whether the validation passes. If <code>ctx.addIssue</code> is <em>not</em> called during the execution of the function, validation passes.</p>
</blockquote>
<div class="pilwrap" id=".transform">
  <h3>
    <a href="#.transform" name=".transform" class="pilcrow"></a>
<code>.transform</code>
  </h3>
</div>
<p>To transform data after parsing, use the <code>transform</code> method.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringToNumber = z.string().transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length);

stringToNumber.parse(<span class="hljs-string">"string"</span>); <span class="hljs-comment">// =&gt; 6</span>
</code></pre>
<div class="pilwrap" id="chaining-order">
  <h4>
    <a href="#chaining-order" name="chaining-order" class="pilcrow"></a>
Chaining order
  </h4>
</div>
<p>Note that <code>stringToNumber</code> above is an instance of the <code>ZodEffects</code> subclass. It is NOT an instance of <code>ZodString</code>. If you want to use the built-in methods of <code>ZodString</code> (e.g. <code>.email()</code>) you must apply those methods <em>before</em> any transforms.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> emailToDomain = z
  .string()
  .email()
  .transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.split(<span class="hljs-string">"@"</span>)[<span class="hljs-number">1</span>]);

emailToDomain.parse(<span class="hljs-string">"colinhacks@example.com"</span>); <span class="hljs-comment">// =&gt; example.com</span>
</code></pre>
<div class="pilwrap" id="validating-during-transform">
  <h4>
    <a href="#validating-during-transform" name="validating-during-transform" class="pilcrow"></a>
Validating during transform
  </h4>
</div>
<p>The <code>.transform</code> method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining <code>transform</code> and <code>refine</code>.</p>
<p>As with <code>.superRefine</code>, the transform function receives a <code>ctx</code> object with an <code>addIssue</code> method that can be used to register validation issues.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberInString = z.string().transform(<span class="hljs-function">(<span class="hljs-params">val, ctx</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> parsed = <span class="hljs-built_in">parseInt</span>(val);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(parsed)) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: <span class="hljs-string">"Not a number"</span>,
    });

    <span class="hljs-comment">// This is a special symbol you can use to</span>
    <span class="hljs-comment">// return early from the transform function.</span>
    <span class="hljs-comment">// It has type `never` so it does not affect the</span>
    <span class="hljs-comment">// inferred return type.</span>
    <span class="hljs-keyword">return</span> z.NEVER;
  }
  <span class="hljs-keyword">return</span> parsed;
});
</code></pre>
<div class="pilwrap" id="relationship-to-refinements">
  <h4>
    <a href="#relationship-to-refinements" name="relationship-to-refinements" class="pilcrow"></a>
Relationship to refinements
  </h4>
</div>
<p>Transforms and refinements can be interleaved. These will be executed in the order they are declared.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nameToGreeting = z
  .string()
  .transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.toUpperCase())
  .refine(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length &gt; <span class="hljs-number">15</span>)
  .transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${val}</span>`</span>)
  .refine(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.indexOf(<span class="hljs-string">"!"</span>) === <span class="hljs-number">-1</span>);
</code></pre>
<div class="pilwrap" id="async-transforms">
  <h4>
    <a href="#async-transforms" name="async-transforms" class="pilcrow"></a>
Async transforms
  </h4>
</div>
<p>Transforms can also be async.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> IdToUser = z
  .string()
  .uuid()
  .transform(<span class="hljs-keyword">async</span> (id) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> getUserById(id);
  });
</code></pre>
<blockquote>
<p>⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.</p>
</blockquote>
<div class="pilwrap" id=".default">
  <h3>
    <a href="#.default" name=".default" class="pilcrow"></a>
<code>.default</code>
  </h3>
</div>
<p>You can use transforms to implement the concept of &quot;default values&quot; in Zod.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringWithDefault = z.string().default(<span class="hljs-string">"tuna"</span>);

stringWithDefault.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; "tuna"</span>
</code></pre>
<p>Optionally, you can pass a function into <code>.default</code> that will be re-executed whenever a default value needs to be generated:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberWithRandomDefault = z.number().default(<span class="hljs-built_in">Math</span>.random);

numberWithRandomDefault.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; 0.4413456736055323</span>
numberWithRandomDefault.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; 0.1871840107401901</span>
numberWithRandomDefault.parse(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// =&gt; 0.7223408162401552</span>
</code></pre>
<p>Conceptually, this is how Zod processes default values:</p>
<ol>
<li>If the input is <code>undefined</code>, the default value is returned</li>
<li>Otherwise, the data is parsed using the base schema</li>
</ol>
<div class="pilwrap" id=".describe">
  <h3>
    <a href="#.describe" name=".describe" class="pilcrow"></a>
<code>.describe</code>
  </h3>
</div>
<p>Use <code>.describe()</code> to add a <code>description</code> property to the resulting schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> documentedString = z
  .string()
  .describe(<span class="hljs-string">"A useful bit of text, if you know what to do with it."</span>);
documentedString.description; <span class="hljs-comment">// A useful bit of text…</span>
</code></pre>
<p>This can be useful for documenting a field, for example in a JSON Schema using a library like <a href="https://github.com/StefanTerdell/zod-to-json-schema"><code>zod-to-json-schema</code></a>).</p>
<div class="pilwrap" id=".catch">
  <h3>
    <a href="#.catch" name=".catch" class="pilcrow"></a>
<code>.catch</code>
  </h3>
</div>
<p>Use <code>.catch()</code> to provide a &quot;catch value&quot; to be returned in the event of a parsing error.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberWithCatch = z.number().catch(<span class="hljs-number">42</span>);

numberWithCatch.parse(<span class="hljs-number">5</span>); <span class="hljs-comment">// =&gt; 5</span>
numberWithCatch.parse(<span class="hljs-string">"tuna"</span>); <span class="hljs-comment">// =&gt; 42</span>
</code></pre>
<p>Optionally, you can pass a function into <code>.catch</code> that will be re-executed whenever a default value needs to be generated. A <code>ctx</code> object containing the caught error will be passed into this function.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> numberWithRandomCatch = z.number().catch(<span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {
  ctx.error; <span class="hljs-comment">// the caught ZodError</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();
});

numberWithRandomCatch.parse(<span class="hljs-string">"sup"</span>); <span class="hljs-comment">// =&gt; 0.4413456736055323</span>
numberWithRandomCatch.parse(<span class="hljs-string">"sup"</span>); <span class="hljs-comment">// =&gt; 0.1871840107401901</span>
numberWithRandomCatch.parse(<span class="hljs-string">"sup"</span>); <span class="hljs-comment">// =&gt; 0.7223408162401552</span>
</code></pre>
<p>Conceptually, this is how Zod processes &quot;catch values&quot;:</p>
<ol>
<li>The data is parsed using the base schema</li>
<li>If the parsing fails, the &quot;catch value&quot; is returned</li>
</ol>
<div class="pilwrap" id=".optional">
  <h3>
    <a href="#.optional" name=".optional" class="pilcrow"></a>
<code>.optional</code>
  </h3>
</div>
<p>A convenience method that returns an optional version of a schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> optionalString = z.string().optional(); <span class="hljs-comment">// string | undefined</span>

<span class="hljs-comment">// equivalent to</span>
z.optional(z.string());
</code></pre>
<div class="pilwrap" id=".nullable">
  <h3>
    <a href="#.nullable" name=".nullable" class="pilcrow"></a>
<code>.nullable</code>
  </h3>
</div>
<p>A convenience method that returns a nullable version of a schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nullableString = z.string().nullable(); <span class="hljs-comment">// string | null</span>

<span class="hljs-comment">// equivalent to</span>
z.nullable(z.string());
</code></pre>
<div class="pilwrap" id=".nullish">
  <h3>
    <a href="#.nullish" name=".nullish" class="pilcrow"></a>
<code>.nullish</code>
  </h3>
</div>
<p>A convenience method that returns a &quot;nullish&quot; version of a schema. Nullish schemas will accept both <code>undefined</code> and <code>null</code>. Read more about the concept of &quot;nullish&quot; <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing">in the TypeScript 3.7 release notes</a>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nullishString = z.string().nullish(); <span class="hljs-comment">// string | null | undefined</span>

<span class="hljs-comment">// equivalent to</span>
z.string().nullable().optional();
</code></pre>
<div class="pilwrap" id=".array">
  <h3>
    <a href="#.array" name=".array" class="pilcrow"></a>
<code>.array</code>
  </h3>
</div>
<p>A convenience method that returns an array schema for the given type:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringArray = z.string().array(); <span class="hljs-comment">// string[]</span>

<span class="hljs-comment">// equivalent to</span>
z.array(z.string());
</code></pre>
<div class="pilwrap" id=".promise">
  <h3>
    <a href="#.promise" name=".promise" class="pilcrow"></a>
<code>.promise</code>
  </h3>
</div>
<p>A convenience method for promise types:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringPromise = z.string().promise(); <span class="hljs-comment">// Promise&lt;string&gt;</span>

<span class="hljs-comment">// equivalent to</span>
z.promise(z.string());
</code></pre>
<div class="pilwrap" id=".or">
  <h3>
    <a href="#.or" name=".or" class="pilcrow"></a>
<code>.or</code>
  </h3>
</div>
<p>A convenience method for <a href="#unions.html">union types</a>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringOrNumber = z.string().or(z.number()); <span class="hljs-comment">// string | number</span>

<span class="hljs-comment">// equivalent to</span>
z.union([z.string(), z.number()]);
</code></pre>
<div class="pilwrap" id=".and">
  <h3>
    <a href="#.and" name=".and" class="pilcrow"></a>
<code>.and</code>
  </h3>
</div>
<p>A convenience method for creating intersection types.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> nameAndAge = z
  .object({ name: z.string() })
  .and(z.object({ age: z.number() })); <span class="hljs-comment">// { name: string } &amp; { age: number }</span>

<span class="hljs-comment">// equivalent to</span>
z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
</code></pre>
<div class="pilwrap" id=".brand">
  <h3>
    <a href="#.brand" name=".brand" class="pilcrow"></a>
<code>.brand</code>
  </h3>
</div>
<p><code>.brand&lt;T&gt;() =&gt; ZodBranded&lt;this, B&gt;</code></p>
<p>TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.</p>
<pre><code class="ts"><span class="hljs-keyword">type</span> Cat = { name: <span class="hljs-built_in">string</span> };
<span class="hljs-keyword">type</span> Dog = { name: <span class="hljs-built_in">string</span> };

<span class="hljs-keyword">const</span> petCat = <span class="hljs-function">(<span class="hljs-params">cat: Cat</span>) =&gt;</span> {};
<span class="hljs-keyword">const</span> fido: Dog = { name: <span class="hljs-string">"fido"</span> };
petCat(fido); <span class="hljs-comment">// works fine</span>
</code></pre>
<p>In some cases, its can be desirable to simulate <em>nominal typing</em> inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with <em>branded types</em> (AKA <em>opaque types</em>).</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Cat = z.object({ name: z.string() }).brand&lt;<span class="hljs-string">"Cat"</span>&gt;();
<span class="hljs-keyword">type</span> Cat = z.infer&lt;<span class="hljs-keyword">typeof</span> Cat&gt;;

<span class="hljs-keyword">const</span> petCat = <span class="hljs-function">(<span class="hljs-params">cat: Cat</span>) =&gt;</span> {};

<span class="hljs-comment">// this works</span>
<span class="hljs-keyword">const</span> simba = Cat.parse({ name: <span class="hljs-string">"simba"</span> });
petCat(simba);

<span class="hljs-comment">// this doesn't</span>
petCat({ name: <span class="hljs-string">"fido"</span> });
</code></pre>
<p>Under the hood, this works by attaching a &quot;brand&quot; to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> Cat = z.object({ name: z.string() }).brand&lt;<span class="hljs-string">"Cat"</span>&gt;();
<span class="hljs-keyword">type</span> Cat = z.infer&lt;<span class="hljs-keyword">typeof</span> Cat&gt;;
<span class="hljs-comment">// {name: string} &amp; {[symbol]: "Cat"}</span>
</code></pre>
<p>Note that branded types do not affect the runtime result of <code>.parse</code>. It is a static-only construct.</p>
<div class="pilwrap" id=".readonly">
  <h3>
    <a href="#.readonly" name=".readonly" class="pilcrow"></a>
<code>.readonly</code>
  </h3>
</div>
<p><code>.readonly() =&gt; ZodReadonly&lt;this&gt;</code></p>
<p>This method returns a <code>ZodReadonly</code> schema instance that parses the input using the base schema, then calls <code>Object.freeze()</code> on the result. The inferred type is also marked as <code>readonly</code>.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> schema = z.object({ name: z.string() }).readonly();
<span class="hljs-keyword">type</span> schema = z.infer&lt;<span class="hljs-keyword">typeof</span> schema&gt;;
<span class="hljs-comment">// Readonly&lt;{name: string}&gt;</span>

<span class="hljs-keyword">const</span> result = schema.parse({ name: <span class="hljs-string">"fido"</span> });
result.name = <span class="hljs-string">"simba"</span>; <span class="hljs-comment">// error</span>
</code></pre>
<p>The inferred type uses TypeScript's built-in readonly types when relevant.</p>
<pre><code class="ts">z.array(z.string()).readonly();
<span class="hljs-comment">// readonly string[]</span>

z.tuple([z.string(), z.number()]).readonly();
<span class="hljs-comment">// readonly [string, number]</span>

z.map(z.string(), z.date()).readonly();
<span class="hljs-comment">// ReadonlyMap&lt;string, Date&gt;</span>

z.set(z.string()).readonly();
<span class="hljs-comment">// ReadonlySet&lt;string&gt;</span>
</code></pre>
<div class="pilwrap" id=".pipe">
  <h3>
    <a href="#.pipe" name=".pipe" class="pilcrow"></a>
<code>.pipe</code>
  </h3>
</div>
<p>Schemas can be chained into validation &quot;pipelines&quot;. It's useful for easily validating the result after a <code>.transform()</code>:</p>
<pre><code class="ts">z.string()
  .transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length)
  .pipe(z.number().min(<span class="hljs-number">5</span>));
</code></pre>
<p>The <code>.pipe()</code> method returns a <code>ZodPipeline</code> instance.</p>
<div class="pilwrap" id="you-can-use.pipe-to-fix-common-issues-with-z.coerce">
  <h4>
    <a href="#you-can-use.pipe-to-fix-common-issues-with-z.coerce" name="you-can-use.pipe-to-fix-common-issues-with-z.coerce" class="pilcrow"></a>
You can use <code>.pipe()</code> to fix common issues with <code>z.coerce</code>.
  </h4>
</div>
<p>You can constrain the input to types that work well with your chosen coercion. Then use <code>.pipe()</code> to apply the coercion.</p>
<p>without constrained input:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> toDate = z.coerce.date();

<span class="hljs-comment">// works intuitively</span>
<span class="hljs-built_in">console</span>.log(toDate.safeParse(<span class="hljs-string">"2023-01-01"</span>).success); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// might not be what you want</span>
<span class="hljs-built_in">console</span>.log(toDate.safeParse(<span class="hljs-literal">null</span>).success); <span class="hljs-comment">// true</span>
</code></pre>
<p>with constrained input:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> datelike = z.union([z.number(), z.string(), z.date()]);
<span class="hljs-keyword">const</span> datelikeToDate = datelike.pipe(z.coerce.date());

<span class="hljs-comment">// still works intuitively</span>
<span class="hljs-built_in">console</span>.log(datelikeToDate.safeParse(<span class="hljs-string">"2023-01-01"</span>).success); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// more likely what you want</span>
<span class="hljs-built_in">console</span>.log(datelikeToDate.safeParse(<span class="hljs-literal">null</span>).success); <span class="hljs-comment">// false</span>
</code></pre>
<p>You can also use this technique to avoid coercions that throw uncaught errors.</p>
<p>without constrained input:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> toBigInt = z.coerce.bigint();

<span class="hljs-comment">// works intuitively</span>
<span class="hljs-built_in">console</span>.log(toBigInt.safeParse(<span class="hljs-string">"42"</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// probably not what you want</span>
<span class="hljs-built_in">console</span>.log(toBigInt.safeParse(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// throws uncaught error</span>
</code></pre>
<p>with constrained input:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> toNumber = z.number().or(z.string()).pipe(z.coerce.number());
<span class="hljs-keyword">const</span> toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());

<span class="hljs-comment">// still works intuitively</span>
<span class="hljs-built_in">console</span>.log(toBigInt.safeParse(<span class="hljs-string">"42"</span>).success); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// error handled by zod, more likely what you want</span>
<span class="hljs-built_in">console</span>.log(toBigInt.safeParse(<span class="hljs-literal">null</span>).success); <span class="hljs-comment">// false</span>
</code></pre>
<div class="pilwrap" id="guides-and-concepts">
  <h2>
    <a href="#guides-and-concepts" name="guides-and-concepts" class="pilcrow"></a>
Guides and concepts
  </h2>
</div>
<div class="pilwrap" id="type-inference">
  <h3>
    <a href="#type-inference" name="type-inference" class="pilcrow"></a>
Type inference
  </h3>
</div>
<p>You can extract the TypeScript type of any schema with <code>z.infer&lt;typeof mySchema&gt;</code> .</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> A = z.string();
<span class="hljs-keyword">type</span> A = z.infer&lt;<span class="hljs-keyword">typeof</span> A&gt;; <span class="hljs-comment">// string</span>

<span class="hljs-keyword">const</span> u: A = <span class="hljs-number">12</span>; <span class="hljs-comment">// TypeError</span>
<span class="hljs-keyword">const</span> u: A = <span class="hljs-string">"asdf"</span>; <span class="hljs-comment">// compiles</span>
</code></pre>
<p><strong>What about transforms?</strong></p>
<p>In reality each Zod schema internally tracks <strong>two</strong> types: an input and an output. For most schemas (e.g. <code>z.string()</code>) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance <code>z.string().transform(val =&gt; val.length)</code> has an input of <code>string</code> and an output of <code>number</code>.</p>
<p>You can separately extract the input and output types like so:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> stringToNumber = z.string().transform(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.length);

<span class="hljs-comment">// ⚠️ Important: z.infer returns the OUTPUT type!</span>
<span class="hljs-keyword">type</span> input = z.input&lt;<span class="hljs-keyword">typeof</span> stringToNumber&gt;; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> output = z.output&lt;<span class="hljs-keyword">typeof</span> stringToNumber&gt;; <span class="hljs-comment">// number</span>

<span class="hljs-comment">// equivalent to z.output!</span>
<span class="hljs-keyword">type</span> inferred = z.infer&lt;<span class="hljs-keyword">typeof</span> stringToNumber&gt;; <span class="hljs-comment">// number</span>
</code></pre>
<div class="pilwrap" id="writing-generic-functions">
  <h3>
    <a href="#writing-generic-functions" name="writing-generic-functions" class="pilcrow"></a>
Writing generic functions
  </h3>
</div>
<p>With TypeScript generics, you can write reusable functions that accept Zod schemas as parameters. This enables you to create custom validation logic, schema transformations, and more, while maintaining type safety and inference.</p>
<p>When attempting to write a function that accepts a Zod schema as an input, it's tempting to try something like this:</p>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferSchema</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">schema: z.ZodType&lt;T&gt;</span>) </span>{
  <span class="hljs-keyword">return</span> schema;
}
</code></pre>
<p>This approach is incorrect, and limits TypeScript's ability to properly infer the argument. No matter what you pass in, the type of <code>schema</code> will be an instance of <code>ZodType</code>.</p>
<pre><code class="ts">inferSchema(z.string());
<span class="hljs-comment">// =&gt; ZodType&lt;string&gt;</span>
</code></pre>
<p>This approach loses type information, namely <em>which subclass</em> the input actually is (in this case, <code>ZodString</code>). That means you can't call any string-specific methods like <code>.min()</code> on the result of <code>inferSchema</code>.</p>
<p>A better approach is to infer <em>the schema as a whole</em> instead of merely its inferred type. You can do this with a utility type called <code>z.ZodTypeAny</code>.</p>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferSchema</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">z</span>.<span class="hljs-title">ZodTypeAny</span>&gt;(<span class="hljs-params">schema: T</span>) </span>{
  <span class="hljs-keyword">return</span> schema;
}

inferSchema(z.string());
<span class="hljs-comment">// =&gt; ZodString</span>
</code></pre>
<blockquote>
<p><code>ZodTypeAny</code> is just a shorthand for <code>ZodType&lt;any, any, any&gt;</code>, a type that is broad enough to match any Zod schema.</p>
</blockquote>
<p>The Result is now fully and properly typed, and the type system can infer the specific subclass of the schema.</p>
<div class="pilwrap" id="inferring-the-inferred-type">
  <h4>
    <a href="#inferring-the-inferred-type" name="inferring-the-inferred-type" class="pilcrow"></a>
Inferring the inferred type
  </h4>
</div>
<p>If you follow the best practice of using <code>z.ZodTypeAny</code> as the generic parameter for your schema, you may encounter issues with the parsed data being typed as <code>any</code> instead of the inferred type of the schema.</p>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseData</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">z</span>.<span class="hljs-title">ZodTypeAny</span>&gt;(<span class="hljs-params">data: unknown, schema: T</span>) </span>{
  <span class="hljs-keyword">return</span> schema.parse(data);
}

parseData(<span class="hljs-string">"sup"</span>, z.string());
<span class="hljs-comment">// =&gt; any</span>
</code></pre>
<p>Due to how TypeScript inference works, it is treating <code>schema</code> like a <code>ZodTypeAny</code> instead of the inferred type. You can fix this with a type cast using <code>z.infer</code>.</p>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseData</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">z</span>.<span class="hljs-title">ZodTypeAny</span>&gt;(<span class="hljs-params">data: unknown, schema: T</span>) </span>{
  <span class="hljs-keyword">return</span> schema.parse(data) <span class="hljs-keyword">as</span> z.infer&lt;T&gt;;
  <span class="hljs-comment">//                        ^^^^^^^^^^^^^^ &lt;- add this</span>
}

parseData(<span class="hljs-string">"sup"</span>, z.string());
<span class="hljs-comment">// =&gt; string</span>
</code></pre>
<div class="pilwrap" id="constraining-allowable-inputs">
  <h4>
    <a href="#constraining-allowable-inputs" name="constraining-allowable-inputs" class="pilcrow"></a>
Constraining allowable inputs
  </h4>
</div>
<p>The <code>ZodType</code> class has three generic parameters.</p>
<pre><code class="ts"><span class="hljs-keyword">class</span> ZodType&lt;
  Output = <span class="hljs-built_in">any</span>,
  Def <span class="hljs-keyword">extends</span> ZodTypeDef = ZodTypeDef,
  Input = Output
&gt; { ... }
</code></pre>
<p>By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function:</p>
<pre><code class="ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSchemaOptional</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">z</span>.<span class="hljs-title">ZodType</span>&lt;<span class="hljs-title">string</span>&gt;&gt;(<span class="hljs-params">schema: T</span>) </span>{
  <span class="hljs-keyword">return</span> schema.optional();
}

makeSchemaOptional(z.string());
<span class="hljs-comment">// works fine</span>

makeSchemaOptional(z.number());
<span class="hljs-comment">// Error: 'ZodNumber' is not assignable to parameter of type 'ZodType&lt;string, ZodTypeDef, string&gt;'</span>
</code></pre>
<div class="pilwrap" id="error-handling">
  <h3>
    <a href="#error-handling" name="error-handling" class="pilcrow"></a>
Error handling
  </h3>
</div>
<p>Zod provides a subclass of Error called <code>ZodError</code>. ZodErrors contain an <code>issues</code> array containing detailed information about the validation problems.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> result = z
  .object({
    name: z.string(),
  })
  .safeParse({ name: <span class="hljs-number">12</span> });

<span class="hljs-keyword">if</span> (!result.success) {
  result.error.issues;
  <span class="hljs-comment">/* [
      {
        "code": "invalid_type",
        "expected": "string",
        "received": "number",
        "path": [ "name" ],
        "message": "Expected string, received number"
      }
  ] */</span>
}
</code></pre>
<blockquote>
<p>For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: <a href="ERROR_HANDLING.md.html">ERROR_HANDLING.md</a></p>
</blockquote>
<p>Zod's error reporting emphasizes <em>completeness</em> and <em>correctness</em>. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like <a href="https://github.com/causaly/zod-validation-error"><code>zod-validation-error</code></a></p>
<div class="pilwrap" id="error-formatting">
  <h3>
    <a href="#error-formatting" name="error-formatting" class="pilcrow"></a>
Error formatting
  </h3>
</div>
<p>You can use the <code>.format()</code> method to convert this error into a nested object.</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> result = z
  .object({
    name: z.string(),
  })
  .safeParse({ name: <span class="hljs-number">12</span> });

<span class="hljs-keyword">if</span> (!result.success) {
  <span class="hljs-keyword">const</span> formatted = result.error.format();
  <span class="hljs-comment">/* {
    name: { _errors: [ 'Expected string, received number' ] }
  } */</span>

  formatted.name?._errors;
  <span class="hljs-comment">// =&gt; ["Expected string, received number"]</span>
}
</code></pre>
<div class="pilwrap" id="comparison">
  <h2>
    <a href="#comparison" name="comparison" class="pilcrow"></a>
Comparison
  </h2>
</div>
<p>There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.</p>
<!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. -->
<!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |
| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |
| <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr>         |               🟢                |                  🔴                  |                  🟢                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |
| <abbr title="Yup's inferred types are incorrect in certain cases, see discussion below.">Correct type inference</abbr> |               🟢                |                  🔴                  |                  🔴                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |

<abbr title="number, string, boolean, null, undefined">Primitive Types</abbr>
<abbr title="Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.">String Validation</abbr>
<abbr title="Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.">Number Validation</abbr>
Dates

Primitive Literals
Object Literals
Tuple Literals
Objects
Arrays
Non-empty arrays
Unions
Optionals
Nullable
Enums
Enum Autocomplete
Intersections
Object Merging
Tuples
Recursive Types
Function Schemas

<abbr title="For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
Immutable instances
Type Guards
Validity Checking
Casting
Default Values
Rich Errors
Branded -->
<!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)

* Missing nonempty arrays with proper typing (`[T, ...T[]]`)
* Missing lazy/recursive types
* Missing promise schemas
* Missing function schemas
* Missing union & intersection schemas
* Missing support for parsing cyclical data (maybe)
* Missing error customization -->
<div class="pilwrap" id="joi">
  <h3>
    <a href="#joi" name="joi" class="pilcrow"></a>
Joi
  </h3>
</div>
<p><a href="https://github.com/hapijs/joi">https://github.com/hapijs/joi</a></p>
<p>Doesn't support static type inference 😕</p>
<div class="pilwrap" id="yup">
  <h3>
    <a href="#yup" name="yup" class="pilcrow"></a>
Yup
  </h3>
</div>
<p><a href="https://github.com/jquense/yup">https://github.com/jquense/yup</a></p>
<p>Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.</p>
<ul>
<li>Supports casting and transforms</li>
<li>All object fields are optional by default</li>
</ul>
<!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
<ul>
<li>Missing promise schemas</li>
<li>Missing function schemas</li>
<li>Missing union &amp; intersection schemas</li>
</ul>
<!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning "not undefined", Yup uses it to mean "not empty". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->
<div class="pilwrap" id="io-ts">
  <h3>
    <a href="#io-ts" name="io-ts" class="pilcrow"></a>
io-ts
  </h3>
</div>
<p><a href="https://github.com/gcanti/io-ts">https://github.com/gcanti/io-ts</a></p>
<p>io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.</p>
<p>In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:</p>
<pre><code class="ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> t <span class="hljs-keyword">from</span> <span class="hljs-string">"io-ts"</span>;

<span class="hljs-keyword">const</span> A = t.type({
  foo: t.string,
});

<span class="hljs-keyword">const</span> B = t.partial({
  bar: t.number,
});

<span class="hljs-keyword">const</span> C = t.intersection([A, B]);

<span class="hljs-keyword">type</span> C = t.TypeOf&lt;<span class="hljs-keyword">typeof</span> C&gt;;
<span class="hljs-comment">// returns { foo: string; bar?: number | undefined }</span>
</code></pre>
<p>You must define the required and optional props in separate object validators, pass the optionals through <code>t.partial</code> (which marks all properties as optional), then combine them with <code>t.intersection</code> .</p>
<p>Consider the equivalent in Zod:</p>
<pre><code class="ts"><span class="hljs-keyword">const</span> C = z.object({
  foo: z.string(),
  bar: z.number().optional(),
});

<span class="hljs-keyword">type</span> C = z.infer&lt;<span class="hljs-keyword">typeof</span> C&gt;;
<span class="hljs-comment">// returns { foo: string; bar?: number | undefined }</span>
</code></pre>
<p>This more declarative API makes schema definitions vastly more concise.</p>
<p><code>io-ts</code> also requires the use of gcanti's functional programming library <code>fp-ts</code> to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on <code>fp-ts</code> necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the <code>fp-ts</code> nomenclature to use the library.</p>
<ul>
<li>Supports codecs with serialization &amp; deserialization transforms</li>
<li>Supports branded types</li>
<li>Supports advanced functional programming, higher-kinded types, <code>fp-ts</code> compatibility</li>
<li>Missing object methods: (pick, omit, partial, deepPartial, merge, extend)</li>
<li>Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>)</li>
<li>Missing promise schemas</li>
<li>Missing function schemas</li>
</ul>
<div class="pilwrap" id="runtypes">
  <h3>
    <a href="#runtypes" name="runtypes" class="pilcrow"></a>
Runtypes
  </h3>
</div>
<p><a href="https://github.com/pelotom/runtypes">https://github.com/pelotom/runtypes</a></p>
<p>Good type inference support.</p>
<ul>
<li>Supports &quot;pattern matching&quot;: computed properties that distribute over unions</li>
<li>Missing object methods: (deepPartial, merge)</li>
<li>Missing nonempty arrays with proper typing (<code>[T, ...T[]]</code>)</li>
<li>Missing promise schemas</li>
<li>Missing error customization</li>
</ul>
<div class="pilwrap" id="ow">
  <h3>
    <a href="#ow" name="ow" class="pilcrow"></a>
Ow
  </h3>
</div>
<p><a href="https://github.com/sindresorhus/ow">https://github.com/sindresorhus/ow</a></p>
<p>Ow is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. <code>int32Array</code> , see full list in their README).</p>
<p>If you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.</p>
<div class="pilwrap" id="changelog">
  <h2>
    <a href="#changelog" name="changelog" class="pilcrow"></a>
Changelog
  </h2>
</div>
<p>View the changelog at <a href="CHANGELOG.md.html">CHANGELOG.md</a></p>
</div>
  </div>
</body>
</html>
