<!DOCTYPE html>
<html>
<head>
  <title>napi-inl.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/node-addon-api/napi-inl.h";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>napi-inl.h</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SRC_NAPI_INL_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SRC_NAPI_INL_H_</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Node-API C++ Wrapper Classes</p>
<p>Inline header-only implementations for &quot;Node-API&quot; ABI-stable C APIs for
Node.js.
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Note: Do not include this file directly! Include &quot;napi.h&quot; instead.
This should be a no-op and is intended for better IDE integration.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"napi.h"</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdarg&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_HAS_THREADS</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_HAS_THREADS</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">namespace</span> Napi {

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_CUSTOM_NAMESPACE</span>
<span class="hljs-keyword">namespace</span> NAPI_CPP_CUSTOM_NAMESPACE {
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Helpers to handle functions exposed from C++ and internal constants.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">namespace</span> details {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>New napi_status constants not yet available in all supported versions of
Node.js releases. Only necessary when they are used in napi.h and napi-inl.h.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> napi_no_external_buffers_allowed = <span class="hljs-number">22</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (defined(NAPI_EXPERIMENTAL) &amp;&amp;                                             \
     defined(NODE_API_EXPERIMENTAL_HAS_POST_FINALIZER))</span>
<span class="hljs-keyword">template</span> &lt;napi_finalize finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostFinalizerWrapper</span><span class="hljs-params">(node_api_nogc_env nogc_env,
                                 <span class="hljs-keyword">void</span>* data,
                                 <span class="hljs-keyword">void</span>* hint)</span> </span>{
  napi_status status = node_api_post_finalizer(nogc_env, finalizer, data, hint);
  NAPI_FATAL_IF_FAILED(
      status, <span class="hljs-string">"PostFinalizerWrapper"</span>, <span class="hljs-string">"node_api_post_finalizer failed"</span>);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">template</span> &lt;napi_finalize finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostFinalizerWrapper</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">void</span>* hint)</span> </span>{
  finalizer(env, data, hint);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FreeType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">default_finalizer</span><span class="hljs-params">(napi_env <span class="hljs-comment">/*env*/</span>, <span class="hljs-keyword">void</span>* data, <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*hint*/</span>)</span> </span>{
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">static_cast</span>&lt;FreeType*&gt;(data);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Attach a data item to an object and delete it when the object gets
garbage-collected.
TODO: Replace this code with <code>napi_add_finalizer()</code> whenever it becomes
available on all supported versions of Node.js.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> FreeType,
          napi_finalize finalizer = default_finalizer&lt;FreeType&gt;&gt;
<span class="hljs-keyword">inline</span> napi_status AttachData(napi_env env,
                              napi_value obj,
                              FreeType* data,
                              <span class="hljs-keyword">void</span>* hint = <span class="hljs-literal">nullptr</span>) {
  napi_status status;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NAPI_VERSION &lt; 5)</span>
  napi_value symbol, external;
  status = napi_create_symbol(env, <span class="hljs-literal">nullptr</span>, &amp;symbol);
  <span class="hljs-keyword">if</span> (status == napi_ok) {
    status = napi_create_external(env, data, finalizer, hint, &amp;external);
    <span class="hljs-keyword">if</span> (status == napi_ok) {
      napi_property_descriptor desc = {<span class="hljs-literal">nullptr</span>,
                                       symbol,
                                       <span class="hljs-literal">nullptr</span>,
                                       <span class="hljs-literal">nullptr</span>,
                                       <span class="hljs-literal">nullptr</span>,
                                       external,
                                       napi_default,
                                       <span class="hljs-literal">nullptr</span>};
      status = napi_define_properties(env, obj, <span class="hljs-number">1</span>, &amp;desc);
    }
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">// NAPI_VERSION &gt;= 5</span></span>
  status = napi_add_finalizer(
      env, obj, data, details::PostFinalizerWrapper&lt;finalizer&gt;, hint, <span class="hljs-literal">nullptr</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">return</span> status;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>For use in JS to C++ callback wrappers to catch any Napi::Error exceptions
and rethrow them as JavaScript exceptions before returning from the callback.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">WrapCallback</span><span class="hljs-params">(Callable callback)</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> callback();
  } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> Error&amp; e) {
    e.ThrowAsJavaScriptException();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>   <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>When C++ exceptions are disabled, errors are immediately thrown as JS
exceptions, so there is no need to catch and rethrow them here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">return</span> callback();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>For use in JS to C++ void callback wrappers to catch any Napi::Error
exceptions and rethrow them as JavaScript exceptions before returning from
the callback.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WrapVoidCallback</span><span class="hljs-params">(Callable callback)</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
  <span class="hljs-keyword">try</span> {
    callback();
  } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> Error&amp; e) {
    e.ThrowAsJavaScriptException();
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>   <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>When C++ exceptions are disabled, errors are immediately thrown as JS
exceptions, so there is no need to catch and rethrow them here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  callback();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable, <span class="hljs-keyword">typename</span> Return&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CallbackData</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">Wrapper</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{
    <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          <span class="hljs-keyword">static_cast</span>&lt;CallbackData*&gt;(callbackInfo.Data());
      callbackInfo.SetData(callbackData-&gt;data);
      <span class="hljs-keyword">return</span> callbackData-&gt;callback(callbackInfo);
    });
  }

  Callable callback;
  <span class="hljs-keyword">void</span>* data;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CallbackData</span>&lt;Callable, void&gt; {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">Wrapper</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{
    <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
      CallbackInfo callbackInfo(env, info);
      CallbackData* callbackData =
          <span class="hljs-keyword">static_cast</span>&lt;CallbackData*&gt;(callbackInfo.Data());
      callbackInfo.SetData(callbackData-&gt;data);
      callbackData-&gt;callback(callbackInfo);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    });
  }

  Callable callback;
  <span class="hljs-keyword">void</span>* data;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">void</span> (*Callback)(<span class="hljs-keyword">const</span> CallbackInfo&amp; info)&gt;
<span class="hljs-function">napi_value <span class="hljs-title">TemplatedVoidCallback</span><span class="hljs-params">(napi_env env,
                                 napi_callback_info info)</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo cbInfo(env, info);
    Callback(cbInfo);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;Napi::Value (*Callback)(<span class="hljs-keyword">const</span> CallbackInfo&amp; info)&gt;
<span class="hljs-function">napi_value <span class="hljs-title">TemplatedCallback</span><span class="hljs-params">(napi_env env,
                             napi_callback_info info)</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo cbInfo(env, info);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>MSVC requires to copy 'Callback' function pointer to a local variable
before invoking it.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">auto</span> callback = Callback;
    <span class="hljs-keyword">return</span> callback(cbInfo);
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,
          Napi::Value (T::*UnwrapCallback)(<span class="hljs-keyword">const</span> CallbackInfo&amp; info)&gt;
<span class="hljs-function">napi_value <span class="hljs-title">TemplatedInstanceCallback</span><span class="hljs-params">(napi_env env,
                                     napi_callback_info info)</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">return</span> instance ? (instance-&gt;*UnwrapCallback)(cbInfo) : Napi::Value();
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">void</span> (T::*UnwrapCallback)(<span class="hljs-keyword">const</span> CallbackInfo&amp; info)&gt;
<span class="hljs-function">napi_value <span class="hljs-title">TemplatedInstanceVoidCallback</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span>
    NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">if</span> (instance) (instance-&gt;*UnwrapCallback)(cbInfo);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> Hint = <span class="hljs-keyword">void</span>&gt;
struct FinalizeData {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Wrapper(napi_env env,
                             <span class="hljs-keyword">void</span>* data,
                             <span class="hljs-keyword">void</span>* finalizeHint) NAPI_NOEXCEPT {
    WrapVoidCallback([&amp;] {
      FinalizeData* finalizeData = <span class="hljs-keyword">static_cast</span>&lt;FinalizeData*&gt;(finalizeHint);
      finalizeData-&gt;callback(Env(env), <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(data));
      <span class="hljs-keyword">delete</span> finalizeData;
    });
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WrapperWithHint</span><span class="hljs-params">(napi_env env,
                                     <span class="hljs-keyword">void</span>* data,
                                     <span class="hljs-keyword">void</span>* finalizeHint)</span> NAPI_NOEXCEPT </span>{
    WrapVoidCallback([&amp;] {
      FinalizeData* finalizeData = <span class="hljs-keyword">static_cast</span>&lt;FinalizeData*&gt;(finalizeHint);
      finalizeData-&gt;callback(
          Env(env), <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(data), finalizeData-&gt;hint);
      <span class="hljs-keyword">delete</span> finalizeData;
    });
  }

  Finalizer callback;
  Hint* hint;
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NAPI_VERSION &gt; 3 &amp;&amp; NAPI_HAS_THREADS)</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType = <span class="hljs-keyword">void</span>,
          <span class="hljs-keyword">typename</span> Finalizer = <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(Env, <span class="hljs-keyword">void</span>*, ContextType*)&gt;,
          <span class="hljs-keyword">typename</span> FinalizerDataType = <span class="hljs-keyword">void</span>&gt;
struct ThreadSafeFinalize {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Wrapper(napi_env env,
                             <span class="hljs-keyword">void</span>* rawFinalizeData,
                             <span class="hljs-keyword">void</span>* <span class="hljs-comment">/* rawContext */</span>) {
    <span class="hljs-keyword">if</span> (rawFinalizeData == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    ThreadSafeFinalize* finalizeData =
        <span class="hljs-keyword">static_cast</span>&lt;ThreadSafeFinalize*&gt;(rawFinalizeData);
    finalizeData-&gt;callback(Env(env));
    <span class="hljs-keyword">delete</span> finalizeData;
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FinalizeWrapperWithData</span><span class="hljs-params">(napi_env env,
                                             <span class="hljs-keyword">void</span>* rawFinalizeData,
                                             <span class="hljs-keyword">void</span>* <span class="hljs-comment">/* rawContext */</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (rawFinalizeData == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    ThreadSafeFinalize* finalizeData =
        <span class="hljs-keyword">static_cast</span>&lt;ThreadSafeFinalize*&gt;(rawFinalizeData);
    finalizeData-&gt;callback(Env(env), finalizeData-&gt;data);
    <span class="hljs-keyword">delete</span> finalizeData;
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FinalizeWrapperWithContext</span><span class="hljs-params">(napi_env env,
                                                <span class="hljs-keyword">void</span>* rawFinalizeData,
                                                <span class="hljs-keyword">void</span>* rawContext)</span> </span>{
    <span class="hljs-keyword">if</span> (rawFinalizeData == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    ThreadSafeFinalize* finalizeData =
        <span class="hljs-keyword">static_cast</span>&lt;ThreadSafeFinalize*&gt;(rawFinalizeData);
    finalizeData-&gt;callback(Env(env), <span class="hljs-keyword">static_cast</span>&lt;ContextType*&gt;(rawContext));
    <span class="hljs-keyword">delete</span> finalizeData;
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FinalizeFinalizeWrapperWithDataAndContext</span><span class="hljs-params">(
      napi_env env, <span class="hljs-keyword">void</span>* rawFinalizeData, <span class="hljs-keyword">void</span>* rawContext)</span> </span>{
    <span class="hljs-keyword">if</span> (rawFinalizeData == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    ThreadSafeFinalize* finalizeData =
        <span class="hljs-keyword">static_cast</span>&lt;ThreadSafeFinalize*&gt;(rawFinalizeData);
    finalizeData-&gt;callback(
        Env(env), finalizeData-&gt;data, <span class="hljs-keyword">static_cast</span>&lt;ContextType*&gt;(rawContext));
    <span class="hljs-keyword">delete</span> finalizeData;
  }

  FinalizerDataType* data;
  Finalizer callback;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType, <span class="hljs-keyword">typename</span> DataType, <span class="hljs-keyword">typename</span> CallJs, CallJs call&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::enable_if&lt;call != <span class="hljs-keyword">static_cast</span>&lt;CallJs&gt;(<span class="hljs-literal">nullptr</span>)&gt;::type
CallJsWrapper(napi_env env, napi_value jsCallback, <span class="hljs-keyword">void</span>* context, <span class="hljs-keyword">void</span>* data) {
  details::WrapVoidCallback([&amp;]() {
    call(env,
         Function(env, jsCallback),
         <span class="hljs-keyword">static_cast</span>&lt;ContextType*&gt;(context),
         <span class="hljs-keyword">static_cast</span>&lt;DataType*&gt;(data));
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType, <span class="hljs-keyword">typename</span> DataType, <span class="hljs-keyword">typename</span> CallJs, CallJs call&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::enable_if&lt;call == <span class="hljs-keyword">static_cast</span>&lt;CallJs&gt;(<span class="hljs-literal">nullptr</span>)&gt;::type
CallJsWrapper(napi_env env,
              napi_value jsCallback,
              <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*context*/</span>,
              <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*data*/</span>) {
  details::WrapVoidCallback([&amp;]() {
    <span class="hljs-keyword">if</span> (jsCallback != <span class="hljs-literal">nullptr</span>) {
      Function(env, jsCallback).Call(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
    }
  });
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 4</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CallbackType, <span class="hljs-keyword">typename</span> TSFN&gt;
<span class="hljs-function">napi_value <span class="hljs-title">DefaultCallbackWrapper</span><span class="hljs-params">(napi_env <span class="hljs-comment">/*env*/</span>, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span> <span class="hljs-comment">/*cb*/</span>)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CallbackType, <span class="hljs-keyword">typename</span> TSFN&gt;
<span class="hljs-function">napi_value <span class="hljs-title">DefaultCallbackWrapper</span><span class="hljs-params">(napi_env <span class="hljs-comment">/*env*/</span>, Napi::Function cb)</span> </span>{
  <span class="hljs-keyword">return</span> cb;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CallbackType, <span class="hljs-keyword">typename</span> TSFN&gt;
<span class="hljs-function">napi_value <span class="hljs-title">DefaultCallbackWrapper</span><span class="hljs-params">(napi_env env, Napi::Function cb)</span> </span>{
  <span class="hljs-keyword">if</span> (cb.IsEmpty()) {
    <span class="hljs-keyword">return</span> TSFN::EmptyFunctionFactory(env);
  }
  <span class="hljs-keyword">return</span> cb;
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt; 4</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt; 3 &amp;&amp; NAPI_HAS_THREADS</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter, <span class="hljs-keyword">typename</span> Setter&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AccessorCallbackData</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">GetterWrapper</span><span class="hljs-params">(napi_env env,
                                         napi_callback_info info)</span> </span>{
    <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          <span class="hljs-keyword">static_cast</span>&lt;AccessorCallbackData*&gt;(callbackInfo.Data());
      callbackInfo.SetData(callbackData-&gt;data);
      <span class="hljs-keyword">return</span> callbackData-&gt;getterCallback(callbackInfo);
    });
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">SetterWrapper</span><span class="hljs-params">(napi_env env,
                                         napi_callback_info info)</span> </span>{
    <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
      CallbackInfo callbackInfo(env, info);
      AccessorCallbackData* callbackData =
          <span class="hljs-keyword">static_cast</span>&lt;AccessorCallbackData*&gt;(callbackInfo.Data());
      callbackInfo.SetData(callbackData-&gt;data);
      callbackData-&gt;setterCallback(callbackInfo);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    });
  }

  Getter getterCallback;
  Setter setterCallback;
  <span class="hljs-keyword">void</span>* data;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Debugging-purpose C++-style variant of sprintf().</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">StringFormat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* format, ...)</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> result;
  va_list args;
  va_start(args, format);
  <span class="hljs-keyword">int</span> len = vsnprintf(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, format, args);
  result.resize(len);
  vsnprintf(&amp;result[<span class="hljs-number">0</span>], len + <span class="hljs-number">1</span>, format, args);
  va_end(args);
  <span class="hljs-keyword">return</span> result;
}

}  <span class="hljs-comment">// namespace details</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_ADDON_API_DISABLE_DEPRECATED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"napi-inl.deprecated.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// !NODE_ADDON_API_DISABLE_DEPRECATED</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Module registration
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Register an add-on based on an initializer function.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_API_MODULE(modname, regfunc)                                      \
  static napi_value __napi_##regfunc(napi_env env, napi_value exports) {       \
    return Napi::RegisterModule(env, exports, regfunc);                        \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##regfunc)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Register an add-on based on a subclass of <code>Addon&lt;T&gt;</code> with a custom Node.js
module name.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_API_NAMED_ADDON(modname, classname)                               \
  static napi_value __napi_##classname(napi_env env, napi_value exports) {     \
    return Napi::RegisterModule(env, exports, &amp;classname::Init);               \
  }                                                                            \
  NAPI_MODULE(modname, __napi_##classname)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Register an add-on based on a subclass of <code>Addon&lt;T&gt;</code> with the Node.js module
name given by node-gyp from the <code>target_name</code> in binding.gyp.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_API_ADDON(classname)                                              \
  NODE_API_NAMED_ADDON(NODE_GYP_MODULE_NAME, classname)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Adapt the NAPI_MODULE registration function:</p>
<ul>
<li>Wrap the arguments in NAPI wrappers.</li>
<li>Catch any NAPI errors and rethrow as JS exceptions.</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> napi_value <span class="hljs-title">RegisterModule</span><span class="hljs-params">(napi_env env,
                                 napi_value exports,
                                 ModuleRegisterCallback registerCallback)</span> </span>{
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    <span class="hljs-keyword">return</span> napi_value(
        registerCallback(Napi::Env(env), Napi::Object(env, exports)));
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Maybe class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:IsNothing() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> !_has_value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:IsJust() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _has_value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:Check() <span class="hljs-keyword">const</span> {
  NAPI_CHECK(IsJust(), <span class="hljs-string">"Napi::Maybe::Check"</span>, <span class="hljs-string">"Maybe value is Nothing."</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">T</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:Unwrap() <span class="hljs-keyword">const</span> {
  NAPI_CHECK(IsJust(), <span class="hljs-string">"Napi::Maybe::Unwrap"</span>, <span class="hljs-string">"Maybe value is Nothing."</span>);
  <span class="hljs-keyword">return</span> _value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">T</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:UnwrapOr(<span class="hljs-keyword">const</span> T&amp; default_value) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _has_value ? _value : default_value;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:UnwrapTo(T* out) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">if</span> (IsJust()) {
    *out = _value;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Maybe&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> (IsJust() == other.IsJust()) &amp;&amp;
         (!IsJust() || Unwrap() == other.Unwrap());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Maybe&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(other);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:Maybe() : _has_value(<span class="hljs-literal">false</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">Maybe</span>&lt;T&gt;:</span>:Maybe(<span class="hljs-keyword">const</span> T&amp; t) : _has_value(<span class="hljs-literal">true</span>), _value(t) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">Maybe</span>&lt;T&gt; <span class="hljs-title">Nothing</span>() {</span>
  <span class="hljs-keyword">return</span> Maybe&lt;T&gt;();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">Maybe</span>&lt;T&gt; <span class="hljs-title">Just</span>(<span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">t</span>) {</span>
  <span class="hljs-keyword">return</span> Maybe&lt;T&gt;(t);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Env class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Env::Env</span><span class="hljs-params">(napi_env env)</span> : _<span class="hljs-title">env</span><span class="hljs-params">(env)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Env::<span class="hljs-keyword">operator</span> <span class="hljs-title">napi_env</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _env;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Object <span class="hljs-title">Env::Global</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value value;
  napi_status status = napi_get_global(*<span class="hljs-keyword">this</span>, &amp;value);
  NAPI_THROW_IF_FAILED(*<span class="hljs-keyword">this</span>, status, Object());
  <span class="hljs-keyword">return</span> Object(*<span class="hljs-keyword">this</span>, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Value <span class="hljs-title">Env::Undefined</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value value;
  napi_status status = napi_get_undefined(*<span class="hljs-keyword">this</span>, &amp;value);
  NAPI_THROW_IF_FAILED(*<span class="hljs-keyword">this</span>, status, Value());
  <span class="hljs-keyword">return</span> Value(*<span class="hljs-keyword">this</span>, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Value <span class="hljs-title">Env::Null</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value value;
  napi_status status = napi_get_null(*<span class="hljs-keyword">this</span>, &amp;value);
  NAPI_THROW_IF_FAILED(*<span class="hljs-keyword">this</span>, status, Value());
  <span class="hljs-keyword">return</span> Value(*<span class="hljs-keyword">this</span>, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Env::IsExceptionPending</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_exception_pending(_env, &amp;result);
  <span class="hljs-keyword">if</span> (status != napi_ok)
    result = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Checking for a pending exception shouldn't throw.</span>
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Error <span class="hljs-title">Env::GetAndClearPendingException</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value value;
  napi_status status = napi_get_and_clear_last_exception(_env, &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Don't throw another exception when failing to get the exception!</p>

        </td>
        <td class="code highlight">
          <pre class="c">    return Error();
  }
  return Error(_env, value);
}

inline MaybeOrValue&lt;Value&gt; Env::RunScript(const char* utf8script) const {
  String script = String::New(_env, utf8script);
  return RunScript(script);
}

inline MaybeOrValue&lt;Value&gt; Env::RunScript(const std::string&amp; utf8script) const {
  return RunScript(utf8script.c_str());
}

inline MaybeOrValue&lt;Value&gt; Env::RunScript(String script) const {
  napi_value result;
  napi_status status = napi_run_script(_env, script, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Value(_env, result), Napi::Value);
}

#if NAPI_VERSION &gt; 2
template &lt;typename Hook, typename Arg&gt;
void Env::CleanupHook&lt;Hook, Arg&gt;::Wrapper(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast&lt;typename Napi::Env::CleanupHook&lt;Hook, Arg&gt;::CleanupData*&gt;(
          data);
  cleanupData-&gt;hook();
  delete cleanupData;
}

template &lt;typename Hook, typename Arg&gt;
void Env::CleanupHook&lt;Hook, Arg&gt;::WrapperWithArg(void* data) NAPI_NOEXCEPT {
  auto* cleanupData =
      static_cast&lt;typename Napi::Env::CleanupHook&lt;Hook, Arg&gt;::CleanupData*&gt;(
          data);
  cleanupData-&gt;hook(static_cast&lt;Arg*&gt;(cleanupData-&gt;arg));
  delete cleanupData;
}
#endif  // NAPI_VERSION &gt; 2

#if NAPI_VERSION &gt; 5
template &lt;typename T, Env::Finalizer&lt;T&gt; fini&gt;
inline void Env::SetInstanceData(T* data) const {
  napi_status status = napi_set_instance_data(
      _env,
      data,
      [](napi_env env, void* data, void*) { fini(env, static_cast&lt;T*&gt;(data)); },
      nullptr);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

template &lt;typename DataType,
          typename HintType,
          Napi::Env::FinalizerWithHint&lt;DataType, HintType&gt; fini&gt;
inline void Env::SetInstanceData(DataType* data, HintType* hint) const {
  napi_status status = napi_set_instance_data(
      _env,
      data,
      [](napi_env env, void* data, void* hint) {
        fini(env, static_cast&lt;DataType*&gt;(data), static_cast&lt;HintType*&gt;(hint));
      },
      hint);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

template &lt;typename T&gt;
inline T* Env::GetInstanceData() const {
  void* data = nullptr;

  napi_status status = napi_get_instance_data(_env, &amp;data);
  NAPI_THROW_IF_FAILED(_env, status, nullptr);

  return static_cast&lt;T*&gt;(data);
}

template &lt;typename T&gt;
void Env::DefaultFini(Env, T* data) {
  delete data;
}

template &lt;typename DataType, typename HintType&gt;
void Env::DefaultFiniWithHint(Env, DataType* data, HintType*) {
  delete data;
}
#endif  // NAPI_VERSION &gt; 5

#if NAPI_VERSION &gt; 8
inline const char* Env::GetModuleFileName() const {
  const char* result;
  napi_status status = node_api_get_module_file_name(_env, &amp;result);
  NAPI_THROW_IF_FAILED(*this, status, nullptr);
  return result;
}
#endif  // NAPI_VERSION &gt; 8
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Value class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline Value::Value() : _env(nullptr), _value(nullptr) {}

inline Value::Value(napi_env env, napi_value value)
    : _env(env), _value(value) {}

inline Value::operator napi_value() const {
  return _value;
}

inline bool Value::operator==(const Value&amp; other) const {
  return StrictEquals(other);
}

inline bool Value::operator!=(const Value&amp; other) const {
  return !this-&gt;operator==(other);
}

inline bool Value::StrictEquals(const Value&amp; other) const {
  bool result;
  napi_status status = napi_strict_equals(_env, *this, other, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline Napi::Env Value::Env() const {
  return Napi::Env(_env);
}

inline bool Value::IsEmpty() const {
  return _value == nullptr;
}

inline napi_valuetype Value::Type() const {
  if (IsEmpty()) {
    return napi_undefined;
  }

  napi_valuetype type;
  napi_status status = napi_typeof(_env, _value, &amp;type);
  NAPI_THROW_IF_FAILED(_env, status, napi_undefined);
  return type;
}

inline bool Value::IsUndefined() const {
  return Type() == napi_undefined;
}

inline bool Value::IsNull() const {
  return Type() == napi_null;
}

inline bool Value::IsBoolean() const {
  return Type() == napi_boolean;
}

inline bool Value::IsNumber() const {
  return Type() == napi_number;
}

#if NAPI_VERSION &gt; 5
inline bool Value::IsBigInt() const {
  return Type() == napi_bigint;
}
#endif  // NAPI_VERSION &gt; 5

#if (NAPI_VERSION &gt; 4)
inline bool Value::IsDate() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_date(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}
#endif

inline bool Value::IsString() const {
  return Type() == napi_string;
}

inline bool Value::IsSymbol() const {
  return Type() == napi_symbol;
}

inline bool Value::IsArray() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_array(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsArrayBuffer() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_arraybuffer(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsTypedArray() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_typedarray(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsObject() const {
  return Type() == napi_object || IsFunction();
}

inline bool Value::IsFunction() const {
  return Type() == napi_function;
}

inline bool Value::IsPromise() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_promise(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsDataView() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_dataview(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsBuffer() const {
  if (IsEmpty()) {
    return false;
  }

  bool result;
  napi_status status = napi_is_buffer(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, false);
  return result;
}

inline bool Value::IsExternal() const {
  return Type() == napi_external;
}

template &lt;typename T&gt;
inline T Value::As() const {
#ifdef NODE_ADDON_API_ENABLE_TYPE_CHECK_ON_AS
  T::CheckCast(_env, _value);
#endif
  return T(_env, _value);
}

inline MaybeOrValue&lt;Boolean&gt; Value::ToBoolean() const {
  napi_value result;
  napi_status status = napi_coerce_to_bool(_env, _value, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Boolean(_env, result), Napi::Boolean);
}

inline MaybeOrValue&lt;Number&gt; Value::ToNumber() const {
  napi_value result;
  napi_status status = napi_coerce_to_number(_env, _value, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Number(_env, result), Napi::Number);
}

inline MaybeOrValue&lt;String&gt; Value::ToString() const {
  napi_value result;
  napi_status status = napi_coerce_to_string(_env, _value, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::String(_env, result), Napi::String);
}

inline MaybeOrValue&lt;Object&gt; Value::ToObject() const {
  napi_value result;
  napi_status status = napi_coerce_to_object(_env, _value, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Object(_env, result), Napi::Object);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Boolean class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Boolean <span class="hljs-title">Boolean::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">bool</span> val)</span> </span>{
  napi_value value;
  napi_status status = napi_get_boolean(env, val, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Boolean());
  <span class="hljs-keyword">return</span> Boolean(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Boolean::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Boolean::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Boolean::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_boolean, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"Boolean::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Boolean::Boolean</span><span class="hljs-params">()</span> : <span class="hljs-title">Napi::Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Boolean::Boolean</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Napi::Value</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Boolean::<span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Boolean::Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_get_value_bool(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> result;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Number class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Number <span class="hljs-title">Number::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">double</span> val)</span> </span>{
  napi_value value;
  napi_status status = napi_create_double(env, val, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Number());
  <span class="hljs-keyword">return</span> Number(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Number::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Number::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Number::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_number, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"Number::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Number::Number</span><span class="hljs-params">()</span> : <span class="hljs-title">Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Number::Number</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Value</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Number::<span class="hljs-keyword">operator</span> <span class="hljs-title">int32_t</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Int32Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Number::<span class="hljs-keyword">operator</span> <span class="hljs-title">uint32_t</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Uint32Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Number::<span class="hljs-keyword">operator</span> <span class="hljs-title">int64_t</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Int64Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Number::<span class="hljs-keyword">operator</span> <span class="hljs-title">float</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> FloatValue();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Number::<span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> DoubleValue();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">Number::Int32Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">int32_t</span> result;
  napi_status status = napi_get_value_int32(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Number::Uint32Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">uint32_t</span> result;
  napi_status status = napi_get_value_uint32(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int64_t</span> <span class="hljs-title">Number::Int64Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">int64_t</span> result;
  napi_status status = napi_get_value_int64(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Number::FloatValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(DoubleValue());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Number::DoubleValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">double</span> result;
  napi_status status = napi_get_value_double(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 5</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
BigInt Class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> BigInt <span class="hljs-title">BigInt::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">int64_t</span> val)</span> </span>{
  napi_value value;
  napi_status status = napi_create_bigint_int64(env, val, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, BigInt());
  <span class="hljs-keyword">return</span> BigInt(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> BigInt <span class="hljs-title">BigInt::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">uint64_t</span> val)</span> </span>{
  napi_value value;
  napi_status status = napi_create_bigint_uint64(env, val, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, BigInt());
  <span class="hljs-keyword">return</span> BigInt(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> BigInt <span class="hljs-title">BigInt::New</span><span class="hljs-params">(napi_env env,
                          <span class="hljs-keyword">int</span> sign_bit,
                          <span class="hljs-keyword">size_t</span> word_count,
                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span>* words)</span> </span>{
  napi_value value;
  napi_status status =
      napi_create_bigint_words(env, sign_bit, word_count, words, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, BigInt());
  <span class="hljs-keyword">return</span> BigInt(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BigInt::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"BigInt::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"BigInt::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_bigint, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"BigInt::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">BigInt::BigInt</span><span class="hljs-params">()</span> : <span class="hljs-title">Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">BigInt::BigInt</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Value</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int64_t</span> <span class="hljs-title">BigInt::Int64Value</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>* lossless)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">int64_t</span> result;
  napi_status status =
      napi_get_value_bigint_int64(_env, _value, &amp;result, lossless);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">BigInt::Uint64Value</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>* lossless)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">uint64_t</span> result;
  napi_status status =
      napi_get_value_bigint_uint64(_env, _value, &amp;result, lossless);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">BigInt::WordCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">size_t</span> word_count;
  napi_status status =
      napi_get_value_bigint_words(_env, _value, <span class="hljs-literal">nullptr</span>, &amp;word_count, <span class="hljs-literal">nullptr</span>);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> word_count;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BigInt::ToWords</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* sign_bit,
                            <span class="hljs-keyword">size_t</span>* word_count,
                            <span class="hljs-keyword">uint64_t</span>* words)</span> </span>{
  napi_status status =
      napi_get_value_bigint_words(_env, _value, sign_bit, word_count, words);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt; 5</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NAPI_VERSION &gt; 4)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Date Class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Date <span class="hljs-title">Date::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">double</span> val)</span> </span>{
  napi_value value;
  napi_status status = napi_create_date(env, val, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Date());
  <span class="hljs-keyword">return</span> Date(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Date::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Date::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_date(env, value, &amp;result);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Date::CheckCast"</span>, <span class="hljs-string">"napi_is_date failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"Date::CheckCast"</span>, <span class="hljs-string">"value is not date"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Date::Date</span><span class="hljs-params">()</span> : <span class="hljs-title">Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Date::Date</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Value</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Date::<span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ValueOf();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Date::ValueOf</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">double</span> result;
  napi_status status = napi_get_date_value(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Name class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Name::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Name::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Name::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK(type == napi_string || type == napi_symbol,
                      <span class="hljs-string">"Name::CheckCast"</span>,
                      <span class="hljs-string">"value is not napi_string or napi_symbol, got %d."</span>,
                      type);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Name::Name</span><span class="hljs-params">()</span> : <span class="hljs-title">Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Name::Name</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Value</span><span class="hljs-params">(env, value)</span> </span>{}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
String class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; val)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, val.c_str(), val.<span class="hljs-built_in">size</span>());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::u16string&amp; val)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, val.c_str(), val.<span class="hljs-built_in">size</span>());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* val)</span> </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>TODO(@gabrielschulhof) Remove if-statement when core's error handling is
available in all supported versions.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">nullptr</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Throw an error that looks like it came from core.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, <span class="hljs-keyword">String</span>());
  }
  napi_value value;
  napi_status status =
      napi_create_string_utf8(env, val, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(val), &amp;value);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-keyword">String</span>());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>* val)</span> </span>{
  napi_value value;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>TODO(@gabrielschulhof) Remove if-statement when core's error handling is
available in all supported versions.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">nullptr</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Throw an error that looks like it came from core.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    NAPI_THROW_IF_FAILED(env, napi_invalid_arg, <span class="hljs-keyword">String</span>());
  }
  napi_status status =
      napi_create_string_utf16(env, val, <span class="hljs-built_in">std</span>::u16string(val).<span class="hljs-built_in">size</span>(), &amp;value);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-keyword">String</span>());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* val, <span class="hljs-keyword">size_t</span> length)</span> </span>{
  napi_value value;
  napi_status status = napi_create_string_utf8(env, val, length, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-keyword">String</span>());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span> <span class="hljs-title">String::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>* val, <span class="hljs-keyword">size_t</span> length)</span> </span>{
  napi_value value;
  napi_status status = napi_create_string_utf16(env, val, length, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-keyword">String</span>());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">String::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"String::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"String::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_string, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"String::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">String::String</span><span class="hljs-params">()</span> : <span class="hljs-title">Name</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">String::String</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Name</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span>::<span class="hljs-keyword">operator</span> <span class="hljs-title">std::string</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Utf8Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">String</span>::<span class="hljs-keyword">operator</span> <span class="hljs-title">std::u16string</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Utf16Value();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">String::Utf8Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">size_t</span> length;
  napi_status status =
      napi_get_value_string_utf8(_env, _value, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;length);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-string">""</span>);

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> value;
  value.reserve(length + <span class="hljs-number">1</span>);
  value.resize(length);
  status = napi_get_value_string_utf8(
      _env, _value, &amp;value[<span class="hljs-number">0</span>], value.capacity(), <span class="hljs-literal">nullptr</span>);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-string">""</span>);
  <span class="hljs-keyword">return</span> value;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::u16string <span class="hljs-title">String::Utf16Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">size_t</span> length;
  napi_status status =
      napi_get_value_string_utf16(_env, _value, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, &amp;length);
  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(<span class="hljs-string">""</span>));

  <span class="hljs-built_in">std</span>::u16string value;
  value.reserve(length + <span class="hljs-number">1</span>);
  value.resize(length);
  status = napi_get_value_string_utf16(
      _env, _value, &amp;value[<span class="hljs-number">0</span>], value.capacity(), <span class="hljs-literal">nullptr</span>);
  NAPI_THROW_IF_FAILED(_env, status, NAPI_WIDE_TEXT(<span class="hljs-string">""</span>));
  <span class="hljs-keyword">return</span> value;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Symbol class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Symbol <span class="hljs-title">Symbol::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* description)</span> </span>{
  napi_value descriptionValue = description != <span class="hljs-literal">nullptr</span>
                                    ? <span class="hljs-keyword">String</span>::New(env, description)
                                    : <span class="hljs-keyword">static_cast</span>&lt;napi_value&gt;(<span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">return</span> Symbol::New(env, descriptionValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Symbol <span class="hljs-title">Symbol::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; description)</span> </span>{
  napi_value descriptionValue = <span class="hljs-keyword">String</span>::New(env, description);
  <span class="hljs-keyword">return</span> Symbol::New(env, descriptionValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Symbol <span class="hljs-title">Symbol::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">String</span> description)</span> </span>{
  napi_value descriptionValue = description;
  <span class="hljs-keyword">return</span> Symbol::New(env, descriptionValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Symbol <span class="hljs-title">Symbol::New</span><span class="hljs-params">(napi_env env, napi_value description)</span> </span>{
  napi_value value;
  napi_status status = napi_create_symbol(env, description, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Symbol());
  <span class="hljs-keyword">return</span> Symbol(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Symbol&gt; <span class="hljs-title">Symbol::WellKnown</span><span class="hljs-params">(napi_env env,
                                              <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name)</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(NODE_ADDON_API_ENABLE_MAYBE)</span>
  Value symbol_obj;
  Value symbol_value;
  <span class="hljs-keyword">if</span> (Napi::Env(env).Global().Get(<span class="hljs-string">"Symbol"</span>).UnwrapTo(&amp;symbol_obj) &amp;&amp;
      symbol_obj.As&lt;Object&gt;().Get(name).UnwrapTo(&amp;symbol_value)) {
    <span class="hljs-keyword">return</span> Just&lt;Symbol&gt;(symbol_value.As&lt;Symbol&gt;());
  }
  <span class="hljs-keyword">return</span> Nothing&lt;Symbol&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">return</span> Napi::Env(env)
      .Global()
      .Get(<span class="hljs-string">"Symbol"</span>)
      .As&lt;Object&gt;()
      .Get(name)
      .As&lt;Symbol&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Symbol&gt; <span class="hljs-title">Symbol::For</span><span class="hljs-params">(napi_env env,
                                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; description)</span> </span>{
  napi_value descriptionValue = <span class="hljs-keyword">String</span>::New(env, description);
  <span class="hljs-keyword">return</span> Symbol::For(env, descriptionValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Symbol&gt; <span class="hljs-title">Symbol::For</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* description)</span> </span>{
  napi_value descriptionValue = <span class="hljs-keyword">String</span>::New(env, description);
  <span class="hljs-keyword">return</span> Symbol::For(env, descriptionValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Symbol&gt; <span class="hljs-title">Symbol::For</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">String</span> description)</span> </span>{
  <span class="hljs-keyword">return</span> Symbol::For(env, <span class="hljs-keyword">static_cast</span>&lt;napi_value&gt;(description));
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Symbol&gt; <span class="hljs-title">Symbol::For</span><span class="hljs-params">(napi_env env, napi_value description)</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(NODE_ADDON_API_ENABLE_MAYBE)</span>
  Value symbol_obj;
  Value symbol_for_value;
  Value symbol_value;
  <span class="hljs-keyword">if</span> (Napi::Env(env).Global().Get(<span class="hljs-string">"Symbol"</span>).UnwrapTo(&amp;symbol_obj) &amp;&amp;
      symbol_obj.As&lt;Object&gt;().Get(<span class="hljs-string">"for"</span>).UnwrapTo(&amp;symbol_for_value) &amp;&amp;
      symbol_for_value.As&lt;Function&gt;()
          .Call(symbol_obj, {description})
          .UnwrapTo(&amp;symbol_value)) {
    <span class="hljs-keyword">return</span> Just&lt;Symbol&gt;(symbol_value.As&lt;Symbol&gt;());
  }
  <span class="hljs-keyword">return</span> Nothing&lt;Symbol&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  Object symbol_obj = Napi::Env(env).Global().Get(<span class="hljs-string">"Symbol"</span>).As&lt;Object&gt;();
  <span class="hljs-keyword">return</span> symbol_obj.Get(<span class="hljs-string">"for"</span>)
      .As&lt;Function&gt;()
      .Call(symbol_obj, {description})
      .As&lt;Symbol&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Symbol::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Symbol::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Symbol::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_symbol, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"Symbol::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Symbol::Symbol</span><span class="hljs-params">()</span> : <span class="hljs-title">Name</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Symbol::Symbol</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Name</span><span class="hljs-params">(env, value)</span> </span>{}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Automagic value creation
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">namespace</span> details {
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_number</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> Number <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, T value)</span> </span>{
    <span class="hljs-keyword">return</span> Number::New(env, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(value));
  }
};

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_number</span>&lt;bool&gt; {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> Boolean <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">bool</span> value)</span> </span>{
    <span class="hljs-keyword">return</span> Boolean::New(env, value);
  }
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_utf8_charp</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, value);
  }
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_utf16_charp</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>* value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, value);
  }
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_utf8_string</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, value);
  }
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_utf16_string</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::u16string&amp; value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>::New(env, value);
  }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vf_fallback</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> Value <span class="hljs-title">From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> T&amp; value)</span> </span>{ <span class="hljs-keyword">return</span> Value(env, value); }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>...&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disjunction</span> :</span> <span class="hljs-built_in">std</span>::false_type {};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disjunction</span>&lt;B&gt; :</span> B {};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> B, <span class="hljs-keyword">typename</span>... Bs&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disjunction</span>&lt;B, Bs...&gt;
    :</span> <span class="hljs-built_in">std</span>::conditional&lt;<span class="hljs-keyword">bool</span>(B::value), B, disjunction&lt;Bs...&gt;&gt;::type {};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">can_make_string</span>
    :</span> disjunction&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;::type,
                  <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>*&gt;::type,
                  <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::type,
                  <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-built_in">std</span>::u16string&gt;::type&gt; {};
}  <span class="hljs-comment">// namespace details</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">Value <span class="hljs-title">Value::From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> T&amp; value)</span> </span>{
  <span class="hljs-keyword">using</span> Helper = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;
      <span class="hljs-built_in">std</span>::is_integral&lt;T&gt;::value || <span class="hljs-built_in">std</span>::is_floating_point&lt;T&gt;::value,
      details::vf_number&lt;T&gt;,
      <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;details::can_make_string&lt;T&gt;::value,
                                <span class="hljs-keyword">String</span>,
                                details::vf_fallback&lt;T&gt;&gt;::type&gt;::type;
  <span class="hljs-keyword">return</span> Helper::From(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">String</span> <span class="hljs-title">String::From</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> T&amp; value)</span> </span>{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dummy</span> {</span>};
  <span class="hljs-keyword">using</span> Helper = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;
      <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;::value,
      details::vf_utf8_charp,
      <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;
          <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>*&gt;::value,
          details::vf_utf16_charp,
          <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;
              <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;::value,
              details::vf_utf8_string,
              <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::conditional&lt;
                  <span class="hljs-built_in">std</span>::is_convertible&lt;T, <span class="hljs-built_in">std</span>::u16string&gt;::value,
                  details::vf_utf16_string,
                  Dummy&gt;::type&gt;::type&gt;::type&gt;::type;
  <span class="hljs-keyword">return</span> Helper::From(env, value);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
TypeTaggable class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">TypeTaggable::TypeTaggable</span><span class="hljs-params">()</span> : <span class="hljs-title">Value</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">TypeTaggable::TypeTaggable</span><span class="hljs-params">(napi_env _env, napi_value _value)</span>
    : <span class="hljs-title">Value</span><span class="hljs-params">(_env, _value)</span> </span>{}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt;= 8</span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TypeTaggable::TypeTag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> napi_type_tag* type_tag)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_type_tag_object(_env, _value, type_tag);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TypeTaggable::CheckTypeTag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> napi_type_tag* type_tag)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status =
      napi_check_object_type_tag(_env, _value, type_tag, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt;= 8</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Object class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key&gt;
<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;Key&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  MaybeOrValue&lt;Value&gt; val = Object(_env, _object).Get(_key);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">return</span> val.Unwrap();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">return</span> val;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;Key&gt;&amp; Object::PropertyLValue&lt;Key&gt;::<span class="hljs-keyword">operator</span>=(
    ValueType value) {
#ifdef NODE_ADDON_API_ENABLE_MAYBE
  MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; result =
#endif
      Object(_env, _object).Set(_key, value);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  result.Unwrap();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key&gt;
<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;Key&gt;::PropertyLValue(Object object, Key key)
    : _env(object.Env()), _object(object), _key(key) {}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Object <span class="hljs-title">Object::New</span><span class="hljs-params">(napi_env env)</span> </span>{
  napi_value value;
  napi_status status = napi_create_object(env, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Object());
  <span class="hljs-keyword">return</span> Object(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Object::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Object::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_object, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"Object::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Object::Object</span><span class="hljs-params">()</span> : <span class="hljs-title">TypeTaggable</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Object::Object</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">TypeTaggable</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; Object::<span class="hljs-keyword">operator</span>[](
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name) {
  <span class="hljs-keyword">return</span> PropertyLValue&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(*<span class="hljs-keyword">this</span>, utf8name);
}

<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; Object::<span class="hljs-keyword">operator</span>[](
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name) {
  <span class="hljs-keyword">return</span> PropertyLValue&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(*<span class="hljs-keyword">this</span>, utf8name);
}

<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;<span class="hljs-keyword">uint32_t</span>&gt; Object::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">uint32_t</span> index) {
  <span class="hljs-keyword">return</span> PropertyLValue&lt;<span class="hljs-keyword">uint32_t</span>&gt;(*<span class="hljs-keyword">this</span>, index);
}

<span class="hljs-keyword">inline</span> Object::PropertyLValue&lt;Value&gt; Object::<span class="hljs-keyword">operator</span>[](Value index) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> PropertyLValue&lt;Value&gt;(*<span class="hljs-keyword">this</span>, index);
}

<span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; Object::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Get(utf8name);
}

<span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; Object::<span class="hljs-keyword">operator</span>[](
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Get(utf8name);
}

<span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; Object::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">uint32_t</span> index) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Get(index);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Has</span><span class="hljs-params">(napi_value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Has</span><span class="hljs-params">(Value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Has</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_named_property(_env, _value, utf8name, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Has</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Has(utf8name.c_str());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::HasOwnProperty</span><span class="hljs-params">(napi_value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_own_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::HasOwnProperty</span><span class="hljs-params">(Value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_own_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::HasOwnProperty</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value key;
  napi_status status =
      napi_create_string_utf8(_env, utf8name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(utf8name), &amp;key);
  NAPI_MAYBE_THROW_IF_FAILED(_env, status, <span class="hljs-keyword">bool</span>);
  <span class="hljs-keyword">return</span> HasOwnProperty(key);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::HasOwnProperty</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> HasOwnProperty(utf8name.c_str());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Object::Get</span><span class="hljs-params">(napi_value key)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status = napi_get_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Object::Get</span><span class="hljs-params">(Value key)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status = napi_get_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Object::Get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status = napi_get_named_property(_env, _value, utf8name, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, result), Value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Object::Get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Get(utf8name.c_str());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Set</span><span class="hljs-params">(napi_value key,
                                      <span class="hljs-keyword">const</span> ValueType&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status =
      napi_set_property(_env, _value, key, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Set</span><span class="hljs-params">(Value key, <span class="hljs-keyword">const</span> ValueType&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status =
      napi_set_property(_env, _value, key, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                      <span class="hljs-keyword">const</span> ValueType&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status =
      napi_set_named_property(_env, _value, utf8name, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                      <span class="hljs-keyword">const</span> ValueType&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Set(utf8name.c_str(), value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Delete</span><span class="hljs-params">(napi_value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_delete_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Delete</span><span class="hljs-params">(Value key)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_delete_property(_env, _value, key, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Delete</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Delete(<span class="hljs-keyword">String</span>::New(_env, utf8name));
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Delete</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Delete(<span class="hljs-keyword">String</span>::New(_env, utf8name));
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Has</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_has_element(_env, _value, index, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Object::Get</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value value;
  napi_status status = napi_get_element(_env, _value, index, &amp;value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Value(_env, value), Value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ValueType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                      <span class="hljs-keyword">const</span> ValueType&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status =
      napi_set_element(_env, _value, index, Value::From(_env, value));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Delete</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_delete_element(_env, _value, index, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Array&gt; <span class="hljs-title">Object::GetPropertyNames</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status = napi_get_property_names(_env, _value, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, Array(_env, result), Array);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::DefineProperty</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> PropertyDescriptor&amp; property)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_define_properties(
      _env,
      _value,
      <span class="hljs-number">1</span>,
      <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> napi_property_descriptor*&gt;(&amp;property));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::DefineProperties</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;PropertyDescriptor&gt;&amp; properties)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_define_properties(
      _env,
      _value,
      properties.<span class="hljs-built_in">size</span>(),
      <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> napi_property_descriptor*&gt;(properties.<span class="hljs-built_in">begin</span>()));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::DefineProperties</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyDescriptor&gt;&amp; properties)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_define_properties(
      _env,
      _value,
      properties.<span class="hljs-built_in">size</span>(),
      <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> napi_property_descriptor*&gt;(properties.data()));
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::InstanceOf</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> Function&amp; constructor)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_instanceof(_env, _value, constructor, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, result, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::AddFinalizer</span><span class="hljs-params">(Finalizer finalizeCallback, T* data)</span> <span class="hljs-keyword">const</span> </span>{
  details::FinalizeData&lt;T, Finalizer&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), <span class="hljs-literal">nullptr</span>});
  napi_status status =
      details::AttachData&lt;T, details::FinalizeData&lt;T, Finalizer&gt;::Wrapper&gt;(
          _env, *<span class="hljs-keyword">this</span>, data, finalizeData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Hint&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::AddFinalizer</span><span class="hljs-params">(Finalizer finalizeCallback,
                                 T* data,
                                 Hint* finalizeHint)</span> <span class="hljs-keyword">const</span> </span>{
  details::FinalizeData&lt;T, Finalizer, Hint&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer, Hint&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), finalizeHint});
  napi_status status = details::
      AttachData&lt;T, details::FinalizeData&lt;T, Finalizer, Hint&gt;::WrapperWithHint&gt;(
          _env, *<span class="hljs-keyword">this</span>, data, finalizeData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
<span class="hljs-keyword">inline</span> Object::const_iterator::const_iterator(<span class="hljs-keyword">const</span> Object* object,
                                              <span class="hljs-keyword">const</span> Type type) {
  _object = object;
  _keys = object-&gt;GetPropertyNames();
  _index = type == Type::BEGIN ? <span class="hljs-number">0</span> : _keys.Length();
}

<span class="hljs-keyword">inline</span> Object::const_iterator Napi::Object::<span class="hljs-built_in">begin</span>() <span class="hljs-keyword">const</span> {
  <span class="hljs-function">const_iterator <span class="hljs-title">it</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Object::const_iterator::Type::BEGIN)</span></span>;
  <span class="hljs-keyword">return</span> it;
}

<span class="hljs-keyword">inline</span> Object::const_iterator Napi::Object::<span class="hljs-built_in">end</span>() <span class="hljs-keyword">const</span> {
  <span class="hljs-function">const_iterator <span class="hljs-title">it</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Object::const_iterator::Type::END)</span></span>;
  <span class="hljs-keyword">return</span> it;
}

<span class="hljs-keyword">inline</span> Object::const_iterator&amp; Object::const_iterator::<span class="hljs-keyword">operator</span>++() {
  ++_index;
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Object::const_iterator::<span class="hljs-keyword">operator</span>==(
    <span class="hljs-keyword">const</span> const_iterator&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _index == other._index;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Object::const_iterator::<span class="hljs-keyword">operator</span>!=(
    <span class="hljs-keyword">const</span> const_iterator&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _index != other._index;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::pair&lt;Value, Object::PropertyLValue&lt;Value&gt;&gt;
Object::const_iterator::<span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">const</span> Value key = _keys[_index];
  <span class="hljs-keyword">const</span> PropertyLValue&lt;Value&gt; value = (*_object)[key];
  <span class="hljs-keyword">return</span> {key, value};
}

<span class="hljs-keyword">inline</span> Object::iterator::iterator(Object* object, <span class="hljs-keyword">const</span> Type type) {
  _object = object;
  _keys = object-&gt;GetPropertyNames();
  _index = type == Type::BEGIN ? <span class="hljs-number">0</span> : _keys.Length();
}

<span class="hljs-keyword">inline</span> Object::iterator Napi::Object::<span class="hljs-built_in">begin</span>() {
  <span class="hljs-function">iterator <span class="hljs-title">it</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Object::iterator::Type::BEGIN)</span></span>;
  <span class="hljs-keyword">return</span> it;
}

<span class="hljs-keyword">inline</span> Object::iterator Napi::Object::<span class="hljs-built_in">end</span>() {
  <span class="hljs-function">iterator <span class="hljs-title">it</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, Object::iterator::Type::END)</span></span>;
  <span class="hljs-keyword">return</span> it;
}

<span class="hljs-keyword">inline</span> Object::iterator&amp; Object::iterator::<span class="hljs-keyword">operator</span>++() {
  ++_index;
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Object::iterator::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> iterator&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _index == other._index;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Object::iterator::<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> iterator&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _index != other._index;
}

<span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::pair&lt;Value, Object::PropertyLValue&lt;Value&gt;&gt;
Object::iterator::<span class="hljs-keyword">operator</span>*() {
  Value key = _keys[_index];
  PropertyLValue&lt;Value&gt; value = (*_object)[key];
  <span class="hljs-keyword">return</span> {key, value};
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt;= 8</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Freeze</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_object_freeze(_env, _value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">Object::Seal</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status = napi_object_seal(_env, _value);
  NAPI_RETURN_OR_THROW_IF_FAILED(_env, status, status == napi_ok, <span class="hljs-keyword">bool</span>);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt;= 8</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
External class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> External&lt;T&gt; External&lt;T&gt;::New(napi_env env, T* data) {
  napi_value value;
  napi_status status =
      napi_create_external(env, data, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, External());
  <span class="hljs-keyword">return</span> External(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-keyword">inline</span> External&lt;T&gt; External&lt;T&gt;::New(napi_env env,
                                    T* data,
                                    Finalizer finalizeCallback) {
  napi_value value;
  details::FinalizeData&lt;T, Finalizer&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), <span class="hljs-literal">nullptr</span>});
  napi_status status =
      napi_create_external(env,
                           data,
                           details::PostFinalizerWrapper&lt;
                               details::FinalizeData&lt;T, Finalizer&gt;::Wrapper&gt;,
                           finalizeData,
                           &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, External());
  }
  <span class="hljs-keyword">return</span> External(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> Hint&gt;
<span class="hljs-keyword">inline</span> External&lt;T&gt; External&lt;T&gt;::New(napi_env env,
                                    T* data,
                                    Finalizer finalizeCallback,
                                    Hint* finalizeHint) {
  napi_value value;
  details::FinalizeData&lt;T, Finalizer, Hint&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer, Hint&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), finalizeHint});
  napi_status status = napi_create_external(
      env,
      data,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;T, Finalizer, Hint&gt;::WrapperWithHint&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, External());
  }
  <span class="hljs-keyword">return</span> External(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> External&lt;T&gt;::CheckCast(napi_env env, napi_value value) {
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"External::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"External::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_external, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"External::CheckCast"</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> External&lt;T&gt;::External() : TypeTaggable() {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> External&lt;T&gt;::External(napi_env env, napi_value value)
    : TypeTaggable(env, value) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T* External&lt;T&gt;::Data() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">void</span>* data;
  napi_status status = napi_get_value_external(_env, _value, &amp;data);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(data);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Array class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Array <span class="hljs-title">Array::New</span><span class="hljs-params">(napi_env env)</span> </span>{
  napi_value value;
  napi_status status = napi_create_array(env, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Array());
  <span class="hljs-keyword">return</span> Array(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Array <span class="hljs-title">Array::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">size_t</span> length)</span> </span>{
  napi_value value;
  napi_status status = napi_create_array_with_length(env, length, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Array());
  <span class="hljs-keyword">return</span> Array(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Array::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Array::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_array(env, value, &amp;result);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Array::CheckCast"</span>, <span class="hljs-string">"napi_is_array failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"Array::CheckCast"</span>, <span class="hljs-string">"value is not array"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Array::Array</span><span class="hljs-params">()</span> : <span class="hljs-title">Object</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Array::Array</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Object</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Array::Length</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">uint32_t</span> result;
  napi_status status = napi_get_array_length(_env, _value, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
ArrayBuffer class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> ArrayBuffer <span class="hljs-title">ArrayBuffer::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">size_t</span> byteLength)</span> </span>{
  napi_value value;
  <span class="hljs-keyword">void</span>* data;
  napi_status status = napi_create_arraybuffer(env, byteLength, &amp;data, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());

  <span class="hljs-keyword">return</span> ArrayBuffer(env, value);
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> ArrayBuffer <span class="hljs-title">ArrayBuffer::New</span><span class="hljs-params">(napi_env env,
                                    <span class="hljs-keyword">void</span>* externalData,
                                    <span class="hljs-keyword">size_t</span> byteLength)</span> </span>{
  napi_value value;
  napi_status status = napi_create_external_arraybuffer(
      env, externalData, byteLength, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());

  <span class="hljs-keyword">return</span> ArrayBuffer(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ArrayBuffer <span class="hljs-title">ArrayBuffer::New</span><span class="hljs-params">(napi_env env,
                                    <span class="hljs-keyword">void</span>* externalData,
                                    <span class="hljs-keyword">size_t</span> byteLength,
                                    Finalizer finalizeCallback)</span> </span>{
  napi_value value;
  details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), <span class="hljs-literal">nullptr</span>});
  napi_status status = napi_create_external_arraybuffer(
      env,
      externalData,
      byteLength,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer&gt;::Wrapper&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());
  }

  <span class="hljs-keyword">return</span> ArrayBuffer(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> Hint&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ArrayBuffer <span class="hljs-title">ArrayBuffer::New</span><span class="hljs-params">(napi_env env,
                                    <span class="hljs-keyword">void</span>* externalData,
                                    <span class="hljs-keyword">size_t</span> byteLength,
                                    Finalizer finalizeCallback,
                                    Hint* finalizeHint)</span> </span>{
  napi_value value;
  details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer, Hint&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer, Hint&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), finalizeHint});
  napi_status status = napi_create_external_arraybuffer(
      env,
      externalData,
      byteLength,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;<span class="hljs-keyword">void</span>, Finalizer, Hint&gt;::WrapperWithHint&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ArrayBuffer());
  }

  <span class="hljs-keyword">return</span> ArrayBuffer(env, value);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ArrayBuffer::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"ArrayBuffer::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_arraybuffer(env, value, &amp;result);
  NAPI_CHECK(status == napi_ok,
             <span class="hljs-string">"ArrayBuffer::CheckCast"</span>,
             <span class="hljs-string">"napi_is_arraybuffer failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"ArrayBuffer::CheckCast"</span>, <span class="hljs-string">"value is not arraybuffer"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ArrayBuffer::ArrayBuffer</span><span class="hljs-params">()</span> : <span class="hljs-title">Object</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ArrayBuffer::ArrayBuffer</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Object</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">ArrayBuffer::Data</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">void</span>* data;
  napi_status status = napi_get_arraybuffer_info(_env, _value, &amp;data, <span class="hljs-literal">nullptr</span>);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ArrayBuffer::ByteLength</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">size_t</span> length;
  napi_status status =
      napi_get_arraybuffer_info(_env, _value, <span class="hljs-literal">nullptr</span>, &amp;length);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> length;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt;= 7</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ArrayBuffer::IsDetached</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">bool</span> detached;
  napi_status status = napi_is_detached_arraybuffer(_env, _value, &amp;detached);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> detached;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ArrayBuffer::Detach</span><span class="hljs-params">()</span> </span>{
  napi_status status = napi_detach_arraybuffer(_env, _value);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt;= 7</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
DataView class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> DataView <span class="hljs-title">DataView::New</span><span class="hljs-params">(napi_env env, Napi::ArrayBuffer arrayBuffer)</span> </span>{
  <span class="hljs-keyword">return</span> New(env, arrayBuffer, <span class="hljs-number">0</span>, arrayBuffer.ByteLength());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> DataView <span class="hljs-title">DataView::New</span><span class="hljs-params">(napi_env env,
                              Napi::ArrayBuffer arrayBuffer,
                              <span class="hljs-keyword">size_t</span> byteOffset)</span> </span>{
  <span class="hljs-keyword">if</span> (byteOffset &gt; arrayBuffer.ByteLength()) {
    NAPI_THROW(RangeError::New(
                   env, <span class="hljs-string">"Start offset is outside the bounds of the buffer"</span>),
               DataView());
  }
  <span class="hljs-keyword">return</span> New(
      env, arrayBuffer, byteOffset, arrayBuffer.ByteLength() - byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> DataView <span class="hljs-title">DataView::New</span><span class="hljs-params">(napi_env env,
                              Napi::ArrayBuffer arrayBuffer,
                              <span class="hljs-keyword">size_t</span> byteOffset,
                              <span class="hljs-keyword">size_t</span> byteLength)</span> </span>{
  <span class="hljs-keyword">if</span> (byteOffset + byteLength &gt; arrayBuffer.ByteLength()) {
    NAPI_THROW(RangeError::New(env, <span class="hljs-string">"Invalid DataView length"</span>), DataView());
  }
  napi_value value;
  napi_status status =
      napi_create_dataview(env, byteLength, arrayBuffer, byteOffset, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, DataView());
  <span class="hljs-keyword">return</span> DataView(env, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"DataView::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_dataview(env, value, &amp;result);
  NAPI_CHECK(
      status == napi_ok, <span class="hljs-string">"DataView::CheckCast"</span>, <span class="hljs-string">"napi_is_dataview failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"DataView::CheckCast"</span>, <span class="hljs-string">"value is not dataview"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">DataView::DataView</span><span class="hljs-params">()</span> : <span class="hljs-title">Object</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">DataView::DataView</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Object</span><span class="hljs-params">(env, value)</span> </span>{
  napi_status status = napi_get_dataview_info(_env,
                                              _value <span class="hljs-comment">/* dataView */</span>,
                                              &amp;_length <span class="hljs-comment">/* byteLength */</span>,
                                              &amp;_data <span class="hljs-comment">/* data */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* arrayBuffer */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* byteOffset */</span>);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Napi::ArrayBuffer <span class="hljs-title">DataView::ArrayBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value arrayBuffer;
  napi_status status = napi_get_dataview_info(_env,
                                              _value <span class="hljs-comment">/* dataView */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* byteLength */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* data */</span>,
                                              &amp;arrayBuffer <span class="hljs-comment">/* arrayBuffer */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* byteOffset */</span>);
  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());
  <span class="hljs-keyword">return</span> Napi::ArrayBuffer(_env, arrayBuffer);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">DataView::ByteOffset</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">size_t</span> byteOffset;
  napi_status status = napi_get_dataview_info(_env,
                                              _value <span class="hljs-comment">/* dataView */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* byteLength */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* data */</span>,
                                              <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* arrayBuffer */</span>,
                                              &amp;byteOffset <span class="hljs-comment">/* byteOffset */</span>);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> byteOffset;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">DataView::ByteLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _length;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">DataView::Data</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _data;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">float</span> <span class="hljs-title">DataView::GetFloat32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">float</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">DataView::GetFloat64</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">double</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int8_t</span> <span class="hljs-title">DataView::GetInt8</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">int8_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int16_t</span> <span class="hljs-title">DataView::GetInt16</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">int16_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">DataView::GetInt32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">int32_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint8_t</span> <span class="hljs-title">DataView::GetUint8</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">uint8_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">DataView::GetUint16</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">uint16_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">DataView::GetUint32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> ReadData&lt;<span class="hljs-keyword">uint32_t</span>&gt;(byteOffset);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetFloat32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">float</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">float</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetFloat64</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">double</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">double</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetInt8</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">int8_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">int8_t</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetInt16</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">int16_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">int16_t</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetInt32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">int32_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">int32_t</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetUint8</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">uint8_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">uint8_t</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetUint16</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">uint16_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">uint16_t</span>&gt;(byteOffset, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::SetUint32</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, <span class="hljs-keyword">uint32_t</span> value)</span> <span class="hljs-keyword">const</span> </span>{
  WriteData&lt;<span class="hljs-keyword">uint32_t</span>&gt;(byteOffset, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">DataView::ReadData</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (byteOffset + <span class="hljs-keyword">sizeof</span>(T) &gt; _length ||
      byteOffset + <span class="hljs-keyword">sizeof</span>(T) &lt; byteOffset) {  <span class="hljs-comment">// overflow</span>
    NAPI_THROW(
        RangeError::New(_env, <span class="hljs-string">"Offset is outside the bounds of the DataView"</span>),
        <span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(_data) + byteOffset);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DataView::WriteData</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> byteOffset, T value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (byteOffset + <span class="hljs-keyword">sizeof</span>(T) &gt; _length ||
      byteOffset + <span class="hljs-keyword">sizeof</span>(T) &lt; byteOffset) {  <span class="hljs-comment">// overflow</span>
    NAPI_THROW_VOID(
        RangeError::New(_env, <span class="hljs-string">"Offset is outside the bounds of the DataView"</span>));
  }

  *<span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(_data) + byteOffset) = value;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
TypedArray class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">inline void TypedArray::CheckCast(napi_env env, napi_value value) {
  NAPI_CHECK(value != nullptr, "TypedArray::CheckCast", "empty value");

  bool result;
  napi_status status = napi_is_typedarray(env, value, &amp;result);
  NAPI_CHECK(
      status == napi_ok, "TypedArray::CheckCast", "napi_is_typedarray failed");
  NAPI_CHECK(result, "TypedArray::CheckCast", "value is not typedarray");
}

inline TypedArray::TypedArray()
    : Object(), _type(napi_typedarray_type::napi_int8_array), _length(0) {}

inline TypedArray::TypedArray(napi_env env, napi_value value)
    : Object(env, value),
      _type(napi_typedarray_type::napi_int8_array),
      _length(0) {
  if (value != nullptr) {
    napi_status status =
        napi_get_typedarray_info(_env,
                                 _value,
                                 &amp;const_cast&lt;TypedArray*&gt;(this)-&gt;_type,
                                 &amp;const_cast&lt;TypedArray*&gt;(this)-&gt;_length,
                                 nullptr,
                                 nullptr,
                                 nullptr);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

inline TypedArray::TypedArray(napi_env env,
                              napi_value value,
                              napi_typedarray_type type,
                              size_t length)
    : Object(env, value), _type(type), _length(length) {}

inline napi_typedarray_type TypedArray::TypedArrayType() const {
  return _type;
}

inline uint8_t TypedArray::ElementSize() const {
  switch (_type) {
    case napi_int8_array:
    case napi_uint8_array:
    case napi_uint8_clamped_array:
      return 1;
    case napi_int16_array:
    case napi_uint16_array:
      return 2;
    case napi_int32_array:
    case napi_uint32_array:
    case napi_float32_array:
      return 4;
    case napi_float64_array:
#if (NAPI_VERSION &gt; 5)
    case napi_bigint64_array:
    case napi_biguint64_array:
#endif  // (NAPI_VERSION &gt; 5)
      return 8;
    default:
      return 0;
  }
}

inline size_t TypedArray::ElementLength() const {
  return _length;
}

inline size_t TypedArray::ByteOffset() const {
  size_t byteOffset;
  napi_status status = napi_get_typedarray_info(
      _env, _value, nullptr, nullptr, nullptr, nullptr, &amp;byteOffset);
  NAPI_THROW_IF_FAILED(_env, status, 0);
  return byteOffset;
}

inline size_t TypedArray::ByteLength() const {
  return ElementSize() * ElementLength();
}

inline Napi::ArrayBuffer TypedArray::ArrayBuffer() const {
  napi_value arrayBuffer;
  napi_status status = napi_get_typedarray_info(
      _env, _value, nullptr, nullptr, nullptr, &amp;arrayBuffer, nullptr);
  NAPI_THROW_IF_FAILED(_env, status, Napi::ArrayBuffer());
  return Napi::ArrayBuffer(_env, arrayBuffer);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
TypedArrayOf<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> TypedArrayOf&lt;T&gt;::CheckCast(napi_env env, napi_value value) {
  TypedArray::CheckCast(env, value);
  napi_typedarray_type type;
  napi_status status = napi_get_typedarray_info(
      env, value, &amp;type, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
  NAPI_CHECK(status == napi_ok,
             <span class="hljs-string">"TypedArrayOf::CheckCast"</span>,
             <span class="hljs-string">"napi_is_typedarray failed"</span>);

  NAPI_INTERNAL_CHECK(
      (type == TypedArrayTypeForPrimitiveType&lt;T&gt;() ||
       (type == napi_uint8_clamped_array &amp;&amp; <span class="hljs-built_in">std</span>::is_same&lt;T, <span class="hljs-keyword">uint8_t</span>&gt;::value)),
      <span class="hljs-string">"TypedArrayOf::CheckCast"</span>,
      <span class="hljs-string">"Array type must match the template parameter, (Uint8 arrays may "</span>
      <span class="hljs-string">"optionally have the \"clamped\" array type.), got %d."</span>,
      type);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> TypedArrayOf&lt;T&gt; TypedArrayOf&lt;T&gt;::New(napi_env env,
                                            <span class="hljs-keyword">size_t</span> elementLength,
                                            napi_typedarray_type type) {
  Napi::ArrayBuffer arrayBuffer =
      Napi::ArrayBuffer::New(env, elementLength * <span class="hljs-keyword">sizeof</span>(T));
  <span class="hljs-keyword">return</span> New(env, elementLength, arrayBuffer, <span class="hljs-number">0</span>, type);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> TypedArrayOf&lt;T&gt; TypedArrayOf&lt;T&gt;::New(napi_env env,
                                            <span class="hljs-keyword">size_t</span> elementLength,
                                            Napi::ArrayBuffer arrayBuffer,
                                            <span class="hljs-keyword">size_t</span> bufferOffset,
                                            napi_typedarray_type type) {
  napi_value value;
  napi_status status = napi_create_typedarray(
      env, type, elementLength, arrayBuffer, bufferOffset, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, TypedArrayOf&lt;T&gt;());

  <span class="hljs-keyword">return</span> TypedArrayOf&lt;T&gt;(
      env,
      value,
      type,
      elementLength,
      <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(arrayBuffer.Data()) +
                           bufferOffset));
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> TypedArrayOf&lt;T&gt;::TypedArrayOf() : TypedArray(), _data(<span class="hljs-literal">nullptr</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> TypedArrayOf&lt;T&gt;::TypedArrayOf(napi_env env, napi_value value)
    : TypedArray(env, value), _data(<span class="hljs-literal">nullptr</span>) {
  napi_status status = napi_ok;
  <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">void</span>* data = <span class="hljs-literal">nullptr</span>;
    status = napi_get_typedarray_info(
        _env, _value, &amp;_type, &amp;_length, &amp;data, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
    _data = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(data);
  } <span class="hljs-keyword">else</span> {
    _type = TypedArrayTypeForPrimitiveType&lt;T&gt;();
    _length = <span class="hljs-number">0</span>;
  }
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> TypedArrayOf&lt;T&gt;::TypedArrayOf(napi_env env,
                                     napi_value value,
                                     napi_typedarray_type type,
                                     <span class="hljs-keyword">size_t</span> length,
                                     T* data)
    : TypedArray(env, value, type, length), _data(data) {
  <span class="hljs-keyword">if</span> (!(type == TypedArrayTypeForPrimitiveType&lt;T&gt;() ||
        (type == napi_uint8_clamped_array &amp;&amp;
         <span class="hljs-built_in">std</span>::is_same&lt;T, <span class="hljs-keyword">uint8_t</span>&gt;::value))) {
    NAPI_THROW_VOID(TypeError::New(
        env,
        <span class="hljs-string">"Array type must match the template parameter. "</span>
        <span class="hljs-string">"(Uint8 arrays may optionally have the \"clamped\" array type.)"</span>));
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T&amp; TypedArrayOf&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) {
  <span class="hljs-keyword">return</span> _data[index];
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> T&amp; TypedArrayOf&lt;T&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _data[index];
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T* TypedArrayOf&lt;T&gt;::Data() {
  <span class="hljs-keyword">return</span> _data;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> T* TypedArrayOf&lt;T&gt;::Data() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _data;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Function class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CbData&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">CreateFunction</span><span class="hljs-params">(napi_env env,
                                  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                  napi_callback cb,
                                  CbData* data,
                                  napi_value* result)</span> </span>{
  napi_status status =
      napi_create_function(env, utf8name, NAPI_AUTO_LENGTH, cb, data, result);
  <span class="hljs-keyword">if</span> (status == napi_ok) {
    status = Napi::details::AttachData(env, *result, data);
  }

  <span class="hljs-keyword">return</span> status;
}

<span class="hljs-keyword">template</span> &lt;Function::VoidCallback cb&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_value result = <span class="hljs-literal">nullptr</span>;
  napi_status status = napi_create_function(env,
                                            utf8name,
                                            NAPI_AUTO_LENGTH,
                                            details::TemplatedVoidCallback&lt;cb&gt;,
                                            data,
                                            &amp;result);
  NAPI_THROW_IF_FAILED(env, status, Function());
  <span class="hljs-keyword">return</span> Function(env, result);
}

<span class="hljs-keyword">template</span> &lt;Function::Callback cb&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_value result = <span class="hljs-literal">nullptr</span>;
  napi_status status = napi_create_function(env,
                                            utf8name,
                                            NAPI_AUTO_LENGTH,
                                            details::TemplatedCallback&lt;cb&gt;,
                                            data,
                                            &amp;result);
  NAPI_THROW_IF_FAILED(env, status, Function());
  <span class="hljs-keyword">return</span> Function(env, result);
}

<span class="hljs-keyword">template</span> &lt;Function::VoidCallback cb&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env,
                              <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                              <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Function::New&lt;cb&gt;(env, utf8name.c_str(), data);
}

<span class="hljs-keyword">template</span> &lt;Function::Callback cb&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env,
                              <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                              <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Function::New&lt;cb&gt;(env, utf8name.c_str(), data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env,
                              Callable cb,
                              <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                              <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">using</span> ReturnType = <span class="hljs-keyword">decltype</span>(cb(CallbackInfo(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>)));
  <span class="hljs-keyword">using</span> CbData = details::CallbackData&lt;Callable, ReturnType&gt;;
  <span class="hljs-keyword">auto</span> callbackData = <span class="hljs-keyword">new</span> CbData{<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(cb), data};

  napi_value value;
  napi_status status =
      CreateFunction(env, utf8name, CbData::Wrapper, callbackData, &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> callbackData;
    NAPI_THROW_IF_FAILED(env, status, Function());
  }

  <span class="hljs-keyword">return</span> Function(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Function <span class="hljs-title">Function::New</span><span class="hljs-params">(napi_env env,
                              Callable cb,
                              <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                              <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> New(env, cb, utf8name.c_str(), data);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Function::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Function::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  napi_valuetype type;
  napi_status status = napi_typeof(env, value, &amp;type);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Function::CheckCast"</span>, <span class="hljs-string">"napi_typeof failed"</span>);
  NAPI_INTERNAL_CHECK_EQ(type, napi_function, <span class="hljs-string">"%d"</span>, <span class="hljs-string">"Function::CheckCast"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Function::Function</span><span class="hljs-params">()</span> : <span class="hljs-title">Object</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Function::Function</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Object</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::operator</span><span class="hljs-params">()</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(Env().Undefined(), args);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(Env().Undefined(), args);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(Env().Undefined(), args);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(Env().Undefined(), args);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> argc,
                                          <span class="hljs-keyword">const</span> napi_value* args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(Env().Undefined(), argc, args);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(recv, args.<span class="hljs-built_in">size</span>(), args.<span class="hljs-built_in">begin</span>());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Call(recv, args.<span class="hljs-built_in">size</span>(), args.data());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> argc = args.<span class="hljs-built_in">size</span>();
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> stackArgsCount = <span class="hljs-number">6</span>;
  napi_value stackArgs[stackArgsCount];
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt; heapArgs;
  napi_value* argv;
  <span class="hljs-keyword">if</span> (argc &lt;= stackArgsCount) {
    argv = stackArgs;
  } <span class="hljs-keyword">else</span> {
    heapArgs.resize(argc);
    argv = heapArgs.data();
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> index = <span class="hljs-number">0</span>; index &lt; argc; index++) {
    argv[index] = <span class="hljs-keyword">static_cast</span>&lt;napi_value&gt;(args[index]);
  }

  <span class="hljs-keyword">return</span> Call(recv, argc, argv);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::Call</span><span class="hljs-params">(napi_value recv,
                                          <span class="hljs-keyword">size_t</span> argc,
                                          <span class="hljs-keyword">const</span> napi_value* args)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status =
      napi_call_function(_env, recv, _value, argc, args, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Value(_env, result), Napi::Value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> MakeCallback(recv, args.<span class="hljs-built_in">size</span>(), args.<span class="hljs-built_in">begin</span>(), context);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> MakeCallback(recv, args.<span class="hljs-built_in">size</span>(), args.data(), context);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Value&gt; <span class="hljs-title">Function::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">size_t</span> argc,
    <span class="hljs-keyword">const</span> napi_value* args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status =
      napi_make_callback(_env, context, recv, _value, argc, args, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Value(_env, result), Napi::Value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Object&gt; <span class="hljs-title">Function::New</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> New(args.<span class="hljs-built_in">size</span>(), args.<span class="hljs-built_in">begin</span>());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Object&gt; <span class="hljs-title">Function::New</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> New(args.<span class="hljs-built_in">size</span>(), args.data());
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Object&gt; <span class="hljs-title">Function::New</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> argc,
                                          <span class="hljs-keyword">const</span> napi_value* args)</span> <span class="hljs-keyword">const</span> </span>{
  napi_value result;
  napi_status status = napi_new_instance(_env, _value, argc, args, &amp;result);
  NAPI_RETURN_OR_THROW_IF_FAILED(
      _env, status, Napi::Object(_env, result), Napi::Object);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Promise class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">inline</span> Promise::Deferred Promise::Deferred::New(napi_env env) {
  <span class="hljs-keyword">return</span> Promise::Deferred(env);
}

<span class="hljs-keyword">inline</span> Promise::Deferred::Deferred(napi_env env) : _env(env) {
  napi_status status = napi_create_promise(_env, &amp;_deferred, &amp;_promise);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-keyword">inline</span> Promise Promise::Deferred::Promise() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Napi::Promise(_env, _promise);
}

<span class="hljs-keyword">inline</span> Napi::Env Promise::Deferred::Env() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Napi::Env(_env);
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Promise::Deferred::Resolve(napi_value value) <span class="hljs-keyword">const</span> {
  napi_status status = napi_resolve_deferred(_env, _deferred, value);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Promise::Deferred::Reject(napi_value value) <span class="hljs-keyword">const</span> {
  napi_status status = napi_reject_deferred(_env, _deferred, value);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Promise::CheckCast</span><span class="hljs-params">(napi_env env, napi_value value)</span> </span>{
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Promise::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_promise(env, value, &amp;result);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Promise::CheckCast"</span>, <span class="hljs-string">"napi_is_promise failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"Promise::CheckCast"</span>, <span class="hljs-string">"value is not promise"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Promise::Promise</span><span class="hljs-params">(napi_env env, napi_value value)</span> : <span class="hljs-title">Object</span><span class="hljs-params">(env, value)</span> </span>{}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Buffer<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::New(napi_env env, <span class="hljs-keyword">size_t</span> length) {
  napi_value value;
  <span class="hljs-keyword">void</span>* data;
  napi_status status =
      napi_create_buffer(env, length * <span class="hljs-keyword">sizeof</span>(T), &amp;data, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Buffer&lt;T&gt;());
  <span class="hljs-keyword">return</span> Buffer(env, value);
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::New(napi_env env, T* data, <span class="hljs-keyword">size_t</span> length) {
  napi_value value;
  napi_status status = napi_create_external_buffer(
      env, length * <span class="hljs-keyword">sizeof</span>(T), data, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Buffer&lt;T&gt;());
  <span class="hljs-keyword">return</span> Buffer(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::New(napi_env env,
                                T* data,
                                <span class="hljs-keyword">size_t</span> length,
                                Finalizer finalizeCallback) {
  napi_value value;
  details::FinalizeData&lt;T, Finalizer&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), <span class="hljs-literal">nullptr</span>});
  napi_status status = napi_create_external_buffer(
      env,
      length * <span class="hljs-keyword">sizeof</span>(T),
      data,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;T, Finalizer&gt;::Wrapper&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, Buffer());
  }
  <span class="hljs-keyword">return</span> Buffer(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> Hint&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::New(napi_env env,
                                T* data,
                                <span class="hljs-keyword">size_t</span> length,
                                Finalizer finalizeCallback,
                                Hint* finalizeHint) {
  napi_value value;
  details::FinalizeData&lt;T, Finalizer, Hint&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer, Hint&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), finalizeHint});
  napi_status status = napi_create_external_buffer(
      env,
      length * <span class="hljs-keyword">sizeof</span>(T),
      data,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;T, Finalizer, Hint&gt;::WrapperWithHint&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, Buffer());
  }
  <span class="hljs-keyword">return</span> Buffer(env, value);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::NewOrCopy(napi_env env, T* data, <span class="hljs-keyword">size_t</span> length) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  napi_value value;
  napi_status status = napi_create_external_buffer(
      env, length * <span class="hljs-keyword">sizeof</span>(T), data, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, &amp;value);
  <span class="hljs-keyword">if</span> (status == details::napi_no_external_buffers_allowed) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>If we can't create an external buffer, we'll just copy the data.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">return</span> Buffer&lt;T&gt;::Copy(env, data, length);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  }
  NAPI_THROW_IF_FAILED(env, status, Buffer&lt;T&gt;());
  <span class="hljs-keyword">return</span> Buffer(env, value);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::NewOrCopy(napi_env env,
                                      T* data,
                                      <span class="hljs-keyword">size_t</span> length,
                                      Finalizer finalizeCallback) {
  details::FinalizeData&lt;T, Finalizer&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), <span class="hljs-literal">nullptr</span>});
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  napi_value value;
  napi_status status = napi_create_external_buffer(
      env,
      length * <span class="hljs-keyword">sizeof</span>(T),
      data,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;T, Finalizer&gt;::Wrapper&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status == details::napi_no_external_buffers_allowed) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>If we can't create an external buffer, we'll just copy the data.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    Buffer&lt;T&gt; ret = Buffer&lt;T&gt;::Copy(env, data, length);
    details::FinalizeData&lt;T, Finalizer&gt;::Wrapper(env, data, finalizeData);
    <span class="hljs-keyword">return</span> ret;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  }
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, Buffer());
  }
  <span class="hljs-keyword">return</span> Buffer(env, value);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span></span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Finalizer, <span class="hljs-keyword">typename</span> Hint&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::NewOrCopy(napi_env env,
                                      T* data,
                                      <span class="hljs-keyword">size_t</span> length,
                                      Finalizer finalizeCallback,
                                      Hint* finalizeHint) {
  details::FinalizeData&lt;T, Finalizer, Hint&gt;* finalizeData =
      <span class="hljs-keyword">new</span> details::FinalizeData&lt;T, Finalizer, Hint&gt;(
          {<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(finalizeCallback), finalizeHint});
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  napi_value value;
  napi_status status = napi_create_external_buffer(
      env,
      length * <span class="hljs-keyword">sizeof</span>(T),
      data,
      details::PostFinalizerWrapper&lt;
          details::FinalizeData&lt;T, Finalizer, Hint&gt;::WrapperWithHint&gt;,
      finalizeData,
      &amp;value);
  <span class="hljs-keyword">if</span> (status == details::napi_no_external_buffers_allowed) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>If we can't create an external buffer, we'll just copy the data.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    Buffer&lt;T&gt; ret = Buffer&lt;T&gt;::Copy(env, data, length);
    details::FinalizeData&lt;T, Finalizer, Hint&gt;::WrapperWithHint(
        env, data, finalizeData);
    <span class="hljs-keyword">return</span> ret;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NODE_API_NO_EXTERNAL_BUFFERS_ALLOWED</span>
  }
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, Buffer());
  }
  <span class="hljs-keyword">return</span> Buffer(env, value);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt; Buffer&lt;T&gt;::Copy(napi_env env, <span class="hljs-keyword">const</span> T* data, <span class="hljs-keyword">size_t</span> length) {
  napi_value value;
  napi_status status =
      napi_create_buffer_copy(env, length * <span class="hljs-keyword">sizeof</span>(T), data, <span class="hljs-literal">nullptr</span>, &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Buffer&lt;T&gt;());
  <span class="hljs-keyword">return</span> Buffer&lt;T&gt;(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Buffer&lt;T&gt;::CheckCast(napi_env env, napi_value value) {
  NAPI_CHECK(value != <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"Buffer::CheckCast"</span>, <span class="hljs-string">"empty value"</span>);

  <span class="hljs-keyword">bool</span> result;
  napi_status status = napi_is_buffer(env, value, &amp;result);
  NAPI_CHECK(status == napi_ok, <span class="hljs-string">"Buffer::CheckCast"</span>, <span class="hljs-string">"napi_is_buffer failed"</span>);
  NAPI_CHECK(result, <span class="hljs-string">"Buffer::CheckCast"</span>, <span class="hljs-string">"value is not buffer"</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt;::Buffer() : Uint8Array() {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Buffer&lt;T&gt;::Buffer(napi_env env, napi_value value)
    : Uint8Array(env, value) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> Buffer&lt;T&gt;::Length() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> ByteLength() / <span class="hljs-keyword">sizeof</span>(T);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T* Buffer&lt;T&gt;::Data() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;T*&gt;(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(Uint8Array::Data()));
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Error class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> Error <span class="hljs-title">Error::New</span><span class="hljs-params">(napi_env env)</span> </span>{
  napi_status status;
  napi_value error = <span class="hljs-literal">nullptr</span>;
  <span class="hljs-keyword">bool</span> is_exception_pending;
  napi_extended_error_info last_error_info_copy;

  {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>We must retrieve the last error info before doing anything else because
doing anything else will replace the last error info.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">const</span> napi_extended_error_info* last_error_info;
    status = napi_get_last_error_info(env, &amp;last_error_info);
    NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::New"</span>, <span class="hljs-string">"napi_get_last_error_info"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<p>All fields of the <code>napi_extended_error_info</code> structure gets reset in
subsequent Node-API function calls on the same <code>env</code>. This includes a
call to <code>napi_is_exception_pending()</code>. So here it is necessary to make a
copy of the information as the <code>error_code</code> field is used later on.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-built_in">memcpy</span>(&amp;last_error_info_copy,
           last_error_info,
           <span class="hljs-keyword">sizeof</span>(napi_extended_error_info));
  }

  status = napi_is_exception_pending(env, &amp;is_exception_pending);
  NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::New"</span>, <span class="hljs-string">"napi_is_exception_pending"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<p>A pending exception takes precedence over any internal error status.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (is_exception_pending) {
    status = napi_get_and_clear_last_exception(env, &amp;error);
    NAPI_FATAL_IF_FAILED(
        status, <span class="hljs-string">"Error::New"</span>, <span class="hljs-string">"napi_get_and_clear_last_exception"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* error_message = last_error_info_copy.error_message != <span class="hljs-literal">nullptr</span>
                                    ? last_error_info_copy.error_message
                                    : <span class="hljs-string">"Error in native callback"</span>;

    napi_value message;
    status = napi_create_string_utf8(
        env, error_message, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(error_message), &amp;message);
    NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::New"</span>, <span class="hljs-string">"napi_create_string_utf8"</span>);

    <span class="hljs-keyword">switch</span> (last_error_info_copy.error_code) {
      <span class="hljs-keyword">case</span> napi_object_expected:
      <span class="hljs-keyword">case</span> napi_string_expected:
      <span class="hljs-keyword">case</span> napi_boolean_expected:
      <span class="hljs-keyword">case</span> napi_number_expected:
        status = napi_create_type_error(env, <span class="hljs-literal">nullptr</span>, message, &amp;error);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        status = napi_create_error(env, <span class="hljs-literal">nullptr</span>, message, &amp;error);
        <span class="hljs-keyword">break</span>;
    }
    NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::New"</span>, <span class="hljs-string">"napi_create_error"</span>);
  }

  <span class="hljs-keyword">return</span> Error(env, error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Error <span class="hljs-title">Error::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;Error&gt;(
      env, message, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(message), napi_create_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Error <span class="hljs-title">Error::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;Error&gt;(
      env, message.c_str(), message.<span class="hljs-built_in">size</span>(), napi_create_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> NAPI_NO_RETURN <span class="hljs-keyword">void</span> <span class="hljs-title">Error::Fatal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* location,
                                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>{
  napi_fatal_error(location, NAPI_AUTO_LENGTH, message, NAPI_AUTO_LENGTH);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Error::Error</span><span class="hljs-params">()</span> : <span class="hljs-title">ObjectReference</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Error::Error</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">ObjectReference</span><span class="hljs-params">(env, <span class="hljs-literal">nullptr</span>)</span> </span>{
  <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">nullptr</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>Attempting to create a reference on the error object.
If it's not a Object/Function/Symbol, this call will return an error
status.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    napi_status status = napi_create_reference(env, value, <span class="hljs-number">1</span>, &amp;_ref);

    <span class="hljs-keyword">if</span> (status != napi_ok) {
      napi_value wrappedErrorObj;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<p>Create an error object</p>

        </td>
        <td class="code highlight">
          <pre class="c">      status = napi_create_object(env, &amp;wrappedErrorObj);
      NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::Error"</span>, <span class="hljs-string">"napi_create_object"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<p>property flag that we attach to show the error object is wrapped</p>

        </td>
        <td class="code highlight">
          <pre class="c">      napi_property_descriptor wrapObjFlag = {
          ERROR_WRAP_VALUE(),  <span class="hljs-comment">// Unique GUID identifier since Symbol isn't a</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>viable option</p>

        </td>
        <td class="code highlight">
          <pre class="c">          <span class="hljs-literal">nullptr</span>,
          <span class="hljs-literal">nullptr</span>,
          <span class="hljs-literal">nullptr</span>,
          <span class="hljs-literal">nullptr</span>,
          Value::From(env, value),
          napi_enumerable,
          <span class="hljs-literal">nullptr</span>};

      status = napi_define_properties(env, wrappedErrorObj, <span class="hljs-number">1</span>, &amp;wrapObjFlag);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS</span>
      <span class="hljs-keyword">if</span> (status == napi_pending_exception) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<p>Test if the pending exception was reported because the environment is
shutting down. We assume that a status of napi_pending_exception
coupled with the absence of an actual pending exception means that
the environment is shutting down. If so, we replace the
napi_pending_exception status with napi_ok.</p>

        </td>
        <td class="code highlight">
          <pre class="c">        <span class="hljs-keyword">bool</span> is_exception_pending = <span class="hljs-literal">false</span>;
        status = napi_is_exception_pending(env, &amp;is_exception_pending);
        <span class="hljs-keyword">if</span> (status == napi_ok &amp;&amp; !is_exception_pending) {
          status = napi_ok;
        } <span class="hljs-keyword">else</span> {
          status = napi_pending_exception;
        }
      }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS</span></span>
      NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::Error"</span>, <span class="hljs-string">"napi_define_properties"</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<p>Create a reference on the newly wrapped object</p>

        </td>
        <td class="code highlight">
          <pre class="c">      status = napi_create_reference(env, wrappedErrorObj, <span class="hljs-number">1</span>, &amp;_ref);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<p>Avoid infinite recursion in the failure case.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    NAPI_FATAL_IF_FAILED(status, <span class="hljs-string">"Error::Error"</span>, <span class="hljs-string">"napi_create_reference"</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Object <span class="hljs-title">Error::Value</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (_ref == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span> Object(_env, <span class="hljs-literal">nullptr</span>);
  }

  napi_value refValue;
  napi_status status = napi_get_reference_value(_env, _ref, &amp;refValue);
  NAPI_THROW_IF_FAILED(_env, status, Object());

  napi_valuetype type;
  status = napi_typeof(_env, refValue, &amp;type);
  NAPI_THROW_IF_FAILED(_env, status, Object());

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<p>If refValue isn't a symbol, then we proceed to whether the refValue has the
wrapped error flag</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (type != napi_symbol) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<p>We are checking if the object is wrapped</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">bool</span> isWrappedObject = <span class="hljs-literal">false</span>;

    status = napi_has_property(_env,
                               refValue,
                               <span class="hljs-keyword">String</span>::From(_env, ERROR_WRAP_VALUE()),
                               &amp;isWrappedObject);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<p>Don't care about status</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">if</span> (isWrappedObject) {
      napi_value unwrappedValue;
      status = napi_get_property(_env,
                                 refValue,
                                 <span class="hljs-keyword">String</span>::From(_env, ERROR_WRAP_VALUE()),
                                 &amp;unwrappedValue);
      NAPI_THROW_IF_FAILED(_env, status, Object());

      <span class="hljs-keyword">return</span> Object(_env, unwrappedValue);
    }
  }

  <span class="hljs-keyword">return</span> Object(_env, refValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Error::Error</span><span class="hljs-params">(Error&amp;&amp; other)</span> : <span class="hljs-title">ObjectReference</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other))</span> </span>{}

<span class="hljs-keyword">inline</span> Error&amp; Error::<span class="hljs-keyword">operator</span>=(Error&amp;&amp; other) {
  <span class="hljs-keyword">static_cast</span>&lt;Reference&lt;Object&gt;*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">Error::Error</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Error&amp; other)</span> : <span class="hljs-title">ObjectReference</span><span class="hljs-params">(other)</span> </span>{}

<span class="hljs-keyword">inline</span> Error&amp; Error::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Error&amp; other) {
  Reset();

  _env = other.Env();
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;

  napi_value value = other.Value();
  <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_create_reference(_env, value, <span class="hljs-number">1</span>, &amp;_ref);
    NAPI_THROW_IF_FAILED(_env, status, *<span class="hljs-keyword">this</span>);
  }

  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-title">Error::Message</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">if</span> (_message.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> &amp;&amp; _env != <span class="hljs-literal">nullptr</span>) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
    <span class="hljs-keyword">try</span> {
      _message = Get(<span class="hljs-string">"message"</span>).As&lt;<span class="hljs-keyword">String</span>&gt;();
    } <span class="hljs-keyword">catch</span> (...) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<p>Catch all errors here, to include e.g. a std::bad_alloc from
the std::string::operator=, because this method may not throw.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(NODE_ADDON_API_ENABLE_MAYBE)</span>
    Napi::Value message_val;
    <span class="hljs-keyword">if</span> (Get(<span class="hljs-string">"message"</span>).UnwrapTo(&amp;message_val)) {
      _message = message_val.As&lt;<span class="hljs-keyword">String</span>&gt;();
    }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    _message = Get(<span class="hljs-string">"message"</span>).As&lt;<span class="hljs-keyword">String</span>&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
  }
  <span class="hljs-keyword">return</span> _message;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>we created an object on the &amp;_ref</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Error::ThrowAsJavaScriptException</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">if</span> (!IsEmpty()) {
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_API_SWALLOW_UNTHROWABLE_EXCEPTIONS</span>
    <span class="hljs-keyword">bool</span> pendingException = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>check if there is already a pending exception. If so don't try to throw a
new one as that is not allowed/possible</p>

        </td>
        <td class="code highlight">
          <pre class="c">    napi_status status = napi_is_exception_pending(_env, &amp;pendingException);

    <span class="hljs-keyword">if</span> ((status != napi_ok) ||
        ((status == napi_ok) &amp;&amp; (pendingException == <span class="hljs-literal">false</span>))) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<p>We intentionally don't use <code>NAPI_THROW_*</code> macros here to ensure
that there is no possible recursion as <code>ThrowAsJavaScriptException</code>
is part of <code>NAPI_THROW_*</code> macro definition for noexcept.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
      status = napi_throw(_env, Value());

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_EXPERIMENTAL</span>
      napi_status expected_failure_mode = napi_cannot_run_js;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
      napi_status expected_failure_mode = napi_pending_exception;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
      <span class="hljs-keyword">if</span> (status == expected_failure_mode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>The environment must be terminating as we checked earlier and there
was no pending exception. In this case continuing will result
in a fatal error and there is nothing the author has done incorrectly
in their code that is worth flagging through a fatal error</p>

        </td>
        <td class="code highlight">
          <pre class="c">        <span class="hljs-keyword">return</span>;
      }
    } <span class="hljs-keyword">else</span> {
      status = napi_pending_exception;
    }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<p>We intentionally don't use <code>NAPI_THROW_*</code> macros here to ensure
that there is no possible recursion as <code>ThrowAsJavaScriptException</code>
is part of <code>NAPI_THROW_*</code> macro definition for noexcept.</p>

        </td>
        <td class="code highlight">
          <pre class="c">
    napi_status status = napi_throw(_env, Value());
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
    <span class="hljs-keyword">if</span> (status != napi_ok) {
      <span class="hljs-keyword">throw</span> Error::New(_env);
    }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>   <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
    NAPI_FATAL_IF_FAILED(
        status, <span class="hljs-string">"Error::ThrowAsJavaScriptException"</span>, <span class="hljs-string">"napi_throw"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
  }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">Error::what</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> Message().c_str();
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">Error::ERROR_WRAP_VALUE</span><span class="hljs-params">()</span> NAPI_NOEXCEPT </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">"4bda9e7e-4913-4dbc-95de-891cbf66598e-errorVal"</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TError&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> TError <span class="hljs-title">Error::New</span><span class="hljs-params">(napi_env env,
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message,
                         <span class="hljs-keyword">size_t</span> length,
                         create_error_fn create_error)</span> </span>{
  napi_value str;
  napi_status status = napi_create_string_utf8(env, message, length, &amp;str);
  NAPI_THROW_IF_FAILED(env, status, TError());

  napi_value error;
  status = create_error(env, <span class="hljs-literal">nullptr</span>, str, &amp;error);
  NAPI_THROW_IF_FAILED(env, status, TError());

  <span class="hljs-keyword">return</span> TError(env, error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> TypeError <span class="hljs-title">TypeError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;TypeError&gt;(
      env, message, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(message), napi_create_type_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> TypeError <span class="hljs-title">TypeError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;TypeError&gt;(
      env, message.c_str(), message.<span class="hljs-built_in">size</span>(), napi_create_type_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">TypeError::TypeError</span><span class="hljs-params">()</span> : <span class="hljs-title">Error</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">TypeError::TypeError</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Error</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> RangeError <span class="hljs-title">RangeError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;RangeError&gt;(
      env, message, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(message), napi_create_range_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> RangeError <span class="hljs-title">RangeError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;RangeError&gt;(
      env, message.c_str(), message.<span class="hljs-built_in">size</span>(), napi_create_range_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">RangeError::RangeError</span><span class="hljs-params">()</span> : <span class="hljs-title">Error</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">RangeError::RangeError</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Error</span><span class="hljs-params">(env, value)</span> </span>{}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 8</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> SyntaxError <span class="hljs-title">SyntaxError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;SyntaxError&gt;(
      env, message, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">strlen</span>(message), node_api_create_syntax_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> SyntaxError <span class="hljs-title">SyntaxError::New</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; message)</span> </span>{
  <span class="hljs-keyword">return</span> Error::New&lt;SyntaxError&gt;(
      env, message.c_str(), message.<span class="hljs-built_in">size</span>(), node_api_create_syntax_error);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">SyntaxError::SyntaxError</span><span class="hljs-params">()</span> : <span class="hljs-title">Error</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">SyntaxError::SyntaxError</span><span class="hljs-params">(napi_env env, napi_value value)</span>
    : <span class="hljs-title">Error</span><span class="hljs-params">(env, value)</span> </span>{}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt; 8</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Reference<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt; Reference&lt;T&gt;::New(<span class="hljs-keyword">const</span> T&amp; value,
                                      <span class="hljs-keyword">uint32_t</span> initialRefcount) {
  napi_env env = value.Env();
  napi_value val = value;

  <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span> Reference&lt;T&gt;(env, <span class="hljs-literal">nullptr</span>);
  }

  napi_ref ref;
  napi_status status = napi_create_reference(env, value, initialRefcount, &amp;ref);
  NAPI_THROW_IF_FAILED(env, status, Reference&lt;T&gt;());

  <span class="hljs-keyword">return</span> Reference&lt;T&gt;(env, ref);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::Reference()
    : _env(<span class="hljs-literal">nullptr</span>), _ref(<span class="hljs-literal">nullptr</span>), _suppressDestruct(<span class="hljs-literal">false</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::Reference(napi_env env, napi_ref ref)
    : _env(env), _ref(ref), _suppressDestruct(<span class="hljs-literal">false</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::~Reference() {
  <span class="hljs-keyword">if</span> (_ref != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">if</span> (!_suppressDestruct) {
      napi_delete_reference(_env, _ref);
    }

    _ref = <span class="hljs-literal">nullptr</span>;
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::Reference(Reference&lt;T&gt;&amp;&amp; other)
    : _env(other._env),
      _ref(other._ref),
      _suppressDestruct(other._suppressDestruct) {
  other._env = <span class="hljs-literal">nullptr</span>;
  other._ref = <span class="hljs-literal">nullptr</span>;
  other._suppressDestruct = <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;&amp; Reference&lt;T&gt;::<span class="hljs-keyword">operator</span>=(Reference&lt;T&gt;&amp;&amp; other) {
  Reset();
  _env = other._env;
  _ref = other._ref;
  _suppressDestruct = other._suppressDestruct;
  other._env = <span class="hljs-literal">nullptr</span>;
  other._ref = <span class="hljs-literal">nullptr</span>;
  other._suppressDestruct = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::Reference(<span class="hljs-keyword">const</span> Reference&lt;T&gt;&amp; other)
    : _env(other._env), _ref(<span class="hljs-literal">nullptr</span>), _suppressDestruct(<span class="hljs-literal">false</span>) {
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;

  napi_value value = other.Value();
  <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">nullptr</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<p>Copying is a limited scenario (currently only used for Error object) and
always creates a strong reference to the given value even if the incoming
reference is weak.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    napi_status status = napi_create_reference(_env, value, <span class="hljs-number">1</span>, &amp;_ref);
    NAPI_FATAL_IF_FAILED(
        status, <span class="hljs-string">"Reference&lt;T&gt;::Reference"</span>, <span class="hljs-string">"napi_create_reference"</span>);
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Reference&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">napi_ref</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _ref;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Reference&lt;T&gt;::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Reference&lt;T&gt;&amp; other) <span class="hljs-keyword">const</span> {
  HandleScope scope(_env);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Value().StrictEquals(other.Value());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Reference&lt;T&gt;::<span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Reference&lt;T&gt;&amp; other) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>==(other);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Napi::Env Reference&lt;T&gt;::Env() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> Napi::Env(_env);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> Reference&lt;T&gt;::IsEmpty() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _ref == <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T Reference&lt;T&gt;::Value() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">if</span> (_ref == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span> T(_env, <span class="hljs-literal">nullptr</span>);
  }

  napi_value value;
  napi_status status = napi_get_reference_value(_env, _ref, &amp;value);
  NAPI_THROW_IF_FAILED(_env, status, T());
  <span class="hljs-keyword">return</span> T(_env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> Reference&lt;T&gt;::Ref() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">uint32_t</span> result;
  napi_status status = napi_reference_ref(_env, _ref, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> Reference&lt;T&gt;::Unref() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">uint32_t</span> result;
  napi_status status = napi_reference_unref(_env, _ref, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Reference&lt;T&gt;::Reset() {
  <span class="hljs-keyword">if</span> (_ref != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_delete_reference(_env, _ref);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
    _ref = <span class="hljs-literal">nullptr</span>;
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Reference&lt;T&gt;::Reset(<span class="hljs-keyword">const</span> T&amp; value, <span class="hljs-keyword">uint32_t</span> refcount) {
  Reset();
  _env = value.Env();

  napi_value val = value;
  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_create_reference(_env, value, refcount, &amp;_ref);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Reference&lt;T&gt;::SuppressDestruct() {
  _suppressDestruct = <span class="hljs-literal">true</span>;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Reference&lt;T&gt; <span class="hljs-title">Weak</span><span class="hljs-params">(T value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;T&gt;::New(value, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> ObjectReference <span class="hljs-title">Weak</span><span class="hljs-params">(Object value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;Object&gt;::New(value, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> FunctionReference <span class="hljs-title">Weak</span><span class="hljs-params">(Function value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;Function&gt;::New(value, <span class="hljs-number">0</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> Reference&lt;T&gt; <span class="hljs-title">Persistent</span><span class="hljs-params">(T value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;T&gt;::New(value, <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> ObjectReference <span class="hljs-title">Persistent</span><span class="hljs-params">(Object value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;Object&gt;::New(value, <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> FunctionReference <span class="hljs-title">Persistent</span><span class="hljs-params">(Function value)</span> </span>{
  <span class="hljs-keyword">return</span> Reference&lt;Function&gt;::New(value, <span class="hljs-number">1</span>);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
ObjectReference class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ObjectReference::ObjectReference</span><span class="hljs-params">()</span> : Reference&lt;Object&gt;<span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ObjectReference::ObjectReference</span><span class="hljs-params">(napi_env env, napi_ref ref)</span>
    : Reference&lt;Object&gt;<span class="hljs-params">(env, ref)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ObjectReference::ObjectReference</span><span class="hljs-params">(Reference&lt;Object&gt;&amp;&amp; other)</span>
    : Reference&lt;Object&gt;<span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other))</span> </span>{}

<span class="hljs-keyword">inline</span> ObjectReference&amp; ObjectReference::<span class="hljs-keyword">operator</span>=(Reference&lt;Object&gt;&amp;&amp; other) {
  <span class="hljs-keyword">static_cast</span>&lt;Reference&lt;Object&gt;*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ObjectReference::ObjectReference</span><span class="hljs-params">(ObjectReference&amp;&amp; other)</span>
    : Reference&lt;Object&gt;<span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other))</span> </span>{}

<span class="hljs-keyword">inline</span> ObjectReference&amp; ObjectReference::<span class="hljs-keyword">operator</span>=(ObjectReference&amp;&amp; other) {
  <span class="hljs-keyword">static_cast</span>&lt;Reference&lt;Object&gt;*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ObjectReference::ObjectReference</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ObjectReference&amp; other)</span>
    : Reference&lt;Object&gt;<span class="hljs-params">(other)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">ObjectReference::Get</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Get(utf8name);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">ObjectReference::Get</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Get(utf8name);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                               napi_value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                               Napi::Value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, utf8value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                               <span class="hljs-keyword">bool</span> boolValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, boolValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
                                               <span class="hljs-keyword">double</span> numberValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, numberValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                               napi_value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                               Napi::Value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, utf8value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                               <span class="hljs-keyword">bool</span> boolValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, boolValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
                                               <span class="hljs-keyword">double</span> numberValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(utf8name, numberValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">ObjectReference::Get</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Get(index);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                               napi_value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                               Napi::Value value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, utf8value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(
    <span class="hljs-keyword">uint32_t</span> index, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8value)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, utf8value);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                               <span class="hljs-keyword">bool</span> boolValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, boolValue);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ObjectReference::Set</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> index,
                                               <span class="hljs-keyword">double</span> numberValue)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  <span class="hljs-keyword">return</span> Value().Set(index, numberValue);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
FunctionReference class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">FunctionReference::FunctionReference</span><span class="hljs-params">()</span> : Reference&lt;Function&gt;<span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">FunctionReference::FunctionReference</span><span class="hljs-params">(napi_env env, napi_ref ref)</span>
    : Reference&lt;Function&gt;<span class="hljs-params">(env, ref)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">FunctionReference::FunctionReference</span><span class="hljs-params">(Reference&lt;Function&gt;&amp;&amp; other)</span>
    : Reference&lt;Function&gt;<span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other))</span> </span>{}

<span class="hljs-keyword">inline</span> FunctionReference&amp; FunctionReference::<span class="hljs-keyword">operator</span>=(
    Reference&lt;Function&gt;&amp;&amp; other) {
  <span class="hljs-keyword">static_cast</span>&lt;Reference&lt;Function&gt;*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">FunctionReference::FunctionReference</span><span class="hljs-params">(FunctionReference&amp;&amp; other)</span>
    : Reference&lt;Function&gt;<span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other))</span> </span>{}

<span class="hljs-keyword">inline</span> FunctionReference&amp; FunctionReference::<span class="hljs-keyword">operator</span>=(
    FunctionReference&amp;&amp; other) {
  <span class="hljs-keyword">static_cast</span>&lt;Reference&lt;Function&gt;*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other));
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::operator</span><span class="hljs-params">()</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value()(args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::Call</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Call(args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::Call</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Call(args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Call(recv, args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Call(recv, args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::Call</span><span class="hljs-params">(
    napi_value recv, <span class="hljs-keyword">size_t</span> argc, <span class="hljs-keyword">const</span> napi_value* args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().Call(recv, argc, args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().MakeCallback(recv, args, context);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }

  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result = Value().MakeCallback(recv, args, context);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Napi::Value&gt; <span class="hljs-title">FunctionReference::MakeCallback</span><span class="hljs-params">(
    napi_value recv,
    <span class="hljs-keyword">size_t</span> argc,
    <span class="hljs-keyword">const</span> napi_value* args,
    napi_async_context context)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Napi::Value&gt; result =
      Value().MakeCallback(recv, argc, args, context);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()));
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Value();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Object&gt; <span class="hljs-title">FunctionReference::New</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Object&gt; result = Value().New(args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()).As&lt;Object&gt;());
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Object();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result).As&lt;Object&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> MaybeOrValue&lt;Object&gt; <span class="hljs-title">FunctionReference::New</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt;&amp; args)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-function">EscapableHandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
  MaybeOrValue&lt;Object&gt; result = Value().New(args);
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NODE_ADDON_API_ENABLE_MAYBE</span>
  <span class="hljs-keyword">if</span> (result.IsJust()) {
    <span class="hljs-keyword">return</span> Just(scope.Escape(result.Unwrap()).As&lt;Object&gt;());
  }
  <span class="hljs-keyword">return</span> result;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">if</span> (scope.Env().IsExceptionPending()) {
    <span class="hljs-keyword">return</span> Object();
  }
  <span class="hljs-keyword">return</span> scope.Escape(result).As&lt;Object&gt;();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
CallbackInfo class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline CallbackInfo::CallbackInfo(napi_env env, napi_callback_info info)
    : _env(env),
      _info(info),
      _this(nullptr),
      _dynamicArgs(nullptr),
      _data(nullptr) {
  _argc = _staticArgCount;
  _argv = _staticArgs;
  napi_status status =
      napi_get_cb_info(env, info, &amp;_argc, _argv, &amp;_this, &amp;_data);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  if (_argc &gt; _staticArgCount) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<p>Use either a fixed-size array (on the stack) or a dynamically-allocated
array (on the heap) depending on the number of args.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    _dynamicArgs = <span class="hljs-keyword">new</span> napi_value[_argc];
    _argv = _dynamicArgs;

    status = napi_get_cb_info(env, info, &amp;_argc, _argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
    NAPI_THROW_IF_FAILED_VOID(_env, status);
  }
}

<span class="hljs-keyword">inline</span> CallbackInfo::~CallbackInfo() {
  <span class="hljs-keyword">if</span> (_dynamicArgs != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">delete</span>[] _dynamicArgs;
  }
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> CallbackInfo::<span class="hljs-keyword">operator</span> <span class="hljs-title">napi_callback_info</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _info;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Value <span class="hljs-title">CallbackInfo::NewTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  napi_value newTarget;
  napi_status status = napi_get_new_target(_env, _info, &amp;newTarget);
  NAPI_THROW_IF_FAILED(_env, status, Value());
  <span class="hljs-keyword">return</span> Value(_env, newTarget);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CallbackInfo::IsConstructCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> !NewTarget().IsEmpty();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Napi::Env <span class="hljs-title">CallbackInfo::Env</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> Napi::Env(_env);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">CallbackInfo::Length</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _argc;
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> Value CallbackInfo::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> index) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> index &lt; _argc ? Value(_env, _argv[index]) : Env().Undefined();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> Value <span class="hljs-title">CallbackInfo::This</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (_this == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span> Env().Undefined();
  }
  <span class="hljs-keyword">return</span> Object(_env, _this);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">CallbackInfo::Data</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _data;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallbackInfo::SetData</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* data)</span> </span>{
  _data = data;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
PropertyDescriptor class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_property_descriptor desc = napi_property_descriptor();

  desc.utf8name = utf8name;
  desc.getter = details::TemplatedCallback&lt;Getter&gt;;
  desc.attributes = attributes;
  desc.data = data;

  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Accessor&lt;Getter&gt;(utf8name.c_str(), attributes, data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Name name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_property_descriptor desc = napi_property_descriptor();

  desc.name = name;
  desc.getter = details::TemplatedCallback&lt;Getter&gt;;
  desc.attributes = attributes;
  desc.data = data;

  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter,
          <span class="hljs-keyword">typename</span> PropertyDescriptor::SetterCallback Setter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_property_descriptor desc = napi_property_descriptor();

  desc.utf8name = utf8name;
  desc.getter = details::TemplatedCallback&lt;Getter&gt;;
  desc.setter = details::TemplatedVoidCallback&lt;Setter&gt;;
  desc.attributes = attributes;
  desc.data = data;

  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter,
          <span class="hljs-keyword">typename</span> PropertyDescriptor::SetterCallback Setter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Accessor&lt;Getter, Setter&gt;(utf8name.c_str(), attributes, data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PropertyDescriptor::GetterCallback Getter,
          <span class="hljs-keyword">typename</span> PropertyDescriptor::SetterCallback Setter&gt;
<span class="hljs-function">PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Name name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data)</span> </span>{
  napi_property_descriptor desc = napi_property_descriptor();

  desc.name = name;
  desc.getter = details::TemplatedCallback&lt;Getter&gt;;
  desc.setter = details::TemplatedVoidCallback&lt;Setter&gt;;
  desc.attributes = attributes;
  desc.data = data;

  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    Getter getter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">using</span> CbData = details::CallbackData&lt;Getter, Napi::Value&gt;;
  <span class="hljs-keyword">auto</span> callbackData = <span class="hljs-keyword">new</span> CbData({getter, data});

  napi_status status = AttachData(env, object, callbackData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  <span class="hljs-keyword">return</span> PropertyDescriptor({utf8name,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             CbData::Wrapper,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             attributes,
                             callbackData});
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    Getter getter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Accessor(env, object, utf8name.c_str(), getter, attributes, data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    Name name,
    Getter getter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">using</span> CbData = details::CallbackData&lt;Getter, Napi::Value&gt;;
  <span class="hljs-keyword">auto</span> callbackData = <span class="hljs-keyword">new</span> CbData({getter, data});

  napi_status status = AttachData(env, object, callbackData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  <span class="hljs-keyword">return</span> PropertyDescriptor({<span class="hljs-literal">nullptr</span>,
                             name,
                             <span class="hljs-literal">nullptr</span>,
                             CbData::Wrapper,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             attributes,
                             callbackData});
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter, <span class="hljs-keyword">typename</span> Setter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">using</span> CbData = details::AccessorCallbackData&lt;Getter, Setter&gt;;
  <span class="hljs-keyword">auto</span> callbackData = <span class="hljs-keyword">new</span> CbData({getter, setter, data});

  napi_status status = AttachData(env, object, callbackData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  <span class="hljs-keyword">return</span> PropertyDescriptor({utf8name,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             CbData::GetterWrapper,
                             CbData::SetterWrapper,
                             <span class="hljs-literal">nullptr</span>,
                             attributes,
                             callbackData});
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter, <span class="hljs-keyword">typename</span> Setter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Accessor(
      env, object, utf8name.c_str(), getter, setter, attributes, data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Getter, <span class="hljs-keyword">typename</span> Setter&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Accessor</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    Name name,
    Getter getter,
    Setter setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">using</span> CbData = details::AccessorCallbackData&lt;Getter, Setter&gt;;
  <span class="hljs-keyword">auto</span> callbackData = <span class="hljs-keyword">new</span> CbData({getter, setter, data});

  napi_status status = AttachData(env, object, callbackData);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> callbackData;
    NAPI_THROW_IF_FAILED(env, status, napi_property_descriptor());
  }

  <span class="hljs-keyword">return</span> PropertyDescriptor({<span class="hljs-literal">nullptr</span>,
                             name,
                             <span class="hljs-literal">nullptr</span>,
                             CbData::GetterWrapper,
                             CbData::SetterWrapper,
                             <span class="hljs-literal">nullptr</span>,
                             attributes,
                             callbackData});
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Function</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object <span class="hljs-comment">/*object*/</span>,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    Callable cb,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> PropertyDescriptor({utf8name,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             Napi::Function::New(env, cb, utf8name, data),
                             attributes,
                             <span class="hljs-literal">nullptr</span>});
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Function</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object object,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    Callable cb,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> Function(env, object, utf8name.c_str(), cb, attributes, data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callable&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Function</span><span class="hljs-params">(
    Napi::Env env,
    Napi::Object <span class="hljs-comment">/*object*/</span>,
    Name name,
    Callable cb,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">return</span> PropertyDescriptor({<span class="hljs-literal">nullptr</span>,
                             name,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             Napi::Function::New(env, cb, <span class="hljs-literal">nullptr</span>, data),
                             attributes,
                             <span class="hljs-literal">nullptr</span>});
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Value</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    napi_value value,
    napi_property_attributes attributes)</span> </span>{
  <span class="hljs-keyword">return</span> PropertyDescriptor({utf8name,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             <span class="hljs-literal">nullptr</span>,
                             value,
                             attributes,
                             <span class="hljs-literal">nullptr</span>});
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Value</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; utf8name,
    napi_value value,
    napi_property_attributes attributes)</span> </span>{
  <span class="hljs-keyword">return</span> Value(utf8name.c_str(), value, attributes);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Value</span><span class="hljs-params">(
    napi_value name, napi_value value, napi_property_attributes attributes)</span> </span>{
  <span class="hljs-keyword">return</span> PropertyDescriptor(
      {<span class="hljs-literal">nullptr</span>, name, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, value, attributes, <span class="hljs-literal">nullptr</span>});
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> PropertyDescriptor <span class="hljs-title">PropertyDescriptor::Value</span><span class="hljs-params">(
    Name name, Napi::Value value, napi_property_attributes attributes)</span> </span>{
  napi_value nameValue = name;
  napi_value valueValue = value;
  <span class="hljs-keyword">return</span> PropertyDescriptor::Value(nameValue, valueValue, attributes);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">PropertyDescriptor::PropertyDescriptor</span><span class="hljs-params">(napi_property_descriptor desc)</span>
    : _<span class="hljs-title">desc</span><span class="hljs-params">(desc)</span> </span>{}

<span class="hljs-keyword">inline</span> PropertyDescriptor::<span class="hljs-keyword">operator</span> napi_property_descriptor&amp;() {
  <span class="hljs-keyword">return</span> _desc;
}

<span class="hljs-keyword">inline</span> PropertyDescriptor::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">const</span> napi_property_descriptor&amp;() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> _desc;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
InstanceWrap<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> InstanceWrap&lt;T&gt;::AttachPropData(
    napi_env env, napi_value value, <span class="hljs-keyword">const</span> napi_property_descriptor* prop) {
  napi_status status;
  <span class="hljs-keyword">if</span> (!(prop-&gt;attributes &amp; napi_static)) {
    <span class="hljs-keyword">if</span> (prop-&gt;method == T::InstanceVoidMethodCallbackWrapper) {
      status = Napi::details::AttachData(
          env, value, <span class="hljs-keyword">static_cast</span>&lt;InstanceVoidMethodCallbackData*&gt;(prop-&gt;data));
      NAPI_THROW_IF_FAILED_VOID(env, status);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop-&gt;method == T::InstanceMethodCallbackWrapper) {
      status = Napi::details::AttachData(
          env, value, <span class="hljs-keyword">static_cast</span>&lt;InstanceMethodCallbackData*&gt;(prop-&gt;data));
      NAPI_THROW_IF_FAILED_VOID(env, status);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop-&gt;getter == T::InstanceGetterCallbackWrapper ||
               prop-&gt;setter == T::InstanceSetterCallbackWrapper) {
      status = Napi::details::AttachData(
          env, value, <span class="hljs-keyword">static_cast</span>&lt;InstanceAccessorCallbackData*&gt;(prop-&gt;data));
      NAPI_THROW_IF_FAILED_VOID(env, status);
    }
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    InstanceVoidMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceVoidMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceVoidMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = T::InstanceVoidMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    InstanceMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = T::InstanceMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    Symbol name,
    InstanceVoidMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceVoidMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceVoidMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = T::InstanceVoidMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    Symbol name,
    InstanceMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = T::InstanceMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceVoidMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = details::TemplatedInstanceVoidCallback&lt;T, method&gt;;
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = details::TemplatedInstanceCallback&lt;T, method&gt;;
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceVoidMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = details::TemplatedInstanceVoidCallback&lt;T, method&gt;;
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceMethod(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = details::TemplatedInstanceCallback&lt;T, method&gt;;
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceAccessor(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    InstanceGetterCallback getter,
    InstanceSetterCallback setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceAccessorCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceAccessorCallbackData({getter, setter, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.getter = getter != <span class="hljs-literal">nullptr</span> ? T::InstanceGetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.setter = setter != <span class="hljs-literal">nullptr</span> ? T::InstanceSetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceAccessor(
    Symbol name,
    InstanceGetterCallback getter,
    InstanceSetterCallback setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  InstanceAccessorCallbackData* callbackData =
      <span class="hljs-keyword">new</span> InstanceAccessorCallbackData({getter, setter, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.getter = getter != <span class="hljs-literal">nullptr</span> ? T::InstanceGetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.setter = setter != <span class="hljs-literal">nullptr</span> ? T::InstanceSetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.data = callbackData;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceGetterCallback getter,
          <span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceSetterCallback setter&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceAccessor(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.getter = details::TemplatedInstanceCallback&lt;T, getter&gt;;
  desc.setter = This::WrapSetter(This::SetterTag&lt;setter&gt;());
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceGetterCallback getter,
          <span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceSetterCallback setter&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceAccessor(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.getter = details::TemplatedInstanceCallback&lt;T, getter&gt;;
  desc.setter = This::WrapSetter(This::SetterTag&lt;setter&gt;());
  desc.data = data;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceValue(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    Napi::Value value,
    napi_property_attributes attributes) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.value = value;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; InstanceWrap&lt;T&gt;::InstanceValue(
    Symbol name, Napi::Value value, napi_property_attributes attributes) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.value = value;
  desc.attributes = attributes;
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value InstanceWrap&lt;T&gt;::InstanceVoidMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    InstanceVoidMethodCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;InstanceVoidMethodCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    T* instance = T::Unwrap(callbackInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">auto</span> cb = callbackData-&gt;callback;
    <span class="hljs-keyword">if</span> (instance) (instance-&gt;*cb)(callbackInfo);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value InstanceWrap&lt;T&gt;::InstanceMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    InstanceMethodCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;InstanceMethodCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    T* instance = T::Unwrap(callbackInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">auto</span> cb = callbackData-&gt;callback;
    <span class="hljs-keyword">return</span> instance ? (instance-&gt;*cb)(callbackInfo) : Napi::Value();
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value InstanceWrap&lt;T&gt;::InstanceGetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    InstanceAccessorCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;InstanceAccessorCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    T* instance = T::Unwrap(callbackInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">auto</span> cb = callbackData-&gt;getterCallback;
    <span class="hljs-keyword">return</span> instance ? (instance-&gt;*cb)(callbackInfo) : Napi::Value();
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value InstanceWrap&lt;T&gt;::InstanceSetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    InstanceAccessorCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;InstanceAccessorCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    T* instance = T::Unwrap(callbackInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">auto</span> cb = callbackData-&gt;setterCallback;
    <span class="hljs-keyword">if</span> (instance) (instance-&gt;*cb)(callbackInfo, callbackInfo[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> InstanceWrap&lt;T&gt;::InstanceSetterCallback method&gt;
<span class="hljs-keyword">inline</span> napi_value InstanceWrap&lt;T&gt;::WrappedMethod(
    napi_env env, napi_callback_info info) NAPI_NOEXCEPT {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    <span class="hljs-keyword">const</span> CallbackInfo cbInfo(env, info);
    T* instance = T::Unwrap(cbInfo.This().As&lt;Object&gt;());
    <span class="hljs-keyword">if</span> (instance) (instance-&gt;*method)(cbInfo, cbInfo[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
ObjectWrap<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ObjectWrap&lt;T&gt;::ObjectWrap(<span class="hljs-keyword">const</span> Napi::CallbackInfo&amp; callbackInfo) {
  napi_env env = callbackInfo.Env();
  napi_value wrapper = callbackInfo.This();
  napi_status status;
  napi_ref ref;
  T* instance = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>);
  status = napi_wrap(env,
                     wrapper,
                     instance,
                     details::PostFinalizerWrapper&lt;FinalizeCallback&gt;,
                     <span class="hljs-literal">nullptr</span>,
                     &amp;ref);
  NAPI_THROW_IF_FAILED_VOID(env, status);

  Reference&lt;Object&gt;* instanceRef = instance;
  *instanceRef = Reference&lt;Object&gt;(env, ref);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ObjectWrap&lt;T&gt;::~ObjectWrap() {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<p>If the JS object still exists at this point, remove the finalizer added
through <code>napi_wrap()</code>.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (!IsEmpty()) {
    Object object = Value();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<p>It is not valid to call <code>napi_remove_wrap()</code> with an empty <code>object</code>.
This happens e.g. during garbage collection.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">if</span> (!object.IsEmpty() &amp;&amp; _construction_failed) {
      napi_remove_wrap(Env(), object, <span class="hljs-literal">nullptr</span>);
    }
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> T* ObjectWrap&lt;T&gt;::Unwrap(Object wrapper) {
  <span class="hljs-keyword">void</span>* unwrapped;
  napi_status status = napi_unwrap(wrapper.Env(), wrapper, &amp;unwrapped);
  NAPI_THROW_IF_FAILED(wrapper.Env(), status, <span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(unwrapped);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Function ObjectWrap&lt;T&gt;::DefineClass(
    Napi::Env env,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> props_count,
    <span class="hljs-keyword">const</span> napi_property_descriptor* descriptors,
    <span class="hljs-keyword">void</span>* data) {
  napi_status status;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_property_descriptor&gt; <span class="hljs-title">props</span><span class="hljs-params">(props_count)</span></span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<p>We copy the descriptors to a local array because before defining the class
we must replace static method property descriptors with value property
descriptors such that the value is a function-valued <code>napi_value</code> created
with <code>CreateFunction()</code>.</p>
<p>This replacement could be made for instance methods as well, but V8 aborts
if we do that, because it expects methods defined on the prototype template
to have <code>FunctionTemplate</code>s.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> index = <span class="hljs-number">0</span>; index &lt; props_count; index++) {
    props[index] = descriptors[index];
    napi_property_descriptor* prop = &amp;props[index];
    <span class="hljs-keyword">if</span> (prop-&gt;method == T::StaticMethodCallbackWrapper) {
      status =
          CreateFunction(env,
                         utf8name,
                         prop-&gt;method,
                         <span class="hljs-keyword">static_cast</span>&lt;StaticMethodCallbackData*&gt;(prop-&gt;data),
                         &amp;(prop-&gt;value));
      NAPI_THROW_IF_FAILED(env, status, Function());
      prop-&gt;method = <span class="hljs-literal">nullptr</span>;
      prop-&gt;data = <span class="hljs-literal">nullptr</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop-&gt;method == T::StaticVoidMethodCallbackWrapper) {
      status =
          CreateFunction(env,
                         utf8name,
                         prop-&gt;method,
                         <span class="hljs-keyword">static_cast</span>&lt;StaticVoidMethodCallbackData*&gt;(prop-&gt;data),
                         &amp;(prop-&gt;value));
      NAPI_THROW_IF_FAILED(env, status, Function());
      prop-&gt;method = <span class="hljs-literal">nullptr</span>;
      prop-&gt;data = <span class="hljs-literal">nullptr</span>;
    }
  }

  napi_value value;
  status = napi_define_class(env,
                             utf8name,
                             NAPI_AUTO_LENGTH,
                             T::ConstructorCallbackWrapper,
                             data,
                             props_count,
                             props.data(),
                             &amp;value);
  NAPI_THROW_IF_FAILED(env, status, Function());

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<p>After defining the class we iterate once more over the property descriptors
and attach the data associated with accessors and instance methods to the
newly created JavaScript class.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>; idx &lt; props_count; idx++) {
    <span class="hljs-keyword">const</span> napi_property_descriptor* prop = &amp;props[idx];

    <span class="hljs-keyword">if</span> (prop-&gt;getter == T::StaticGetterCallbackWrapper ||
        prop-&gt;setter == T::StaticSetterCallbackWrapper) {
      status = Napi::details::AttachData(
          env, value, <span class="hljs-keyword">static_cast</span>&lt;StaticAccessorCallbackData*&gt;(prop-&gt;data));
      NAPI_THROW_IF_FAILED(env, status, Function());
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>InstanceWrap<T>::AttachPropData is responsible for attaching the data
of instance methods and accessors.</p>

        </td>
        <td class="code highlight">
          <pre class="c">      T::AttachPropData(env, value, prop);
    }
  }

  <span class="hljs-keyword">return</span> Function(env, value);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Function ObjectWrap&lt;T&gt;::DefineClass(
    Napi::Env env,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;ClassPropertyDescriptor&lt;T&gt;&gt;&amp; properties,
    <span class="hljs-keyword">void</span>* data) {
  <span class="hljs-keyword">return</span> DefineClass(
      env,
      utf8name,
      properties.<span class="hljs-built_in">size</span>(),
      <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> napi_property_descriptor*&gt;(properties.<span class="hljs-built_in">begin</span>()),
      data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Function ObjectWrap&lt;T&gt;::DefineClass(
    Napi::Env env,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ClassPropertyDescriptor&lt;T&gt;&gt;&amp; properties,
    <span class="hljs-keyword">void</span>* data) {
  <span class="hljs-keyword">return</span> DefineClass(
      env,
      utf8name,
      properties.<span class="hljs-built_in">size</span>(),
      <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> napi_property_descriptor*&gt;(properties.data()),
      data);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    StaticVoidMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticVoidMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticVoidMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = T::StaticVoidMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    StaticMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = T::StaticMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    Symbol name,
    StaticVoidMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticVoidMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticVoidMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = T::StaticVoidMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    Symbol name,
    StaticMethodCallback method,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticMethodCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticMethodCallbackData({method, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = T::StaticMethodCallbackWrapper;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticVoidMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = details::TemplatedVoidCallback&lt;method&gt;;
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticVoidMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = details::TemplatedVoidCallback&lt;method&gt;;
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.method = details::TemplatedCallback&lt;method&gt;;
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticMethodCallback method&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticMethod(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.method = details::TemplatedCallback&lt;method&gt;;
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticAccessor(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    StaticGetterCallback getter,
    StaticSetterCallback setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticAccessorCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticAccessorCallbackData({getter, setter, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.getter = getter != <span class="hljs-literal">nullptr</span> ? T::StaticGetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.setter = setter != <span class="hljs-literal">nullptr</span> ? T::StaticSetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticAccessor(
    Symbol name,
    StaticGetterCallback getter,
    StaticSetterCallback setter,
    napi_property_attributes attributes,
    <span class="hljs-keyword">void</span>* data) {
  StaticAccessorCallbackData* callbackData =
      <span class="hljs-keyword">new</span> StaticAccessorCallbackData({getter, setter, data});

  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.getter = getter != <span class="hljs-literal">nullptr</span> ? T::StaticGetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.setter = setter != <span class="hljs-literal">nullptr</span> ? T::StaticSetterCallbackWrapper : <span class="hljs-literal">nullptr</span>;
  desc.data = callbackData;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticGetterCallback getter,
          <span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticSetterCallback setter&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticAccessor(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.getter = details::TemplatedCallback&lt;getter&gt;;
  desc.setter = This::WrapStaticSetter(This::StaticSetterTag&lt;setter&gt;());
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticGetterCallback getter,
          <span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticSetterCallback setter&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticAccessor(
    Symbol name, napi_property_attributes attributes, <span class="hljs-keyword">void</span>* data) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.getter = details::TemplatedCallback&lt;getter&gt;;
  desc.setter = This::WrapStaticSetter(This::StaticSetterTag&lt;setter&gt;());
  desc.data = data;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticValue(
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* utf8name,
    Napi::Value value,
    napi_property_attributes attributes) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.utf8name = utf8name;
  desc.value = value;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> ClassPropertyDescriptor&lt;T&gt; ObjectWrap&lt;T&gt;::StaticValue(
    Symbol name, Napi::Value value, napi_property_attributes attributes) {
  napi_property_descriptor desc = napi_property_descriptor();
  desc.name = name;
  desc.value = value;
  desc.attributes =
      <span class="hljs-keyword">static_cast</span>&lt;napi_property_attributes&gt;(attributes | napi_static);
  <span class="hljs-keyword">return</span> desc;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> Value ObjectWrap&lt;T&gt;::OnCalledAsFunction(
    <span class="hljs-keyword">const</span> Napi::CallbackInfo&amp; callbackInfo) {
  NAPI_THROW(
      TypeError::New(callbackInfo.Env(),
                     <span class="hljs-string">"Class constructors cannot be invoked without 'new'"</span>),
      Napi::Value());
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> ObjectWrap&lt;T&gt;::Finalize(Napi::Env <span class="hljs-comment">/*env*/</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::ConstructorCallbackWrapper(
    napi_env env, napi_callback_info info) {
  napi_value new_target;
  napi_status status = napi_get_new_target(env, info, &amp;new_target);
  <span class="hljs-keyword">if</span> (status != napi_ok) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

  <span class="hljs-keyword">bool</span> isConstructCall = (new_target != <span class="hljs-literal">nullptr</span>);
  <span class="hljs-keyword">if</span> (!isConstructCall) {
    <span class="hljs-keyword">return</span> details::WrapCallback(
        [&amp;] { <span class="hljs-keyword">return</span> T::OnCalledAsFunction(CallbackInfo(env, info)); });
  }

  napi_value wrapper = details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    T* instance = <span class="hljs-keyword">new</span> T(callbackInfo);
#ifdef NAPI_CPP_EXCEPTIONS
    instance-&gt;_construction_failed = <span class="hljs-literal">false</span>;
#<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">if</span> (callbackInfo.Env().IsExceptionPending()) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<p>We need to clear the exception so that removing the wrap might work.</p>

        </td>
        <td class="code highlight">
          <pre class="c">      Error e = callbackInfo.Env().GetAndClearPendingException();
      <span class="hljs-keyword">delete</span> instance;
      e.ThrowAsJavaScriptException();
    } <span class="hljs-keyword">else</span> {
      instance-&gt;_construction_failed = <span class="hljs-literal">false</span>;
    }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
    <span class="hljs-keyword">return</span> callbackInfo.This();
  });

  <span class="hljs-keyword">return</span> wrapper;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::StaticVoidMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    StaticVoidMethodCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;StaticVoidMethodCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    callbackData-&gt;callback(callbackInfo);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::StaticMethodCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    StaticMethodCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;StaticMethodCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    <span class="hljs-keyword">return</span> callbackData-&gt;callback(callbackInfo);
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::StaticGetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    StaticAccessorCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;StaticAccessorCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    <span class="hljs-keyword">return</span> callbackData-&gt;getterCallback(callbackInfo);
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::StaticSetterCallbackWrapper(
    napi_env env, napi_callback_info info) {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    CallbackInfo callbackInfo(env, info);
    StaticAccessorCallbackData* callbackData =
        <span class="hljs-keyword">reinterpret_cast</span>&lt;StaticAccessorCallbackData*&gt;(callbackInfo.Data());
    callbackInfo.SetData(callbackData-&gt;data);
    callbackData-&gt;setterCallback(callbackInfo, callbackInfo[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> ObjectWrap&lt;T&gt;::FinalizeCallback(napi_env env,
                                            <span class="hljs-keyword">void</span>* data,
                                            <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*hint*/</span>) {
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(env)</span></span>;
  T* instance = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(data);
  instance-&gt;Finalize(Napi::Env(env));
  <span class="hljs-keyword">delete</span> instance;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ObjectWrap&lt;T&gt;::StaticSetterCallback method&gt;
<span class="hljs-keyword">inline</span> napi_value ObjectWrap&lt;T&gt;::WrappedMethod(
    napi_env env, napi_callback_info info) NAPI_NOEXCEPT {
  <span class="hljs-keyword">return</span> details::WrapCallback([&amp;] {
    <span class="hljs-keyword">const</span> CallbackInfo cbInfo(env, info);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<p>MSVC requires to copy 'method' function pointer to a local variable
before invoking it.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">auto</span> m = method;
    m(cbInfo, cbInfo[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
HandleScope class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline HandleScope::HandleScope(napi_env env, napi_handle_scope scope)
    : _env(env), _scope(scope) {}

inline HandleScope::HandleScope(Napi::Env env) : _env(env) {
  napi_status status = napi_open_handle_scope(_env, &amp;_scope);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline HandleScope::~HandleScope() {
  napi_status status = napi_close_handle_scope(_env, _scope);
  NAPI_FATAL_IF_FAILED(
      status, "HandleScope::~HandleScope", "napi_close_handle_scope");
}

inline HandleScope::operator napi_handle_scope() const {
  return _scope;
}

inline Napi::Env HandleScope::Env() const {
  return Napi::Env(_env);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
EscapableHandleScope class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline EscapableHandleScope::EscapableHandleScope(
    napi_env env, napi_escapable_handle_scope scope)
    : _env(env), _scope(scope) {}

inline EscapableHandleScope::EscapableHandleScope(Napi::Env env) : _env(env) {
  napi_status status = napi_open_escapable_handle_scope(_env, &amp;_scope);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline EscapableHandleScope::~EscapableHandleScope() {
  napi_status status = napi_close_escapable_handle_scope(_env, _scope);
  NAPI_FATAL_IF_FAILED(status,
                       "EscapableHandleScope::~EscapableHandleScope",
                       "napi_close_escapable_handle_scope");
}

inline EscapableHandleScope::operator napi_escapable_handle_scope() const {
  return _scope;
}

inline Napi::Env EscapableHandleScope::Env() const {
  return Napi::Env(_env);
}

inline Value EscapableHandleScope::Escape(napi_value escapee) {
  napi_value result;
  napi_status status = napi_escape_handle(_env, _scope, escapee, &amp;result);
  NAPI_THROW_IF_FAILED(_env, status, Value());
  return Value(_env, result);
}

#if (NAPI_VERSION &gt; 2)
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
CallbackScope class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline CallbackScope::CallbackScope(napi_env env, napi_callback_scope scope)
    : _env(env), _scope(scope) {}

inline CallbackScope::CallbackScope(napi_env env, napi_async_context context)
    : _env(env) {
  napi_status status =
      napi_open_callback_scope(_env, Object::New(env), context, &amp;_scope);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline CallbackScope::~CallbackScope() {
  napi_status status = napi_close_callback_scope(_env, _scope);
  NAPI_FATAL_IF_FAILED(
      status, "CallbackScope::~CallbackScope", "napi_close_callback_scope");
}

inline CallbackScope::operator napi_callback_scope() const {
  return _scope;
}

inline Napi::Env CallbackScope::Env() const {
  return Napi::Env(_env);
}
#endif

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
AsyncContext class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline AsyncContext::AsyncContext(napi_env env, const char* resource_name)
    : AsyncContext(env, resource_name, Object::New(env)) {}

inline AsyncContext::AsyncContext(napi_env env,
                                  const char* resource_name,
                                  const Object&amp; resource)
    : _env(env), _context(nullptr) {
  napi_value resource_id;
  napi_status status = napi_create_string_utf8(
      _env, resource_name, NAPI_AUTO_LENGTH, &amp;resource_id);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  status = napi_async_init(_env, resource, resource_id, &amp;_context);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline AsyncContext::~AsyncContext() {
  if (_context != nullptr) {
    napi_async_destroy(_env, _context);
    _context = nullptr;
  }
}

inline AsyncContext::AsyncContext(AsyncContext&amp;&amp; other) {
  _env = other._env;
  other._env = nullptr;
  _context = other._context;
  other._context = nullptr;
}

inline AsyncContext&amp; AsyncContext::operator=(AsyncContext&amp;&amp; other) {
  _env = other._env;
  other._env = nullptr;
  _context = other._context;
  other._context = nullptr;
  return *this;
}

inline AsyncContext::operator napi_async_context() const {
  return _context;
}

inline Napi::Env AsyncContext::Env() const {
  return Napi::Env(_env);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
AsyncWorker class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
#if NAPI_HAS_THREADS

inline AsyncWorker::AsyncWorker(const Function&amp; callback)
    : AsyncWorker(callback, "generic") {}

inline AsyncWorker::AsyncWorker(const Function&amp; callback,
                                const char* resource_name)
    : AsyncWorker(callback, resource_name, Object::New(callback.Env())) {}

inline AsyncWorker::AsyncWorker(const Function&amp; callback,
                                const char* resource_name,
                                const Object&amp; resource)
    : AsyncWorker(
          Object::New(callback.Env()), callback, resource_name, resource) {}

inline AsyncWorker::AsyncWorker(const Object&amp; receiver,
                                const Function&amp; callback)
    : AsyncWorker(receiver, callback, "generic") {}

inline AsyncWorker::AsyncWorker(const Object&amp; receiver,
                                const Function&amp; callback,
                                const char* resource_name)
    : AsyncWorker(
          receiver, callback, resource_name, Object::New(callback.Env())) {}

inline AsyncWorker::AsyncWorker(const Object&amp; receiver,
                                const Function&amp; callback,
                                const char* resource_name,
                                const Object&amp; resource)
    : _env(callback.Env()),
      _receiver(Napi::Persistent(receiver)),
      _callback(Napi::Persistent(callback)),
      _suppress_destruct(false) {
  napi_value resource_id;
  napi_status status = napi_create_string_latin1(
      _env, resource_name, NAPI_AUTO_LENGTH, &amp;resource_id);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  status = napi_create_async_work(_env,
                                  resource,
                                  resource_id,
                                  OnAsyncWorkExecute,
                                  OnAsyncWorkComplete,
                                  this,
                                  &amp;_work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline AsyncWorker::AsyncWorker(Napi::Env env) : AsyncWorker(env, "generic") {}

inline AsyncWorker::AsyncWorker(Napi::Env env, const char* resource_name)
    : AsyncWorker(env, resource_name, Object::New(env)) {}

inline AsyncWorker::AsyncWorker(Napi::Env env,
                                const char* resource_name,
                                const Object&amp; resource)
    : _env(env), _receiver(), _callback(), _suppress_destruct(false) {
  napi_value resource_id;
  napi_status status = napi_create_string_latin1(
      _env, resource_name, NAPI_AUTO_LENGTH, &amp;resource_id);
  NAPI_THROW_IF_FAILED_VOID(_env, status);

  status = napi_create_async_work(_env,
                                  resource,
                                  resource_id,
                                  OnAsyncWorkExecute,
                                  OnAsyncWorkComplete,
                                  this,
                                  &amp;_work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline AsyncWorker::~AsyncWorker() {
  if (_work != nullptr) {
    napi_delete_async_work(_env, _work);
    _work = nullptr;
  }
}

inline void AsyncWorker::Destroy() {
  delete this;
}

inline AsyncWorker::operator napi_async_work() const {
  return _work;
}

inline Napi::Env AsyncWorker::Env() const {
  return Napi::Env(_env);
}

inline void AsyncWorker::Queue() {
  napi_status status = napi_queue_async_work(_env, _work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline void AsyncWorker::Cancel() {
  napi_status status = napi_cancel_async_work(_env, _work);
  NAPI_THROW_IF_FAILED_VOID(_env, status);
}

inline ObjectReference&amp; AsyncWorker::Receiver() {
  return _receiver;
}

inline FunctionReference&amp; AsyncWorker::Callback() {
  return _callback;
}

inline void AsyncWorker::SuppressDestruct() {
  _suppress_destruct = true;
}

inline void AsyncWorker::OnOK() {
  if (!_callback.IsEmpty()) {
    _callback.Call(_receiver.Value(), GetResult(_callback.Env()));
  }
}

inline void AsyncWorker::OnError(const Error&amp; e) {
  if (!_callback.IsEmpty()) {
    _callback.Call(_receiver.Value(),
                   std::initializer_list&lt;napi_value&gt;{e.Value()});
  }
}

inline void AsyncWorker::SetError(const std::string&amp; error) {
  _error = error;
}

inline std::vector&lt;napi_value&gt; AsyncWorker::GetResult(Napi::Env /*env*/) {
  return {};
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>The OnAsyncWorkExecute method receives an napi_env argument. However, do NOT
use it within this method, as it does not run on the JavaScript thread and
must not run any method that would cause JavaScript to run. In practice,
this means that almost any use of napi_env will be incorrect.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncWorker::OnAsyncWorkExecute</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">void</span>* asyncworker)</span> </span>{
  AsyncWorker* self = <span class="hljs-keyword">static_cast</span>&lt;AsyncWorker*&gt;(asyncworker);
  self-&gt;OnExecute(env);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p>The OnExecute method receives an napi_env argument. However, do NOT
use it within this method, as it does not run on the JavaScript thread and
must not run any method that would cause JavaScript to run. In practice,
this means that almost any use of napi_env will be incorrect.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncWorker::OnExecute</span><span class="hljs-params">(Napi::Env <span class="hljs-comment">/*DO_NOT_USE*/</span>)</span> </span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NAPI_CPP_EXCEPTIONS</span>
  <span class="hljs-keyword">try</span> {
    Execute();
  } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::exception&amp; e) {
    SetError(e.what());
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>   <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
  Execute();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_CPP_EXCEPTIONS</span></span>
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncWorker::OnAsyncWorkComplete</span><span class="hljs-params">(napi_env env,
                                             napi_status status,
                                             <span class="hljs-keyword">void</span>* asyncworker)</span> </span>{
  AsyncWorker* self = <span class="hljs-keyword">static_cast</span>&lt;AsyncWorker*&gt;(asyncworker);
  self-&gt;OnWorkComplete(env, status);
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncWorker::OnWorkComplete</span><span class="hljs-params">(Napi::Env <span class="hljs-comment">/*env*/</span>, napi_status status)</span> </span>{
  <span class="hljs-keyword">if</span> (status != napi_cancelled) {
    <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(_env)</span></span>;
    details::WrapCallback([&amp;] {
      <span class="hljs-keyword">if</span> (_error.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
        OnOK();
      } <span class="hljs-keyword">else</span> {
        OnError(Error::New(_env, _error));
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    });
  }
  <span class="hljs-keyword">if</span> (!_suppress_destruct) {
    Destroy();
  }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_HAS_THREADS</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NAPI_VERSION &gt; 3 &amp;&amp; NAPI_HAS_THREADS)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-91" id="section-91"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
TypedThreadSafeFunction&lt;ContextType,DataType,CallJs&gt; class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-92" id="section-92"></a>
</div>
<p>Starting with NAPI 5, the JavaScript function <code>func</code> parameter of
<code>napi_create_threadsafe_function</code> is optional.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 4</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-93" id="section-93"></a>
</div>
<p>static, with Callback [missing] Resource [missing] Finalizer [missing]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  napi_status status =
      napi_create_threadsafe_function(env,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<p>static, with Callback [missing] Resource [passed] Finalizer [missing]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  napi_status status =
      napi_create_threadsafe_function(env,
                                      <span class="hljs-literal">nullptr</span>,
                                      resource,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<p>static, with Callback [missing] Resource [missing] Finalizer [passed]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context,
    Finalizer finalizeCallback,
    FinalizerDataType* data) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  <span class="hljs-keyword">auto</span>* finalizeData = <span class="hljs-keyword">new</span> details::
      ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;(
          {data, finalizeCallback});
  <span class="hljs-keyword">auto</span> fini =
      details::ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;::
          FinalizeFinalizeWrapperWithDataAndContext;
  napi_status status =
      napi_create_threadsafe_function(env,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      finalizeData,
                                      fini,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-96" id="section-96"></a>
</div>
<p>static, with Callback [missing] Resource [passed] Finalizer [passed]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context,
    Finalizer finalizeCallback,
    FinalizerDataType* data) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  <span class="hljs-keyword">auto</span>* finalizeData = <span class="hljs-keyword">new</span> details::
      ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;(
          {data, finalizeCallback});
  <span class="hljs-keyword">auto</span> fini =
      details::ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;::
          FinalizeFinalizeWrapperWithDataAndContext;
  napi_status status =
      napi_create_threadsafe_function(env,
                                      <span class="hljs-literal">nullptr</span>,
                                      resource,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      finalizeData,
                                      fini,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-97" id="section-97"></a>
</div>
<p>static, with Callback [passed] Resource [missing] Finalizer [missing]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    <span class="hljs-keyword">const</span> Function&amp; callback,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  napi_status status =
      napi_create_threadsafe_function(env,
                                      callback,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<p>static, with Callback [passed] Resource [passed] Finalizer [missing]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    <span class="hljs-keyword">const</span> Function&amp; callback,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  napi_status status =
      napi_create_threadsafe_function(env,
                                      callback,
                                      resource,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-literal">nullptr</span>,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<p>static, with Callback [passed] Resource [missing] Finalizer [passed]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    <span class="hljs-keyword">const</span> Function&amp; callback,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context,
    Finalizer finalizeCallback,
    FinalizerDataType* data) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  <span class="hljs-keyword">auto</span>* finalizeData = <span class="hljs-keyword">new</span> details::
      ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;(
          {data, finalizeCallback});
  <span class="hljs-keyword">auto</span> fini =
      details::ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;::
          FinalizeFinalizeWrapperWithDataAndContext;
  napi_status status =
      napi_create_threadsafe_function(env,
                                      callback,
                                      <span class="hljs-literal">nullptr</span>,
                                      <span class="hljs-keyword">String</span>::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      finalizeData,
                                      fini,
                                      context,
                                      CallJsInternal,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<p>static, with: Callback [passed] Resource [passed] Finalizer [passed]</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CallbackType,
          <span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::New(
    napi_env env,
    CallbackType callback,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    ResourceString resourceName,
    <span class="hljs-keyword">size_t</span> maxQueueSize,
    <span class="hljs-keyword">size_t</span> initialThreadCount,
    ContextType* context,
    Finalizer finalizeCallback,
    FinalizerDataType* data) {
  TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt; tsfn;

  <span class="hljs-keyword">auto</span>* finalizeData = <span class="hljs-keyword">new</span> details::
      ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;(
          {data, finalizeCallback});
  <span class="hljs-keyword">auto</span> fini =
      details::ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;::
          FinalizeFinalizeWrapperWithDataAndContext;
  napi_status status = napi_create_threadsafe_function(
      env,
      details::DefaultCallbackWrapper&lt;
          CallbackType,
          TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;&gt;(env,
                                                                  callback),
      resource,
      <span class="hljs-keyword">String</span>::From(env, resourceName),
      maxQueueSize,
      initialThreadCount,
      finalizeData,
      fini,
      context,
      CallJsInternal,
      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(
        env, status, TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::
    TypedThreadSafeFunction()
    : _tsfn() {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::
    TypedThreadSafeFunction(napi_threadsafe_function tsfn)
    : _tsfn(tsfn) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::
<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">napi_threadsafe_function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _tsfn;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> napi_status
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::BlockingCall(
    DataType* data) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> napi_call_threadsafe_function(_tsfn, data, napi_tsfn_blocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> napi_status
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::NonBlockingCall(
    DataType* data) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> napi_call_threadsafe_function(_tsfn, data, napi_tsfn_nonblocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::Ref(
    napi_env env) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">if</span> (_tsfn != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_ref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::Unref(
    napi_env env) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">if</span> (_tsfn != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_unref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> napi_status
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::Acquire() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> napi_acquire_threadsafe_function(_tsfn);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> napi_status
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::Release() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> napi_release_threadsafe_function(_tsfn, napi_tsfn_release);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> napi_status
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::Abort() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">inline</span> ContextType*
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::GetContext() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">void</span>* context;
  napi_status status = napi_get_threadsafe_function_context(_tsfn, &amp;context);
  NAPI_FATAL_IF_FAILED(status,
                       <span class="hljs-string">"TypedThreadSafeFunction::GetContext"</span>,
                       <span class="hljs-string">"napi_get_threadsafe_function_context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;ContextType*&gt;(context);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-101" id="section-101"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-keyword">void</span> TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::CallJsInternal(
    napi_env env, napi_value jsCallback, <span class="hljs-keyword">void</span>* context, <span class="hljs-keyword">void</span>* data) {
  details::CallJsWrapper&lt;ContextType, DataType, <span class="hljs-keyword">decltype</span>(CallJs), CallJs&gt;(
      env, jsCallback, context, data);
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION == 4</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
Napi::Function
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::EmptyFunctionFactory(
    Napi::Env env) {
  <span class="hljs-keyword">return</span> Napi::Function::New(env, [](<span class="hljs-keyword">const</span> CallbackInfo&amp; cb) {});
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
Napi::Function
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::FunctionOrEmpty(
    Napi::Env env, Napi::Function&amp; callback) {
  <span class="hljs-keyword">if</span> (callback.IsEmpty()) {
    <span class="hljs-keyword">return</span> EmptyFunctionFactory(env);
  }
  <span class="hljs-keyword">return</span> callback;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::EmptyFunctionFactory(
    Napi::Env <span class="hljs-comment">/*env*/</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> DataType,
          <span class="hljs-keyword">void</span> (*CallJs)(Napi::Env, Napi::Function, ContextType*, DataType*)&gt;
Napi::Function
TypedThreadSafeFunction&lt;ContextType, DataType, CallJs&gt;::FunctionOrEmpty(
    Napi::Env <span class="hljs-comment">/*env*/</span>, Napi::Function&amp; callback) {
  <span class="hljs-keyword">return</span> callback;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
ThreadSafeFunction class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount)</span> </span>{
  <span class="hljs-keyword">return</span> New(
      env, callback, Object(), resourceName, maxQueueSize, initialThreadCount);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> ContextType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  Finalizer finalizeCallback)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             finalizeCallback);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             finalizeCallback,
             data);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> ContextType, <span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             finalizeCallback);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             Object(),
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             finalizeCallback,
             data);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">/* context */</span>);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> ContextType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             context,
             [](Env, ContextType*) {} <span class="hljs-comment">/* empty finalizer */</span>);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  Finalizer finalizeCallback)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">/* context */</span>,
             finalizeCallback,
             <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">/* data */</span>,
             details::ThreadSafeFinalize&lt;<span class="hljs-keyword">void</span>, Finalizer&gt;::Wrapper);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data)</span> </span>{
  <span class="hljs-keyword">return</span> New(env,
             callback,
             resource,
             resourceName,
             maxQueueSize,
             initialThreadCount,
             <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">/* context */</span>,
             finalizeCallback,
             data,
             details::ThreadSafeFinalize&lt;<span class="hljs-keyword">void</span>, Finalizer, FinalizerDataType&gt;::
                 FinalizeWrapperWithData);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString, <span class="hljs-keyword">typename</span> ContextType, <span class="hljs-keyword">typename</span> Finalizer&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback)</span> </span>{
  <span class="hljs-keyword">return</span> New(
      env,
      callback,
      resource,
      resourceName,
      maxQueueSize,
      initialThreadCount,
      context,
      finalizeCallback,
      <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-literal">nullptr</span>) <span class="hljs-comment">/* data */</span>,
      details::ThreadSafeFinalize&lt;ContextType,
                                  Finalizer&gt;::FinalizeWrapperWithContext);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-118" id="section-118"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data)</span> </span>{
  <span class="hljs-keyword">return</span> New(
      env,
      callback,
      resource,
      resourceName,
      maxQueueSize,
      initialThreadCount,
      context,
      finalizeCallback,
      data,
      details::ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;::
          FinalizeFinalizeWrapperWithDataAndContext);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ThreadSafeFunction::ThreadSafeFunction</span><span class="hljs-params">()</span> : _<span class="hljs-title">tsfn</span><span class="hljs-params">()</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ThreadSafeFunction::ThreadSafeFunction</span><span class="hljs-params">(napi_threadsafe_function tsfn)</span>
    : _<span class="hljs-title">tsfn</span><span class="hljs-params">(tsfn)</span> </span>{}

<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction::<span class="hljs-keyword">operator</span> <span class="hljs-title">napi_threadsafe_function</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> _tsfn;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::BlockingCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-literal">nullptr</span>, napi_tsfn_blocking);
}

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::BlockingCall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* data)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> napi_call_threadsafe_function(_tsfn, data, napi_tsfn_blocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callback&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::BlockingCall</span><span class="hljs-params">(Callback callback)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-keyword">new</span> CallbackWrapper(callback), napi_tsfn_blocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType, <span class="hljs-keyword">typename</span> Callback&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::BlockingCall</span><span class="hljs-params">(DataType* data,
                                                    Callback callback)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">auto</span> wrapper = [data, callback](Env env, Function jsCallback) {
    callback(env, jsCallback, data);
  };
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-keyword">new</span> CallbackWrapper(wrapper), napi_tsfn_blocking);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::NonBlockingCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-literal">nullptr</span>, napi_tsfn_nonblocking);
}

<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::NonBlockingCall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* data)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> napi_call_threadsafe_function(_tsfn, data, napi_tsfn_nonblocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Callback&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::NonBlockingCall</span><span class="hljs-params">(
    Callback callback)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-keyword">new</span> CallbackWrapper(callback), napi_tsfn_nonblocking);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType, <span class="hljs-keyword">typename</span> Callback&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::NonBlockingCall</span><span class="hljs-params">(
    DataType* data, Callback callback)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">auto</span> wrapper = [data, callback](Env env, Function jsCallback) {
    callback(env, jsCallback, data);
  };
  <span class="hljs-keyword">return</span> CallInternal(<span class="hljs-keyword">new</span> CallbackWrapper(wrapper), napi_tsfn_nonblocking);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThreadSafeFunction::Ref</span><span class="hljs-params">(napi_env env)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (_tsfn != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_ref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThreadSafeFunction::Unref</span><span class="hljs-params">(napi_env env)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (_tsfn != <span class="hljs-literal">nullptr</span>) {
    napi_status status = napi_unref_threadsafe_function(env, _tsfn);
    NAPI_THROW_IF_FAILED_VOID(env, status);
  }
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::Acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> napi_acquire_threadsafe_function(_tsfn);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::Release</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> napi_release_threadsafe_function(_tsfn, napi_tsfn_release);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::Abort</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> napi_release_threadsafe_function(_tsfn, napi_tsfn_abort);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction::ConvertibleContext <span class="hljs-title">ThreadSafeFunction::GetContext</span><span class="hljs-params">()</span>
    <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">void</span>* context;
  napi_status status = napi_get_threadsafe_function_context(_tsfn, &amp;context);
  NAPI_FATAL_IF_FAILED(status,
                       <span class="hljs-string">"ThreadSafeFunction::GetContext"</span>,
                       <span class="hljs-string">"napi_get_threadsafe_function_context"</span>);
  <span class="hljs-keyword">return</span> ConvertibleContext({context});
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-119" id="section-119"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ResourceString,
          <span class="hljs-keyword">typename</span> ContextType,
          <span class="hljs-keyword">typename</span> Finalizer,
          <span class="hljs-keyword">typename</span> FinalizerDataType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> ThreadSafeFunction <span class="hljs-title">ThreadSafeFunction::New</span><span class="hljs-params">(napi_env env,
                                                  <span class="hljs-keyword">const</span> Function&amp; callback,
                                                  <span class="hljs-keyword">const</span> Object&amp; resource,
                                                  ResourceString resourceName,
                                                  <span class="hljs-keyword">size_t</span> maxQueueSize,
                                                  <span class="hljs-keyword">size_t</span> initialThreadCount,
                                                  ContextType* context,
                                                  Finalizer finalizeCallback,
                                                  FinalizerDataType* data,
                                                  napi_finalize wrapper)</span> </span>{
  <span class="hljs-keyword">static_assert</span>(details::can_make_string&lt;ResourceString&gt;::value ||
                    <span class="hljs-built_in">std</span>::is_convertible&lt;ResourceString, napi_value&gt;::value,
                <span class="hljs-string">"Resource name should be convertible to the string type"</span>);

  ThreadSafeFunction tsfn;
  <span class="hljs-keyword">auto</span>* finalizeData = <span class="hljs-keyword">new</span> details::
      ThreadSafeFinalize&lt;ContextType, Finalizer, FinalizerDataType&gt;(
          {data, finalizeCallback});
  napi_status status =
      napi_create_threadsafe_function(env,
                                      callback,
                                      resource,
                                      Value::From(env, resourceName),
                                      maxQueueSize,
                                      initialThreadCount,
                                      finalizeData,
                                      wrapper,
                                      context,
                                      CallJS,
                                      &amp;tsfn._tsfn);
  <span class="hljs-keyword">if</span> (status != napi_ok) {
    <span class="hljs-keyword">delete</span> finalizeData;
    NAPI_THROW_IF_FAILED(env, status, ThreadSafeFunction());
  }

  <span class="hljs-keyword">return</span> tsfn;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> napi_status <span class="hljs-title">ThreadSafeFunction::CallInternal</span><span class="hljs-params">(
    CallbackWrapper* callbackWrapper,
    napi_threadsafe_function_call_mode mode)</span> <span class="hljs-keyword">const</span> </span>{
  napi_status status =
      napi_call_threadsafe_function(_tsfn, callbackWrapper, mode);
  <span class="hljs-keyword">if</span> (status != napi_ok &amp;&amp; callbackWrapper != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">delete</span> callbackWrapper;
  }

  <span class="hljs-keyword">return</span> status;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<p>static</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThreadSafeFunction::CallJS</span><span class="hljs-params">(napi_env env,
                                       napi_value jsCallback,
                                       <span class="hljs-keyword">void</span>* <span class="hljs-comment">/* context */</span>,
                                       <span class="hljs-keyword">void</span>* data)</span> </span>{
  <span class="hljs-keyword">if</span> (env == <span class="hljs-literal">nullptr</span> &amp;&amp; jsCallback == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span>;
  }

  details::WrapVoidCallback([&amp;]() {
    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) {
      <span class="hljs-keyword">auto</span>* callbackWrapper = <span class="hljs-keyword">static_cast</span>&lt;CallbackWrapper*&gt;(data);
      (*callbackWrapper)(env, Function(env, jsCallback));
      <span class="hljs-keyword">delete</span> callbackWrapper;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jsCallback != <span class="hljs-literal">nullptr</span>) {
      Function(env, jsCallback).Call({});
    }
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Async Progress Worker Base class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> AsyncProgressWorkerBase&lt;DataType&gt;::AsyncProgressWorkerBase(
    <span class="hljs-keyword">const</span> Object&amp; receiver,
    <span class="hljs-keyword">const</span> Function&amp; callback,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    <span class="hljs-keyword">size_t</span> queue_size)
    : AsyncWorker(receiver, callback, resource_name, resource) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<p>Fill all possible arguments to work around ambiguous
ThreadSafeFunction::New signatures.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  _tsfn = ThreadSafeFunction::New(callback.Env(),
                                  callback,
                                  resource,
                                  resource_name,
                                  queue_size,
                                  <span class="hljs-comment">/** initialThreadCount */</span> <span class="hljs-number">1</span>,
                                  <span class="hljs-comment">/** context */</span> <span class="hljs-keyword">this</span>,
                                  OnThreadSafeFunctionFinalize,
                                  <span class="hljs-comment">/** finalizeData */</span> <span class="hljs-keyword">this</span>);
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 4</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> AsyncProgressWorkerBase&lt;DataType&gt;::AsyncProgressWorkerBase(
    Napi::Env env,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
    <span class="hljs-keyword">const</span> Object&amp; resource,
    <span class="hljs-keyword">size_t</span> queue_size)
    : AsyncWorker(env, resource_name, resource) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<p>TODO: Once the changes to make the callback optional for threadsafe
functions are available on all versions we can remove the dummy Function
here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  Function callback;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<p>Fill all possible arguments to work around ambiguous
ThreadSafeFunction::New signatures.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  _tsfn = ThreadSafeFunction::New(env,
                                  callback,
                                  resource,
                                  resource_name,
                                  queue_size,
                                  <span class="hljs-comment">/** initialThreadCount */</span> <span class="hljs-number">1</span>,
                                  <span class="hljs-comment">/** context */</span> <span class="hljs-keyword">this</span>,
                                  OnThreadSafeFunctionFinalize,
                                  <span class="hljs-comment">/** finalizeData */</span> <span class="hljs-keyword">this</span>);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> AsyncProgressWorkerBase&lt;DataType&gt;::~AsyncProgressWorkerBase() {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<p>Abort pending tsfn call.
Don't send progress events after we've already completed.
It's ok to call ThreadSafeFunction::Abort and ThreadSafeFunction::Release
duplicated.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  _tsfn.Abort();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> AsyncProgressWorkerBase&lt;DataType&gt;::OnAsyncWorkProgress(
    Napi::Env <span class="hljs-comment">/* env */</span>, Napi::Function <span class="hljs-comment">/* jsCallback */</span>, <span class="hljs-keyword">void</span>* data) {
  ThreadSafeData* tsd = <span class="hljs-keyword">static_cast</span>&lt;ThreadSafeData*&gt;(data);
  tsd-&gt;asyncprogressworker()-&gt;OnWorkProgress(tsd-&gt;data());
  <span class="hljs-keyword">delete</span> tsd;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> napi_status AsyncProgressWorkerBase&lt;DataType&gt;::NonBlockingCall(
    DataType* data) {
  <span class="hljs-keyword">auto</span> tsd = <span class="hljs-keyword">new</span> AsyncProgressWorkerBase::ThreadSafeData(<span class="hljs-keyword">this</span>, data);
  <span class="hljs-keyword">auto</span> ret = _tsfn.NonBlockingCall(tsd, OnAsyncWorkProgress);
  <span class="hljs-keyword">if</span> (ret != napi_ok) {
    <span class="hljs-keyword">delete</span> tsd;
  }
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> AsyncProgressWorkerBase&lt;DataType&gt;::OnWorkComplete(
    Napi::Env <span class="hljs-comment">/* env */</span>, napi_status status) {
  _work_completed = <span class="hljs-literal">true</span>;
  _complete_status = status;
  _tsfn.Release();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> DataType&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> AsyncProgressWorkerBase&lt;DataType&gt;::OnThreadSafeFunctionFinalize(
    Napi::Env env, <span class="hljs-keyword">void</span>* <span class="hljs-comment">/* data */</span>, AsyncProgressWorkerBase* context) {
  <span class="hljs-keyword">if</span> (context-&gt;_work_completed) {
    context-&gt;AsyncWorker::OnWorkComplete(env, context-&gt;_complete_status);
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-126" id="section-126"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Async Progress Worker class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Function&amp; callback)
    : AsyncProgressWorker(callback, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Function&amp; callback,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressWorker(
          callback, resource_name, Object::New(callback.Env())) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Function&amp; callback,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
                                                   <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressWorker(
          Object::New(callback.Env()), callback, resource_name, resource) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Object&amp; receiver,
                                                   <span class="hljs-keyword">const</span> Function&amp; callback)
    : AsyncProgressWorker(receiver, callback, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Object&amp; receiver,
                                                   <span class="hljs-keyword">const</span> Function&amp; callback,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressWorker(
          receiver, callback, resource_name, Object::New(callback.Env())) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(<span class="hljs-keyword">const</span> Object&amp; receiver,
                                                   <span class="hljs-keyword">const</span> Function&amp; callback,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
                                                   <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressWorkerBase(receiver, callback, resource_name, resource),
      _asyncdata(<span class="hljs-literal">nullptr</span>),
      _asyncsize(<span class="hljs-number">0</span>),
      _signaled(<span class="hljs-literal">false</span>) {}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 4</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(Napi::Env env)
    : AsyncProgressWorker(env, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(Napi::Env env,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressWorker(env, resource_name, Object::New(env)) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:AsyncProgressWorker(Napi::Env env,
                                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
                                                   <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressWorkerBase(env, resource_name, resource),
      _asyncdata(<span class="hljs-literal">nullptr</span>),
      _asyncsize(<span class="hljs-number">0</span>) {}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:~AsyncProgressWorker() {
  {
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;_mutex)</span></span>;
    _asyncdata = <span class="hljs-literal">nullptr</span>;
    _asyncsize = <span class="hljs-number">0</span>;
  }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:Execute() {
  <span class="hljs-function">ExecutionProgress <span class="hljs-title">progress</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
  Execute(progress);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:OnWorkProgress(<span class="hljs-keyword">void</span>*) {
  T* data;
  <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>;
  <span class="hljs-keyword">bool</span> signaled;
  {
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;_mutex)</span></span>;
    data = <span class="hljs-keyword">this</span>-&gt;_asyncdata;
    <span class="hljs-built_in">size</span> = <span class="hljs-keyword">this</span>-&gt;_asyncsize;
    signaled = <span class="hljs-keyword">this</span>-&gt;_signaled;
    <span class="hljs-keyword">this</span>-&gt;_asyncdata = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">this</span>-&gt;_asyncsize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>-&gt;_signaled = <span class="hljs-literal">false</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-127" id="section-127"></a>
</div>
<div class="dox">
<div class="summary">
<p>The callback of ThreadSafeFunction is not been invoked immediately on the
callback of uv_async_t (uv io poll), rather the callback of TSFN is
invoked on the right next uv idle callback. There are chances that during
the deferring the signal of uv_async_t is been sent again, i.e. potential
not coalesced two calls of the TSFN callback.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">  <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span> &amp;&amp; !signaled) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">this</span>-&gt;OnProgress(data, <span class="hljs-built_in">size</span>);
  <span class="hljs-keyword">delete</span>[] data;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:SendProgress_(<span class="hljs-keyword">const</span> T* data, <span class="hljs-keyword">size_t</span> count) {
  T* new_data = <span class="hljs-keyword">new</span> T[count];
  <span class="hljs-built_in">std</span>::copy(data, data + count, new_data);

  T* old_data;
  {
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;_mutex)</span></span>;
    old_data = _asyncdata;
    _asyncdata = new_data;
    _asyncsize = count;
    _signaled = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">this</span>-&gt;NonBlockingCall(<span class="hljs-literal">nullptr</span>);

  <span class="hljs-keyword">delete</span>[] old_data;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:Signal() {
  {
    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;_mutex)</span></span>;
    _signaled = <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">this</span>-&gt;NonBlockingCall(<span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-literal">nullptr</span>));
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:ExecutionProgress::Signal() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">this</span>-&gt;_worker-&gt;Signal();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressWorker</span>&lt;T&gt;:</span>:ExecutionProgress::Send(
    <span class="hljs-keyword">const</span> T* data, <span class="hljs-keyword">size_t</span> count) <span class="hljs-keyword">const</span> {
  _worker-&gt;SendProgress_(data, count);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Async Progress Queue Worker class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Function&amp; callback)
    : AsyncProgressQueueWorker(callback, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressQueueWorker(
          callback, resource_name, Object::New(callback.Env())) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name, <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressQueueWorker(
          Object::New(callback.Env()), callback, resource_name, resource) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Object&amp; receiver, <span class="hljs-keyword">const</span> Function&amp; callback)
    : AsyncProgressQueueWorker(receiver, callback, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Object&amp; receiver, <span class="hljs-keyword">const</span> Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressQueueWorker(
          receiver, callback, resource_name, Object::New(callback.Env())) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    <span class="hljs-keyword">const</span> Object&amp; receiver,
    <span class="hljs-keyword">const</span> Function&amp; callback,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name,
    <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressWorkerBase&lt;<span class="hljs-built_in">std</span>::pair&lt;T*, <span class="hljs-keyword">size_t</span>&gt;&gt;(
          receiver,
          callback,
          resource_name,
          resource,
          <span class="hljs-comment">/** unlimited queue size */</span> <span class="hljs-number">0</span>) {}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 4</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(Napi::Env env)
    : AsyncProgressQueueWorker(env, <span class="hljs-string">"generic"</span>) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    Napi::Env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)
    : AsyncProgressQueueWorker(env, resource_name, Object::New(env)) {}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:AsyncProgressQueueWorker(
    Napi::Env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name, <span class="hljs-keyword">const</span> Object&amp; resource)
    : AsyncProgressWorkerBase&lt;<span class="hljs-built_in">std</span>::pair&lt;T*, <span class="hljs-keyword">size_t</span>&gt;&gt;(
          env, resource_name, resource, <span class="hljs-comment">/** unlimited queue size */</span> <span class="hljs-number">0</span>) {}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:Execute() {
  <span class="hljs-function">ExecutionProgress <span class="hljs-title">progress</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;
  Execute(progress);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:OnWorkProgress(
    <span class="hljs-built_in">std</span>::pair&lt;T*, <span class="hljs-keyword">size_t</span>&gt;* datapair) {
  <span class="hljs-keyword">if</span> (datapair == <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-keyword">return</span>;
  }

  T* data = datapair-&gt;first;
  <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span> = datapair-&gt;second;

  <span class="hljs-keyword">this</span>-&gt;OnProgress(data, <span class="hljs-built_in">size</span>);
  <span class="hljs-keyword">delete</span> datapair;
  <span class="hljs-keyword">delete</span>[] data;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:SendProgress_(<span class="hljs-keyword">const</span> T* data,
                                                       <span class="hljs-keyword">size_t</span> count) {
  T* new_data = <span class="hljs-keyword">new</span> T[count];
  <span class="hljs-built_in">std</span>::copy(data, data + count, new_data);

  <span class="hljs-keyword">auto</span> pair = <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::pair&lt;T*, <span class="hljs-keyword">size_t</span>&gt;(new_data, count);
  <span class="hljs-keyword">this</span>-&gt;NonBlockingCall(pair);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:Signal() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">this</span>-&gt;SendProgress_(<span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-literal">nullptr</span>), <span class="hljs-number">0</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:OnWorkComplete(Napi::Env env,
                                                        napi_status status) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<p>Draining queued items in TSFN.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  AsyncProgressWorkerBase&lt;<span class="hljs-built_in">std</span>::pair&lt;T*, <span class="hljs-keyword">size_t</span>&gt;&gt;::OnWorkComplete(env, status);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:ExecutionProgress::Signal() <span class="hljs-keyword">const</span> {
  _worker-&gt;SendProgress_(<span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-literal">nullptr</span>), <span class="hljs-number">0</span>);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">AsyncProgressQueueWorker</span>&lt;T&gt;:</span>:ExecutionProgress::Send(
    <span class="hljs-keyword">const</span> T* data, <span class="hljs-keyword">size_t</span> count) <span class="hljs-keyword">const</span> {
  _worker-&gt;SendProgress_(data, count);
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAPI_VERSION &gt; 3 &amp;&amp; NAPI_HAS_THREADS</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Memory Management class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int64_t</span> <span class="hljs-title">MemoryManagement::AdjustExternalMemory</span><span class="hljs-params">(Env env,
                                                      <span class="hljs-keyword">int64_t</span> change_in_bytes)</span> </span>{
  <span class="hljs-keyword">int64_t</span> result;
  napi_status status =
      napi_adjust_external_memory(env, change_in_bytes, &amp;result);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Version Management class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">VersionManagement::GetNapiVersion</span><span class="hljs-params">(Env env)</span> </span>{
  <span class="hljs-keyword">uint32_t</span> result;
  napi_status status = napi_get_version(env, &amp;result);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> napi_node_version* <span class="hljs-title">VersionManagement::GetNodeVersion</span><span class="hljs-params">(Env env)</span> </span>{
  <span class="hljs-keyword">const</span> napi_node_version* result;
  napi_status status = napi_get_node_version(env, &amp;result);
  NAPI_THROW_IF_FAILED(env, status, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAPI_VERSION &gt; 5</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<p>//////////////////////////////////////////////////////////////////////////////
Addon<T> class
//////////////////////////////////////////////////////////////////////////////</p>

        </td>
        <td class="code highlight">
          <pre class="c">
template &lt;typename T&gt;
inline Object Addon&lt;T&gt;::Init(Env env, Object exports) {
  T* addon = new T(env, exports);
  env.SetInstanceData(addon);
  return addon-&gt;entry_point_;
}

template &lt;typename T&gt;
inline T* Addon&lt;T&gt;::Unwrap(Object wrapper) {
  return wrapper.Env().GetInstanceData&lt;T&gt;();
}

template &lt;typename T&gt;
inline void Addon&lt;T&gt;::DefineAddon(
    Object exports, const std::initializer_list&lt;AddonProp&gt;&amp; props) {
  DefineProperties(exports, props);
  entry_point_ = exports;
}

template &lt;typename T&gt;
inline Napi::Object Addon&lt;T&gt;::DefineProperties(
    Object object, const std::initializer_list&lt;AddonProp&gt;&amp; props) {
  const napi_property_descriptor* properties =
      reinterpret_cast&lt;const napi_property_descriptor*&gt;(props.begin());
  size_t size = props.size();
  napi_status status =
      napi_define_properties(object.Env(), object, size, properties);
  NAPI_THROW_IF_FAILED(object.Env(), status, object);
  for (size_t idx = 0; idx &lt; size; idx++)
    T::AttachPropData(object.Env(), object, &amp;properties[idx]);
  return object;
}
#endif  // NAPI_VERSION &gt; 5

#if NAPI_VERSION &gt; 2
template &lt;typename Hook, typename Arg&gt;
Env::CleanupHook&lt;Hook, Arg&gt; Env::AddCleanupHook(Hook hook, Arg* arg) {
  return CleanupHook&lt;Hook, Arg&gt;(*this, hook, arg);
}

template &lt;typename Hook&gt;
Env::CleanupHook&lt;Hook&gt; Env::AddCleanupHook(Hook hook) {
  return CleanupHook&lt;Hook&gt;(*this, hook);
}

template &lt;typename Hook, typename Arg&gt;
Env::CleanupHook&lt;Hook, Arg&gt;::CleanupHook() {
  data = nullptr;
}

template &lt;typename Hook, typename Arg&gt;
Env::CleanupHook&lt;Hook, Arg&gt;::CleanupHook(Napi::Env env, Hook hook)
    : wrapper(Env::CleanupHook&lt;Hook, Arg&gt;::Wrapper) {
  data = new CleanupData{std::move(hook), nullptr};
  napi_status status = napi_add_env_cleanup_hook(env, wrapper, data);
  if (status != napi_ok) {
    delete data;
    data = nullptr;
  }
}

template &lt;typename Hook, typename Arg&gt;
Env::CleanupHook&lt;Hook, Arg&gt;::CleanupHook(Napi::Env env, Hook hook, Arg* arg)
    : wrapper(Env::CleanupHook&lt;Hook, Arg&gt;::WrapperWithArg) {
  data = new CleanupData{std::move(hook), arg};
  napi_status status = napi_add_env_cleanup_hook(env, wrapper, data);
  if (status != napi_ok) {
    delete data;
    data = nullptr;
  }
}

template &lt;class Hook, class Arg&gt;
bool Env::CleanupHook&lt;Hook, Arg&gt;::Remove(Env env) {
  napi_status status = napi_remove_env_cleanup_hook(env, wrapper, data);
  delete data;
  data = nullptr;
  return status == napi_ok;
}

template &lt;class Hook, class Arg&gt;
bool Env::CleanupHook&lt;Hook, Arg&gt;::IsEmpty() const {
  return data == nullptr;
}
#endif  // NAPI_VERSION &gt; 2

#ifdef NAPI_CPP_CUSTOM_NAMESPACE
}  // namespace NAPI_CPP_CUSTOM_NAMESPACE
#endif

}  // namespace Napi

#endif  // SRC_NAPI_INL_H_

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
