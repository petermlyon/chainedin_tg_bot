<!DOCTYPE html>
<html>
<head>
  <title>argon2.cpp</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/argon2/argon2.cpp";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>argon2.cpp</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="cpp">#include "argon2/include/argon2.h"

#include &lt;napi.h&gt;
#include &lt;string&gt;

namespace {

class HashWorker final : public Napi::AsyncWorker {
public:
    HashWorker(const Napi::Env &amp;env, const Napi::Buffer&lt;uint8_t&gt; &amp;plain,
               const Napi::Buffer&lt;uint8_t&gt; &amp;salt,
               const Napi::Buffer&lt;uint8_t&gt; &amp;secret,
               const Napi::Buffer&lt;uint8_t&gt; &amp;ad, uint32_t hash_length,
               uint32_t memory_cost, uint32_t time_cost, uint32_t parallelism,
               uint32_t version, uint32_t type)
        : AsyncWorker{env, "argon2:HashWorker"}, deferred{env},
          plain{plain.Data(), plain.ByteLength()},
          salt{salt.Data(), salt.ByteLength()},
          secret{secret.Data(), secret.ByteLength()},
          ad{ad.Data(), ad.ByteLength()}, hash_length{hash_length},
          memory_cost{memory_cost}, time_cost{time_cost},
          parallelism{parallelism}, version{version},
          type{static_cast&lt;argon2_type&gt;(type)} {}

    auto GetPromise() -&gt; Napi::Promise { return deferred.Promise(); }

protected:
    void Execute() override {
        hash.resize(hash_length);

        argon2_context ctx;
        ctx.out = hash.data();
        ctx.outlen = static_cast&lt;uint32_t&gt;(hash.size());
        ctx.pwd = plain.data();
        ctx.pwdlen = static_cast&lt;uint32_t&gt;(plain.size());
        ctx.salt = salt.data();
        ctx.saltlen = static_cast&lt;uint32_t&gt;(salt.size());
        ctx.secret = secret.empty() ? nullptr : secret.data();
        ctx.secretlen = static_cast&lt;uint32_t&gt;(secret.size());
        ctx.ad = ad.empty() ? nullptr : ad.data();
        ctx.adlen = static_cast&lt;uint32_t&gt;(ad.size());
        ctx.m_cost = memory_cost;
        ctx.t_cost = time_cost;
        ctx.lanes = parallelism;
        ctx.threads = parallelism;
        ctx.allocate_cbk = nullptr;
        ctx.free_cbk = nullptr;
        ctx.flags = ARGON2_FLAG_CLEAR_PASSWORD | ARGON2_FLAG_CLEAR_SECRET;
        ctx.version = version;

        if (const int result = argon2_ctx(&amp;ctx, type); result != ARGON2_OK) {
            /* LCOV_EXCL_START */
            SetError(argon2_error_message(result));
            /* LCOV_EXCL_STOP */
        }
    }

    void OnOK() override {
        deferred.Resolve(
            Napi::Buffer&lt;uint8_t&gt;::Copy(Env(), hash.data(), hash.size()));
    }

    void OnError(const Napi::Error &amp;err) override {
        deferred.Reject(err.Value());
    }

private:
    using ustring = std::basic_string&lt;uint8_t&gt;;

    Napi::Promise::Deferred deferred;
    ustring hash = {};

    ustring plain;
    ustring salt;
    ustring secret;
    ustring ad;

    uint32_t hash_length;
    uint32_t memory_cost;
    uint32_t time_cost;
    uint32_t parallelism;
    uint32_t version;

    argon2_type type;
};

auto Hash(const Napi::CallbackInfo &amp;info) -&gt; Napi::Value {
    NAPI_CHECK(info.Length() == 1, "Hash", "expected 1 argument");

    const auto &amp;args = info[0].As&lt;Napi::Object&gt;();
    auto *worker = new HashWorker{info.Env(),
                                  args["password"].As&lt;Napi::Buffer&lt;uint8_t&gt;&gt;(),
                                  args["salt"].As&lt;Napi::Buffer&lt;uint8_t&gt;&gt;(),
                                  args["secret"].As&lt;Napi::Buffer&lt;uint8_t&gt;&gt;(),
                                  args["data"].As&lt;Napi::Buffer&lt;uint8_t&gt;&gt;(),
                                  args["hashLength"].ToNumber(),
                                  args["m"].ToNumber(),
                                  args["t"].ToNumber(),
                                  args["p"].ToNumber(),
                                  args["version"].ToNumber(),
                                  args["type"].ToNumber()};

    worker-&gt;Queue();
    return worker-&gt;GetPromise();
}

auto init(Napi::Env env, Napi::Object exports) -&gt; Napi::Object {
    exports["hash"] = Napi::Function::New(env, Hash);
    return exports;
}

} // namespace

NODE_API_MODULE(argon2_lib, init)

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
